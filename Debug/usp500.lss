
usp500.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000289c  00000000  00000000  00010000  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .relocate     00000000  20000000  20000000  0001289c  2**0
                  CONTENTS
  2 .bss          00000460  20000000  20000000  00020000  2**4
                  ALLOC
  3 .stack        00002000  20000460  20000460  00020000  2**0
                  ALLOC
  4 .ARM.attributes 00000028  00000000  00000000  0001289c  2**0
                  CONTENTS, READONLY
  5 .comment      00000059  00000000  00000000  000128c4  2**0
                  CONTENTS, READONLY
  6 .debug_info   0002b3b2  00000000  00000000  0001291d  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000038c8  00000000  00000000  0003dccf  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_loc    00016ac5  00000000  00000000  00041597  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_aranges 00000f78  00000000  00000000  0005805c  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_ranges 000010d0  00000000  00000000  00058fd4  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_macro  00022e74  00000000  00000000  0005a0a4  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_line   0001609f  00000000  00000000  0007cf18  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_str    000b0ff1  00000000  00000000  00092fb7  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_frame  000027a0  00000000  00000000  00143fa8  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <exception_table>:
       0:	60 24 00 20 2d 01 00 00 29 01 00 00 29 01 00 00     `$. -...)...)...
	...
      2c:	15 23 00 00 00 00 00 00 00 00 00 00 31 23 00 00     .#..........1#..
      3c:	75 23 00 00 29 01 00 00 29 01 00 00 29 01 00 00     u#..)...)...)...
      4c:	15 18 00 00 29 01 00 00 29 01 00 00 29 01 00 00     ....)...)...)...
      5c:	51 16 00 00 29 01 00 00 29 01 00 00 29 01 00 00     Q...)...)...)...
      6c:	29 01 00 00 29 01 00 00 29 01 00 00 29 01 00 00     )...)...)...)...
      7c:	29 01 00 00 29 01 00 00 29 01 00 00 29 01 00 00     )...)...)...)...
      8c:	29 01 00 00 29 01 00 00 29 01 00 00 29 01 00 00     )...)...)...)...
      9c:	29 01 00 00 29 01 00 00 29 01 00 00 29 01 00 00     )...)...)...)...
      ac:	29 01 00 00 29 01 00 00 29 01 00 00 29 01 00 00     )...)...)...)...

000000bc <__do_global_dtors_aux>:
      bc:	b510      	push	{r4, lr}
      be:	4c06      	ldr	r4, [pc, #24]	; (d8 <__do_global_dtors_aux+0x1c>)
      c0:	7823      	ldrb	r3, [r4, #0]
      c2:	2b00      	cmp	r3, #0
      c4:	d107      	bne.n	d6 <__do_global_dtors_aux+0x1a>
      c6:	4b05      	ldr	r3, [pc, #20]	; (dc <__do_global_dtors_aux+0x20>)
      c8:	2b00      	cmp	r3, #0
      ca:	d002      	beq.n	d2 <__do_global_dtors_aux+0x16>
      cc:	4804      	ldr	r0, [pc, #16]	; (e0 <__do_global_dtors_aux+0x24>)
      ce:	e000      	b.n	d2 <__do_global_dtors_aux+0x16>
      d0:	bf00      	nop
      d2:	2301      	movs	r3, #1
      d4:	7023      	strb	r3, [r4, #0]
      d6:	bd10      	pop	{r4, pc}
      d8:	20000000 	.word	0x20000000
      dc:	00000000 	.word	0x00000000
      e0:	0000289c 	.word	0x0000289c

000000e4 <frame_dummy>:
      e4:	4b08      	ldr	r3, [pc, #32]	; (108 <frame_dummy+0x24>)
      e6:	b510      	push	{r4, lr}
      e8:	2b00      	cmp	r3, #0
      ea:	d003      	beq.n	f4 <frame_dummy+0x10>
      ec:	4907      	ldr	r1, [pc, #28]	; (10c <frame_dummy+0x28>)
      ee:	4808      	ldr	r0, [pc, #32]	; (110 <frame_dummy+0x2c>)
      f0:	e000      	b.n	f4 <frame_dummy+0x10>
      f2:	bf00      	nop
      f4:	4807      	ldr	r0, [pc, #28]	; (114 <frame_dummy+0x30>)
      f6:	6803      	ldr	r3, [r0, #0]
      f8:	2b00      	cmp	r3, #0
      fa:	d100      	bne.n	fe <frame_dummy+0x1a>
      fc:	bd10      	pop	{r4, pc}
      fe:	4b06      	ldr	r3, [pc, #24]	; (118 <frame_dummy+0x34>)
     100:	2b00      	cmp	r3, #0
     102:	d0fb      	beq.n	fc <frame_dummy+0x18>
     104:	4798      	blx	r3
     106:	e7f9      	b.n	fc <frame_dummy+0x18>
     108:	00000000 	.word	0x00000000
     10c:	20000004 	.word	0x20000004
     110:	0000289c 	.word	0x0000289c
     114:	0000289c 	.word	0x0000289c
     118:	00000000 	.word	0x00000000

0000011c <atmel_start_init>:

/**
 * Initializes MCU, drivers and middleware in the project
 **/
void atmel_start_init(void)
{
     11c:	b510      	push	{r4, lr}
	system_init();
     11e:	4b01      	ldr	r3, [pc, #4]	; (124 <atmel_start_init+0x8>)
     120:	4798      	blx	r3
}
     122:	bd10      	pop	{r4, pc}
     124:	00000afd 	.word	0x00000afd

00000128 <Dummy_Handler>:

/**
 * \brief Default interrupt handler for unused IRQs.
 */
void Dummy_Handler(void)
{
     128:	e7fe      	b.n	128 <Dummy_Handler>
	...

0000012c <Reset_Handler>:
{
     12c:	b510      	push	{r4, lr}
        if (pSrc != pDest) {
     12e:	4a10      	ldr	r2, [pc, #64]	; (170 <Reset_Handler+0x44>)
     130:	4b10      	ldr	r3, [pc, #64]	; (174 <Reset_Handler+0x48>)
     132:	429a      	cmp	r2, r3
     134:	d009      	beq.n	14a <Reset_Handler+0x1e>
     136:	4b0f      	ldr	r3, [pc, #60]	; (174 <Reset_Handler+0x48>)
     138:	4a0d      	ldr	r2, [pc, #52]	; (170 <Reset_Handler+0x44>)
     13a:	e003      	b.n	144 <Reset_Handler+0x18>
                        *pDest++ = *pSrc++;
     13c:	6811      	ldr	r1, [r2, #0]
     13e:	6019      	str	r1, [r3, #0]
     140:	3304      	adds	r3, #4
     142:	3204      	adds	r2, #4
                for (; pDest < &_erelocate;) {
     144:	490c      	ldr	r1, [pc, #48]	; (178 <Reset_Handler+0x4c>)
     146:	428b      	cmp	r3, r1
     148:	d3f8      	bcc.n	13c <Reset_Handler+0x10>
                        *pDest++ = *pSrc++;
     14a:	4b0c      	ldr	r3, [pc, #48]	; (17c <Reset_Handler+0x50>)
     14c:	e002      	b.n	154 <Reset_Handler+0x28>
                *pDest++ = 0;
     14e:	2200      	movs	r2, #0
     150:	601a      	str	r2, [r3, #0]
     152:	3304      	adds	r3, #4
        for (pDest = &_szero; pDest < &_ezero;) {
     154:	4a0a      	ldr	r2, [pc, #40]	; (180 <Reset_Handler+0x54>)
     156:	4293      	cmp	r3, r2
     158:	d3f9      	bcc.n	14e <Reset_Handler+0x22>
        SCB->VTOR = ((uint32_t) pSrc & SCB_VTOR_TBLOFF_Msk);
     15a:	4a0a      	ldr	r2, [pc, #40]	; (184 <Reset_Handler+0x58>)
     15c:	21ff      	movs	r1, #255	; 0xff
     15e:	4b0a      	ldr	r3, [pc, #40]	; (188 <Reset_Handler+0x5c>)
     160:	438b      	bics	r3, r1
     162:	6093      	str	r3, [r2, #8]
        __libc_init_array();
     164:	4b09      	ldr	r3, [pc, #36]	; (18c <Reset_Handler+0x60>)
     166:	4798      	blx	r3
        main();
     168:	4b09      	ldr	r3, [pc, #36]	; (190 <Reset_Handler+0x64>)
     16a:	4798      	blx	r3
     16c:	e7fe      	b.n	16c <Reset_Handler+0x40>
     16e:	46c0      	nop			; (mov r8, r8)
     170:	0000289c 	.word	0x0000289c
     174:	20000000 	.word	0x20000000
     178:	20000000 	.word	0x20000000
     17c:	20000000 	.word	0x20000000
     180:	20000460 	.word	0x20000460
     184:	e000ed00 	.word	0xe000ed00
     188:	00000000 	.word	0x00000000
     18c:	00002629 	.word	0x00002629
     190:	000022b5 	.word	0x000022b5

00000194 <ADC_A_init>:
 * \brief ADC initialization function
 *
 * Enables ADC peripheral, clocks and initializes ADC driver
 */
static void ADC_A_init(void)
{
     194:	b510      	push	{r4, lr}
}

static inline void hri_mclk_set_APBCMASK_ADC1_bit(const void *const hw)
{
	MCLK_CRITICAL_SECTION_ENTER();
	((Mclk *)hw)->APBCMASK.reg |= MCLK_APBCMASK_ADC1;
     196:	4a16      	ldr	r2, [pc, #88]	; (1f0 <ADC_A_init+0x5c>)
     198:	69d1      	ldr	r1, [r2, #28]
     19a:	2380      	movs	r3, #128	; 0x80
     19c:	02db      	lsls	r3, r3, #11
     19e:	430b      	orrs	r3, r1
     1a0:	61d3      	str	r3, [r2, #28]
}

static inline void hri_gclk_write_PCHCTRL_reg(const void *const hw, uint8_t index, hri_gclk_pchctrl_reg_t data)
{
	GCLK_CRITICAL_SECTION_ENTER();
	((Gclk *)hw)->PCHCTRL[index].reg = data;
     1a2:	2140      	movs	r1, #64	; 0x40
     1a4:	2384      	movs	r3, #132	; 0x84
     1a6:	005b      	lsls	r3, r3, #1
     1a8:	4a12      	ldr	r2, [pc, #72]	; (1f4 <ADC_A_init+0x60>)
     1aa:	50d1      	str	r1, [r2, r3]
	hri_mclk_set_APBCMASK_ADC1_bit(MCLK);
	hri_gclk_write_PCHCTRL_reg(GCLK, ADC1_GCLK_ID, CONF_GCLK_ADC1_SRC | (1 << GCLK_PCHCTRL_CHEN_Pos));

	adc_dma_init(&ADC_A, ADC1);
     1ac:	4912      	ldr	r1, [pc, #72]	; (1f8 <ADC_A_init+0x64>)
     1ae:	4813      	ldr	r0, [pc, #76]	; (1fc <ADC_A_init+0x68>)
     1b0:	4b13      	ldr	r3, [pc, #76]	; (200 <ADC_A_init+0x6c>)
     1b2:	4798      	blx	r3
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = ~data;
}

static inline void hri_port_clear_DIR_reg(const void *const hw, uint8_t submodule_index, hri_port_dir_reg_t mask)
{
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = mask;
     1b4:	2120      	movs	r1, #32
     1b6:	2384      	movs	r3, #132	; 0x84
     1b8:	22c0      	movs	r2, #192	; 0xc0
     1ba:	05d2      	lsls	r2, r2, #23
     1bc:	50d1      	str	r1, [r2, r3]

static inline void hri_port_write_WRCONFIG_reg(const void *const hw, uint8_t submodule_index,
                                               hri_port_wrconfig_reg_t data)
{
	PORT_CRITICAL_SECTION_ENTER();
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     1be:	2282      	movs	r2, #130	; 0x82
     1c0:	05d2      	lsls	r2, r2, #23
     1c2:	3324      	adds	r3, #36	; 0x24
     1c4:	490f      	ldr	r1, [pc, #60]	; (204 <ADC_A_init+0x70>)
     1c6:	50d1      	str	r1, [r2, r3]
     1c8:	21c0      	movs	r1, #192	; 0xc0
     1ca:	0609      	lsls	r1, r1, #24
     1cc:	50d1      	str	r1, [r2, r3]
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     1ce:	21c5      	movs	r1, #197	; 0xc5
     1d0:	5c53      	ldrb	r3, [r2, r1]
	tmp &= ~PORT_PINCFG_PMUXEN;
     1d2:	2001      	movs	r0, #1
     1d4:	4383      	bics	r3, r0
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
     1d6:	4303      	orrs	r3, r0
     1d8:	b2db      	uxtb	r3, r3
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     1da:	5453      	strb	r3, [r2, r1]
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
     1dc:	3913      	subs	r1, #19
     1de:	5c53      	ldrb	r3, [r2, r1]
	tmp &= ~PORT_PMUX_PMUXO_Msk;
     1e0:	200f      	movs	r0, #15
     1e2:	4003      	ands	r3, r0
	tmp |= PORT_PMUX_PMUXO(data);
     1e4:	2010      	movs	r0, #16
     1e6:	4303      	orrs	r3, r0
     1e8:	b2db      	uxtb	r3, r3
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
     1ea:	5453      	strb	r3, [r2, r1]

	// Disable digital pin circuitry
	gpio_set_pin_direction(MAX14752_OUT, GPIO_DIRECTION_OFF);

	gpio_set_pin_function(MAX14752_OUT, PINMUX_PB05B_ADC1_AIN7);
}
     1ec:	bd10      	pop	{r4, pc}
     1ee:	46c0      	nop			; (mov r8, r8)
     1f0:	40000800 	.word	0x40000800
     1f4:	40001c00 	.word	0x40001c00
     1f8:	42004800 	.word	0x42004800
     1fc:	2000027c 	.word	0x2000027c
     200:	00001021 	.word	0x00001021
     204:	40000020 	.word	0x40000020

00000208 <ADC_B_init>:
{
     208:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
     20a:	46de      	mov	lr, fp
     20c:	4657      	mov	r7, sl
     20e:	464e      	mov	r6, r9
     210:	4645      	mov	r5, r8
     212:	b5e0      	push	{r5, r6, r7, lr}
	((Mclk *)hw)->APBCMASK.reg |= MCLK_APBCMASK_ADC0;
     214:	4a7e      	ldr	r2, [pc, #504]	; (410 <ADC_B_init+0x208>)
     216:	69d1      	ldr	r1, [r2, #28]
     218:	2380      	movs	r3, #128	; 0x80
     21a:	029b      	lsls	r3, r3, #10
     21c:	430b      	orrs	r3, r1
     21e:	61d3      	str	r3, [r2, #28]
     220:	2540      	movs	r5, #64	; 0x40
     222:	4b7c      	ldr	r3, [pc, #496]	; (414 <ADC_B_init+0x20c>)
     224:	2282      	movs	r2, #130	; 0x82
     226:	0052      	lsls	r2, r2, #1
     228:	509d      	str	r5, [r3, r2]
	adc_dma_init(&ADC_B, ADC0);
     22a:	497b      	ldr	r1, [pc, #492]	; (418 <ADC_B_init+0x210>)
     22c:	487b      	ldr	r0, [pc, #492]	; (41c <ADC_B_init+0x214>)
     22e:	4b7c      	ldr	r3, [pc, #496]	; (420 <ADC_B_init+0x218>)
     230:	4798      	blx	r3
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = mask;
     232:	24c0      	movs	r4, #192	; 0xc0
     234:	05e4      	lsls	r4, r4, #23
     236:	2304      	movs	r3, #4
     238:	6063      	str	r3, [r4, #4]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     23a:	2382      	movs	r3, #130	; 0x82
     23c:	05db      	lsls	r3, r3, #23
     23e:	4a79      	ldr	r2, [pc, #484]	; (424 <ADC_B_init+0x21c>)
     240:	629a      	str	r2, [r3, #40]	; 0x28
     242:	20c0      	movs	r0, #192	; 0xc0
     244:	0600      	lsls	r0, r0, #24
     246:	6298      	str	r0, [r3, #40]	; 0x28
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     248:	2242      	movs	r2, #66	; 0x42
     24a:	4694      	mov	ip, r2
     24c:	5c9e      	ldrb	r6, [r3, r2]
	tmp &= ~PORT_PINCFG_PMUXEN;
     24e:	2101      	movs	r1, #1
     250:	438e      	bics	r6, r1
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
     252:	2201      	movs	r2, #1
     254:	4316      	orrs	r6, r2
     256:	b2f6      	uxtb	r6, r6
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     258:	4667      	mov	r7, ip
     25a:	55de      	strb	r6, [r3, r7]
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
     25c:	2631      	movs	r6, #49	; 0x31
     25e:	5d9e      	ldrb	r6, [r3, r6]
	tmp &= ~PORT_PMUX_PMUXE_Msk;
     260:	3f33      	subs	r7, #51	; 0x33
     262:	46b9      	mov	r9, r7
     264:	43be      	bics	r6, r7
	tmp |= PORT_PMUX_PMUXE(data);
     266:	4316      	orrs	r6, r2
     268:	b2f6      	uxtb	r6, r6
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
     26a:	3722      	adds	r7, #34	; 0x22
     26c:	55de      	strb	r6, [r3, r7]
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = mask;
     26e:	2680      	movs	r6, #128	; 0x80
     270:	00b6      	lsls	r6, r6, #2
     272:	46b4      	mov	ip, r6
     274:	3e7d      	subs	r6, #125	; 0x7d
     276:	3eff      	subs	r6, #255	; 0xff
     278:	4667      	mov	r7, ip
     27a:	51a7      	str	r7, [r4, r6]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     27c:	3624      	adds	r6, #36	; 0x24
     27e:	4f6a      	ldr	r7, [pc, #424]	; (428 <ADC_B_init+0x220>)
     280:	519f      	str	r7, [r3, r6]
     282:	5198      	str	r0, [r3, r6]
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     284:	3621      	adds	r6, #33	; 0x21
     286:	46b4      	mov	ip, r6
     288:	5d9e      	ldrb	r6, [r3, r6]
	tmp &= ~PORT_PINCFG_PMUXEN;
     28a:	438e      	bics	r6, r1
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
     28c:	4316      	orrs	r6, r2
     28e:	b2f6      	uxtb	r6, r6
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     290:	4667      	mov	r7, ip
     292:	55de      	strb	r6, [r3, r7]
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
     294:	26b4      	movs	r6, #180	; 0xb4
     296:	46b2      	mov	sl, r6
     298:	5d9e      	ldrb	r6, [r3, r6]
	tmp &= ~PORT_PMUX_PMUXO_Msk;
     29a:	3fba      	subs	r7, #186	; 0xba
     29c:	46b8      	mov	r8, r7
     29e:	403e      	ands	r6, r7
	tmp |= PORT_PMUX_PMUXO(data);
     2a0:	2710      	movs	r7, #16
     2a2:	46bc      	mov	ip, r7
     2a4:	4667      	mov	r7, ip
     2a6:	433e      	orrs	r6, r7
     2a8:	b2f6      	uxtb	r6, r6
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
     2aa:	4657      	mov	r7, sl
     2ac:	55de      	strb	r6, [r3, r7]
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = mask;
     2ae:	2610      	movs	r6, #16
     2b0:	6066      	str	r6, [r4, #4]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     2b2:	4e5e      	ldr	r6, [pc, #376]	; (42c <ADC_B_init+0x224>)
     2b4:	629e      	str	r6, [r3, #40]	; 0x28
     2b6:	6298      	str	r0, [r3, #40]	; 0x28
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     2b8:	2644      	movs	r6, #68	; 0x44
     2ba:	46b2      	mov	sl, r6
     2bc:	5d9e      	ldrb	r6, [r3, r6]
	tmp &= ~PORT_PINCFG_PMUXEN;
     2be:	438e      	bics	r6, r1
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
     2c0:	4316      	orrs	r6, r2
     2c2:	b2f6      	uxtb	r6, r6
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     2c4:	4657      	mov	r7, sl
     2c6:	55de      	strb	r6, [r3, r7]
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
     2c8:	2632      	movs	r6, #50	; 0x32
     2ca:	46b2      	mov	sl, r6
     2cc:	5d9e      	ldrb	r6, [r3, r6]
	tmp &= ~PORT_PMUX_PMUXE_Msk;
     2ce:	464f      	mov	r7, r9
     2d0:	43be      	bics	r6, r7
	tmp |= PORT_PMUX_PMUXE(data);
     2d2:	4316      	orrs	r6, r2
     2d4:	b2f6      	uxtb	r6, r6
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
     2d6:	4657      	mov	r7, sl
     2d8:	55de      	strb	r6, [r3, r7]
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = mask;
     2da:	2620      	movs	r6, #32
     2dc:	6066      	str	r6, [r4, #4]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     2de:	4e54      	ldr	r6, [pc, #336]	; (430 <ADC_B_init+0x228>)
     2e0:	629e      	str	r6, [r3, #40]	; 0x28
     2e2:	6298      	str	r0, [r3, #40]	; 0x28
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     2e4:	2645      	movs	r6, #69	; 0x45
     2e6:	46b3      	mov	fp, r6
     2e8:	5d9e      	ldrb	r6, [r3, r6]
	tmp &= ~PORT_PINCFG_PMUXEN;
     2ea:	438e      	bics	r6, r1
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
     2ec:	4316      	orrs	r6, r2
     2ee:	b2f6      	uxtb	r6, r6
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     2f0:	465f      	mov	r7, fp
     2f2:	55de      	strb	r6, [r3, r7]
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
     2f4:	4656      	mov	r6, sl
     2f6:	5d9e      	ldrb	r6, [r3, r6]
	tmp &= ~PORT_PMUX_PMUXO_Msk;
     2f8:	4647      	mov	r7, r8
     2fa:	403e      	ands	r6, r7
	tmp |= PORT_PMUX_PMUXO(data);
     2fc:	4667      	mov	r7, ip
     2fe:	433e      	orrs	r6, r7
     300:	b2f6      	uxtb	r6, r6
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
     302:	4657      	mov	r7, sl
     304:	55de      	strb	r6, [r3, r7]
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = mask;
     306:	6065      	str	r5, [r4, #4]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     308:	4d4a      	ldr	r5, [pc, #296]	; (434 <ADC_B_init+0x22c>)
     30a:	629d      	str	r5, [r3, #40]	; 0x28
     30c:	6298      	str	r0, [r3, #40]	; 0x28
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     30e:	2646      	movs	r6, #70	; 0x46
     310:	5d9d      	ldrb	r5, [r3, r6]
	tmp &= ~PORT_PINCFG_PMUXEN;
     312:	438d      	bics	r5, r1
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
     314:	4315      	orrs	r5, r2
     316:	b2ed      	uxtb	r5, r5
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     318:	559d      	strb	r5, [r3, r6]
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
     31a:	3e13      	subs	r6, #19
     31c:	5d9d      	ldrb	r5, [r3, r6]
	tmp &= ~PORT_PMUX_PMUXE_Msk;
     31e:	464f      	mov	r7, r9
     320:	43bd      	bics	r5, r7
	tmp |= PORT_PMUX_PMUXE(data);
     322:	4315      	orrs	r5, r2
     324:	b2ed      	uxtb	r5, r5
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
     326:	559d      	strb	r5, [r3, r6]
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = mask;
     328:	2580      	movs	r5, #128	; 0x80
     32a:	6065      	str	r5, [r4, #4]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     32c:	4d42      	ldr	r5, [pc, #264]	; (438 <ADC_B_init+0x230>)
     32e:	629d      	str	r5, [r3, #40]	; 0x28
     330:	6298      	str	r0, [r3, #40]	; 0x28
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     332:	2547      	movs	r5, #71	; 0x47
     334:	46aa      	mov	sl, r5
     336:	5d5d      	ldrb	r5, [r3, r5]
	tmp &= ~PORT_PINCFG_PMUXEN;
     338:	438d      	bics	r5, r1
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
     33a:	4315      	orrs	r5, r2
     33c:	b2ed      	uxtb	r5, r5
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     33e:	4657      	mov	r7, sl
     340:	55dd      	strb	r5, [r3, r7]
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
     342:	5d9d      	ldrb	r5, [r3, r6]
	tmp &= ~PORT_PMUX_PMUXO_Msk;
     344:	4647      	mov	r7, r8
     346:	403d      	ands	r5, r7
	tmp |= PORT_PMUX_PMUXO(data);
     348:	4667      	mov	r7, ip
     34a:	433d      	orrs	r5, r7
     34c:	b2ed      	uxtb	r5, r5
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
     34e:	559d      	strb	r5, [r3, r6]
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = mask;
     350:	2582      	movs	r5, #130	; 0x82
     352:	006d      	lsls	r5, r5, #1
     354:	5161      	str	r1, [r4, r5]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     356:	36f5      	adds	r6, #245	; 0xf5
     358:	4d38      	ldr	r5, [pc, #224]	; (43c <ADC_B_init+0x234>)
     35a:	519d      	str	r5, [r3, r6]
     35c:	5198      	str	r0, [r3, r6]
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     35e:	25a0      	movs	r5, #160	; 0xa0
     360:	006d      	lsls	r5, r5, #1
     362:	46aa      	mov	sl, r5
     364:	5d5d      	ldrb	r5, [r3, r5]
	tmp &= ~PORT_PINCFG_PMUXEN;
     366:	438d      	bics	r5, r1
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
     368:	4315      	orrs	r5, r2
     36a:	b2ed      	uxtb	r5, r5
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     36c:	4657      	mov	r7, sl
     36e:	55dd      	strb	r5, [r3, r7]
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
     370:	2598      	movs	r5, #152	; 0x98
     372:	006d      	lsls	r5, r5, #1
     374:	46aa      	mov	sl, r5
     376:	5d5d      	ldrb	r5, [r3, r5]
	tmp &= ~PORT_PMUX_PMUXE_Msk;
     378:	464f      	mov	r7, r9
     37a:	43bd      	bics	r5, r7
	tmp |= PORT_PMUX_PMUXE(data);
     37c:	4315      	orrs	r5, r2
     37e:	b2ed      	uxtb	r5, r5
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
     380:	4657      	mov	r7, sl
     382:	55dd      	strb	r5, [r3, r7]
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = mask;
     384:	2502      	movs	r5, #2
     386:	3f2c      	subs	r7, #44	; 0x2c
     388:	51e5      	str	r5, [r4, r7]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     38a:	4d2d      	ldr	r5, [pc, #180]	; (440 <ADC_B_init+0x238>)
     38c:	519d      	str	r5, [r3, r6]
     38e:	5198      	str	r0, [r3, r6]
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     390:	2542      	movs	r5, #66	; 0x42
     392:	35ff      	adds	r5, #255	; 0xff
     394:	46ab      	mov	fp, r5
     396:	5d5d      	ldrb	r5, [r3, r5]
	tmp &= ~PORT_PINCFG_PMUXEN;
     398:	438d      	bics	r5, r1
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
     39a:	4315      	orrs	r5, r2
     39c:	b2ed      	uxtb	r5, r5
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     39e:	465f      	mov	r7, fp
     3a0:	55dd      	strb	r5, [r3, r7]
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
     3a2:	4655      	mov	r5, sl
     3a4:	5d5d      	ldrb	r5, [r3, r5]
	tmp &= ~PORT_PMUX_PMUXO_Msk;
     3a6:	4647      	mov	r7, r8
     3a8:	403d      	ands	r5, r7
	tmp |= PORT_PMUX_PMUXO(data);
     3aa:	4667      	mov	r7, ip
     3ac:	433d      	orrs	r5, r7
     3ae:	b2ed      	uxtb	r5, r5
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
     3b0:	4657      	mov	r7, sl
     3b2:	55dd      	strb	r5, [r3, r7]
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = mask;
     3b4:	2504      	movs	r5, #4
     3b6:	3f2c      	subs	r7, #44	; 0x2c
     3b8:	51e5      	str	r5, [r4, r7]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     3ba:	4d1a      	ldr	r5, [pc, #104]	; (424 <ADC_B_init+0x21c>)
     3bc:	519d      	str	r5, [r3, r6]
     3be:	5198      	str	r0, [r3, r6]
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     3c0:	361a      	adds	r6, #26
     3c2:	5d9d      	ldrb	r5, [r3, r6]
	tmp &= ~PORT_PINCFG_PMUXEN;
     3c4:	438d      	bics	r5, r1
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
     3c6:	4315      	orrs	r5, r2
     3c8:	b2ed      	uxtb	r5, r5
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     3ca:	559d      	strb	r5, [r3, r6]
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
     3cc:	2632      	movs	r6, #50	; 0x32
     3ce:	36ff      	adds	r6, #255	; 0xff
     3d0:	5d9d      	ldrb	r5, [r3, r6]
	tmp &= ~PORT_PMUX_PMUXE_Msk;
     3d2:	464f      	mov	r7, r9
     3d4:	43bd      	bics	r5, r7
	tmp |= PORT_PMUX_PMUXE(data);
     3d6:	4315      	orrs	r5, r2
     3d8:	b2ed      	uxtb	r5, r5
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
     3da:	559d      	strb	r5, [r3, r6]
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = mask;
     3dc:	2508      	movs	r5, #8
     3de:	6065      	str	r5, [r4, #4]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     3e0:	4c18      	ldr	r4, [pc, #96]	; (444 <ADC_B_init+0x23c>)
     3e2:	629c      	str	r4, [r3, #40]	; 0x28
     3e4:	6298      	str	r0, [r3, #40]	; 0x28
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     3e6:	2443      	movs	r4, #67	; 0x43
     3e8:	5d18      	ldrb	r0, [r3, r4]
	tmp &= ~PORT_PINCFG_PMUXEN;
     3ea:	4388      	bics	r0, r1
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
     3ec:	4302      	orrs	r2, r0
     3ee:	b2d2      	uxtb	r2, r2
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     3f0:	551a      	strb	r2, [r3, r4]
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
     3f2:	2231      	movs	r2, #49	; 0x31
     3f4:	5c9a      	ldrb	r2, [r3, r2]
	tmp &= ~PORT_PMUX_PMUXO_Msk;
     3f6:	4641      	mov	r1, r8
     3f8:	400a      	ands	r2, r1
	tmp |= PORT_PMUX_PMUXO(data);
     3fa:	4661      	mov	r1, ip
     3fc:	430a      	orrs	r2, r1
     3fe:	b2d2      	uxtb	r2, r2
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
     400:	2131      	movs	r1, #49	; 0x31
     402:	545a      	strb	r2, [r3, r1]
}
     404:	bc3c      	pop	{r2, r3, r4, r5}
     406:	4690      	mov	r8, r2
     408:	4699      	mov	r9, r3
     40a:	46a2      	mov	sl, r4
     40c:	46ab      	mov	fp, r5
     40e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
     410:	40000800 	.word	0x40000800
     414:	40001c00 	.word	0x40001c00
     418:	42004400 	.word	0x42004400
     41c:	2000025c 	.word	0x2000025c
     420:	00001021 	.word	0x00001021
     424:	40000004 	.word	0x40000004
     428:	40000200 	.word	0x40000200
     42c:	40000010 	.word	0x40000010
     430:	40000020 	.word	0x40000020
     434:	40000040 	.word	0x40000040
     438:	40000080 	.word	0x40000080
     43c:	40000001 	.word	0x40000001
     440:	40000002 	.word	0x40000002
     444:	40000008 	.word	0x40000008

00000448 <EXTERNAL_IRQ_init>:

void EXTERNAL_IRQ_init(void)
{
     448:	b5f0      	push	{r4, r5, r6, r7, lr}
     44a:	46de      	mov	lr, fp
     44c:	4657      	mov	r7, sl
     44e:	464e      	mov	r6, r9
     450:	4645      	mov	r5, r8
     452:	b5e0      	push	{r5, r6, r7, lr}
     454:	b083      	sub	sp, #12
     456:	2140      	movs	r1, #64	; 0x40
     458:	2388      	movs	r3, #136	; 0x88
     45a:	4aaa      	ldr	r2, [pc, #680]	; (704 <EXTERNAL_IRQ_init+0x2bc>)
     45c:	50d1      	str	r1, [r2, r3]
	((Mclk *)hw)->APBAMASK.reg |= MCLK_APBAMASK_EIC;
     45e:	4aaa      	ldr	r2, [pc, #680]	; (708 <EXTERNAL_IRQ_init+0x2c0>)
     460:	6953      	ldr	r3, [r2, #20]
     462:	2180      	movs	r1, #128	; 0x80
     464:	00c9      	lsls	r1, r1, #3
     466:	430b      	orrs	r3, r1
     468:	6153      	str	r3, [r2, #20]
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = mask;
     46a:	24c0      	movs	r4, #192	; 0xc0
     46c:	05e4      	lsls	r4, r4, #23
     46e:	2382      	movs	r3, #130	; 0x82
     470:	005b      	lsls	r3, r3, #1
     472:	469a      	mov	sl, r3
     474:	3b04      	subs	r3, #4
     476:	4652      	mov	r2, sl
     478:	50a3      	str	r3, [r4, r2]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     47a:	2382      	movs	r3, #130	; 0x82
     47c:	05db      	lsls	r3, r3, #23
     47e:	2794      	movs	r7, #148	; 0x94
     480:	007f      	lsls	r7, r7, #1
     482:	4aa2      	ldr	r2, [pc, #648]	; (70c <EXTERNAL_IRQ_init+0x2c4>)
     484:	51da      	str	r2, [r3, r7]
     486:	4aa2      	ldr	r2, [pc, #648]	; (710 <EXTERNAL_IRQ_init+0x2c8>)
     488:	51da      	str	r2, [r3, r7]
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg &= ~PORT_PINCFG_PULLEN;
     48a:	22a4      	movs	r2, #164	; 0xa4
     48c:	0052      	lsls	r2, r2, #1
     48e:	4694      	mov	ip, r2
     490:	5c9a      	ldrb	r2, [r3, r2]
     492:	2004      	movs	r0, #4
     494:	4382      	bics	r2, r0
     496:	4661      	mov	r1, ip
     498:	545a      	strb	r2, [r3, r1]
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     49a:	5c5d      	ldrb	r5, [r3, r1]
	tmp &= ~PORT_PINCFG_PMUXEN;
     49c:	3948      	subs	r1, #72	; 0x48
     49e:	39ff      	subs	r1, #255	; 0xff
     4a0:	438d      	bics	r5, r1
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
     4a2:	2201      	movs	r2, #1
     4a4:	4315      	orrs	r5, r2
     4a6:	b2ed      	uxtb	r5, r5
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     4a8:	4666      	mov	r6, ip
     4aa:	559d      	strb	r5, [r3, r6]
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
     4ac:	259a      	movs	r5, #154	; 0x9a
     4ae:	006d      	lsls	r5, r5, #1
     4b0:	46a8      	mov	r8, r5
     4b2:	5d5d      	ldrb	r5, [r3, r5]
	tmp &= ~PORT_PMUX_PMUXE_Msk;
     4b4:	002e      	movs	r6, r5
     4b6:	250f      	movs	r5, #15
     4b8:	43ae      	bics	r6, r5
     4ba:	46b4      	mov	ip, r6
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
     4bc:	4646      	mov	r6, r8
     4be:	4665      	mov	r5, ip
     4c0:	559d      	strb	r5, [r3, r6]
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = mask;
     4c2:	2580      	movs	r5, #128	; 0x80
     4c4:	04ad      	lsls	r5, r5, #18
     4c6:	46ac      	mov	ip, r5
     4c8:	4655      	mov	r5, sl
     4ca:	4666      	mov	r6, ip
     4cc:	5166      	str	r6, [r4, r5]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     4ce:	4d91      	ldr	r5, [pc, #580]	; (714 <EXTERNAL_IRQ_init+0x2cc>)
     4d0:	46a9      	mov	r9, r5
     4d2:	51dd      	str	r5, [r3, r7]
     4d4:	4d90      	ldr	r5, [pc, #576]	; (718 <EXTERNAL_IRQ_init+0x2d0>)
     4d6:	51dd      	str	r5, [r3, r7]
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg &= ~PORT_PINCFG_PULLEN;
     4d8:	255a      	movs	r5, #90	; 0x5a
     4da:	35ff      	adds	r5, #255	; 0xff
     4dc:	46a8      	mov	r8, r5
     4de:	5d5d      	ldrb	r5, [r3, r5]
     4e0:	002e      	movs	r6, r5
     4e2:	4386      	bics	r6, r0
     4e4:	4645      	mov	r5, r8
     4e6:	555e      	strb	r6, [r3, r5]
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     4e8:	5d5d      	ldrb	r5, [r3, r5]
	tmp &= ~PORT_PINCFG_PMUXEN;
     4ea:	002e      	movs	r6, r5
     4ec:	438e      	bics	r6, r1
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
     4ee:	4316      	orrs	r6, r2
     4f0:	1c35      	adds	r5, r6, #0
     4f2:	466e      	mov	r6, sp
     4f4:	71f5      	strb	r5, [r6, #7]
     4f6:	79f5      	ldrb	r5, [r6, #7]
     4f8:	46ac      	mov	ip, r5
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     4fa:	4645      	mov	r5, r8
     4fc:	4666      	mov	r6, ip
     4fe:	555e      	strb	r6, [r3, r5]
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
     500:	3d1d      	subs	r5, #29
     502:	46ab      	mov	fp, r5
     504:	5d5d      	ldrb	r5, [r3, r5]
     506:	46ac      	mov	ip, r5
	tmp &= ~PORT_PMUX_PMUXO_Msk;
     508:	250f      	movs	r5, #15
     50a:	46a8      	mov	r8, r5
     50c:	4666      	mov	r6, ip
     50e:	402e      	ands	r6, r5
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
     510:	465d      	mov	r5, fp
     512:	555e      	strb	r6, [r3, r5]
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = mask;
     514:	2580      	movs	r5, #128	; 0x80
     516:	04ed      	lsls	r5, r5, #19
     518:	46ac      	mov	ip, r5
     51a:	4655      	mov	r5, sl
     51c:	4666      	mov	r6, ip
     51e:	5166      	str	r6, [r4, r5]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     520:	464d      	mov	r5, r9
     522:	51dd      	str	r5, [r3, r7]
     524:	4d7d      	ldr	r5, [pc, #500]	; (71c <EXTERNAL_IRQ_init+0x2d4>)
     526:	51dd      	str	r5, [r3, r7]
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg &= ~PORT_PINCFG_PULLEN;
     528:	25ad      	movs	r5, #173	; 0xad
     52a:	006d      	lsls	r5, r5, #1
     52c:	46ab      	mov	fp, r5
     52e:	5d5d      	ldrb	r5, [r3, r5]
     530:	002e      	movs	r6, r5
     532:	4386      	bics	r6, r0
     534:	465d      	mov	r5, fp
     536:	555e      	strb	r6, [r3, r5]
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     538:	5d5d      	ldrb	r5, [r3, r5]
	tmp &= ~PORT_PINCFG_PMUXEN;
     53a:	002e      	movs	r6, r5
     53c:	438e      	bics	r6, r1
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
     53e:	4316      	orrs	r6, r2
     540:	1c35      	adds	r5, r6, #0
     542:	466e      	mov	r6, sp
     544:	71f5      	strb	r5, [r6, #7]
     546:	79f5      	ldrb	r5, [r6, #7]
     548:	46ac      	mov	ip, r5
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     54a:	465d      	mov	r5, fp
     54c:	4666      	mov	r6, ip
     54e:	555e      	strb	r6, [r3, r5]
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
     550:	253e      	movs	r5, #62	; 0x3e
     552:	35ff      	adds	r5, #255	; 0xff
     554:	46ab      	mov	fp, r5
     556:	5d5d      	ldrb	r5, [r3, r5]
	tmp &= ~PORT_PMUX_PMUXE_Msk;
     558:	002e      	movs	r6, r5
     55a:	250f      	movs	r5, #15
     55c:	43ae      	bics	r6, r5
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
     55e:	465d      	mov	r5, fp
     560:	555e      	strb	r6, [r3, r5]
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = mask;
     562:	4655      	mov	r5, sl
     564:	2680      	movs	r6, #128	; 0x80
     566:	0136      	lsls	r6, r6, #4
     568:	5166      	str	r6, [r4, r5]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     56a:	4d6d      	ldr	r5, [pc, #436]	; (720 <EXTERNAL_IRQ_init+0x2d8>)
     56c:	51dd      	str	r5, [r3, r7]
     56e:	4d68      	ldr	r5, [pc, #416]	; (710 <EXTERNAL_IRQ_init+0x2c8>)
     570:	51dd      	str	r5, [r3, r7]
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg &= ~PORT_PINCFG_PULLEN;
     572:	254c      	movs	r5, #76	; 0x4c
     574:	35ff      	adds	r5, #255	; 0xff
     576:	5d5f      	ldrb	r7, [r3, r5]
     578:	4387      	bics	r7, r0
     57a:	555f      	strb	r7, [r3, r5]
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     57c:	5d5f      	ldrb	r7, [r3, r5]
	tmp &= ~PORT_PINCFG_PMUXEN;
     57e:	438f      	bics	r7, r1
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
     580:	4317      	orrs	r7, r2
     582:	b2ff      	uxtb	r7, r7
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     584:	555f      	strb	r7, [r3, r5]
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
     586:	2536      	movs	r5, #54	; 0x36
     588:	35ff      	adds	r5, #255	; 0xff
     58a:	46ac      	mov	ip, r5
     58c:	5d5f      	ldrb	r7, [r3, r5]
	tmp &= ~PORT_PMUX_PMUXO_Msk;
     58e:	4645      	mov	r5, r8
     590:	402f      	ands	r7, r5
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
     592:	4665      	mov	r5, ip
     594:	555f      	strb	r7, [r3, r5]
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = mask;
     596:	3db1      	subs	r5, #177	; 0xb1
     598:	46ab      	mov	fp, r5
     59a:	2780      	movs	r7, #128	; 0x80
     59c:	03ff      	lsls	r7, r7, #15
     59e:	5167      	str	r7, [r4, r5]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     5a0:	3524      	adds	r5, #36	; 0x24
     5a2:	46ac      	mov	ip, r5
     5a4:	464e      	mov	r6, r9
     5a6:	515e      	str	r6, [r3, r5]
     5a8:	4f5e      	ldr	r7, [pc, #376]	; (724 <EXTERNAL_IRQ_init+0x2dc>)
     5aa:	515f      	str	r7, [r3, r5]
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg &= ~PORT_PINCFG_PULLEN;
     5ac:	352e      	adds	r5, #46	; 0x2e
     5ae:	5d5f      	ldrb	r7, [r3, r5]
     5b0:	4387      	bics	r7, r0
     5b2:	555f      	strb	r7, [r3, r5]
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     5b4:	5d5f      	ldrb	r7, [r3, r5]
	tmp &= ~PORT_PINCFG_PMUXEN;
     5b6:	438f      	bics	r7, r1
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
     5b8:	4317      	orrs	r7, r2
     5ba:	b2ff      	uxtb	r7, r7
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     5bc:	555f      	strb	r7, [r3, r5]
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
     5be:	3d1b      	subs	r5, #27
     5c0:	46aa      	mov	sl, r5
     5c2:	5d5f      	ldrb	r7, [r3, r5]
	tmp &= ~PORT_PMUX_PMUXE_Msk;
     5c4:	3dac      	subs	r5, #172	; 0xac
     5c6:	43af      	bics	r7, r5
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
     5c8:	4655      	mov	r5, sl
     5ca:	555f      	strb	r7, [r3, r5]
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = mask;
     5cc:	2780      	movs	r7, #128	; 0x80
     5ce:	047f      	lsls	r7, r7, #17
     5d0:	465d      	mov	r5, fp
     5d2:	5167      	str	r7, [r4, r5]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     5d4:	4665      	mov	r5, ip
     5d6:	515e      	str	r6, [r3, r5]
     5d8:	4f53      	ldr	r7, [pc, #332]	; (728 <EXTERNAL_IRQ_init+0x2e0>)
     5da:	515f      	str	r7, [r3, r5]
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg &= ~PORT_PINCFG_PULLEN;
     5dc:	3530      	adds	r5, #48	; 0x30
     5de:	5d5f      	ldrb	r7, [r3, r5]
     5e0:	4387      	bics	r7, r0
     5e2:	555f      	strb	r7, [r3, r5]
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     5e4:	5d5f      	ldrb	r7, [r3, r5]
	tmp &= ~PORT_PINCFG_PMUXEN;
     5e6:	438f      	bics	r7, r1
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
     5e8:	4317      	orrs	r7, r2
     5ea:	b2ff      	uxtb	r7, r7
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     5ec:	555f      	strb	r7, [r3, r5]
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
     5ee:	3d1c      	subs	r5, #28
     5f0:	46a9      	mov	r9, r5
     5f2:	5d5f      	ldrb	r7, [r3, r5]
	tmp &= ~PORT_PMUX_PMUXE_Msk;
     5f4:	3dad      	subs	r5, #173	; 0xad
     5f6:	43af      	bics	r7, r5
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
     5f8:	464d      	mov	r5, r9
     5fa:	555f      	strb	r7, [r3, r5]
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = mask;
     5fc:	2580      	movs	r5, #128	; 0x80
     5fe:	00ed      	lsls	r5, r5, #3
     600:	6065      	str	r5, [r4, #4]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     602:	4f4a      	ldr	r7, [pc, #296]	; (72c <EXTERNAL_IRQ_init+0x2e4>)
     604:	629f      	str	r7, [r3, #40]	; 0x28
     606:	4d42      	ldr	r5, [pc, #264]	; (710 <EXTERNAL_IRQ_init+0x2c8>)
     608:	629d      	str	r5, [r3, #40]	; 0x28
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg &= ~PORT_PINCFG_PULLEN;
     60a:	254a      	movs	r5, #74	; 0x4a
     60c:	5d5f      	ldrb	r7, [r3, r5]
     60e:	4387      	bics	r7, r0
     610:	555f      	strb	r7, [r3, r5]
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     612:	5d5f      	ldrb	r7, [r3, r5]
	tmp &= ~PORT_PINCFG_PMUXEN;
     614:	438f      	bics	r7, r1
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
     616:	4317      	orrs	r7, r2
     618:	b2ff      	uxtb	r7, r7
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     61a:	555f      	strb	r7, [r3, r5]
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
     61c:	2735      	movs	r7, #53	; 0x35
     61e:	5ddd      	ldrb	r5, [r3, r7]
	tmp &= ~PORT_PMUX_PMUXE_Msk;
     620:	002e      	movs	r6, r5
     622:	250f      	movs	r5, #15
     624:	43ae      	bics	r6, r5
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
     626:	55de      	strb	r6, [r3, r7]
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = mask;
     628:	2580      	movs	r5, #128	; 0x80
     62a:	012d      	lsls	r5, r5, #4
     62c:	6065      	str	r5, [r4, #4]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     62e:	4d3c      	ldr	r5, [pc, #240]	; (720 <EXTERNAL_IRQ_init+0x2d8>)
     630:	629d      	str	r5, [r3, #40]	; 0x28
     632:	4d37      	ldr	r5, [pc, #220]	; (710 <EXTERNAL_IRQ_init+0x2c8>)
     634:	629d      	str	r5, [r3, #40]	; 0x28
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg &= ~PORT_PINCFG_PULLEN;
     636:	254b      	movs	r5, #75	; 0x4b
     638:	46aa      	mov	sl, r5
     63a:	5d5d      	ldrb	r5, [r3, r5]
     63c:	002e      	movs	r6, r5
     63e:	4386      	bics	r6, r0
     640:	4655      	mov	r5, sl
     642:	555e      	strb	r6, [r3, r5]
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     644:	5d5d      	ldrb	r5, [r3, r5]
	tmp &= ~PORT_PINCFG_PMUXEN;
     646:	002e      	movs	r6, r5
     648:	438e      	bics	r6, r1
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
     64a:	4316      	orrs	r6, r2
     64c:	1c35      	adds	r5, r6, #0
     64e:	466e      	mov	r6, sp
     650:	71f5      	strb	r5, [r6, #7]
     652:	79f5      	ldrb	r5, [r6, #7]
     654:	46a9      	mov	r9, r5
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     656:	4655      	mov	r5, sl
     658:	464e      	mov	r6, r9
     65a:	555e      	strb	r6, [r3, r5]
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
     65c:	5ddd      	ldrb	r5, [r3, r7]
	tmp &= ~PORT_PMUX_PMUXO_Msk;
     65e:	002e      	movs	r6, r5
     660:	4645      	mov	r5, r8
     662:	402e      	ands	r6, r5
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
     664:	55de      	strb	r6, [r3, r7]
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = mask;
     666:	2780      	movs	r7, #128	; 0x80
     668:	017f      	lsls	r7, r7, #5
     66a:	6067      	str	r7, [r4, #4]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     66c:	4f30      	ldr	r7, [pc, #192]	; (730 <EXTERNAL_IRQ_init+0x2e8>)
     66e:	629f      	str	r7, [r3, #40]	; 0x28
     670:	4d27      	ldr	r5, [pc, #156]	; (710 <EXTERNAL_IRQ_init+0x2c8>)
     672:	629d      	str	r5, [r3, #40]	; 0x28
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg &= ~PORT_PINCFG_PULLEN;
     674:	254c      	movs	r5, #76	; 0x4c
     676:	5d5f      	ldrb	r7, [r3, r5]
     678:	4387      	bics	r7, r0
     67a:	555f      	strb	r7, [r3, r5]
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     67c:	5d5f      	ldrb	r7, [r3, r5]
	tmp &= ~PORT_PINCFG_PMUXEN;
     67e:	438f      	bics	r7, r1
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
     680:	4317      	orrs	r7, r2
     682:	b2ff      	uxtb	r7, r7
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     684:	555f      	strb	r7, [r3, r5]
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
     686:	3d16      	subs	r5, #22
     688:	46a9      	mov	r9, r5
     68a:	5d5f      	ldrb	r7, [r3, r5]
	tmp &= ~PORT_PMUX_PMUXE_Msk;
     68c:	3d27      	subs	r5, #39	; 0x27
     68e:	43af      	bics	r7, r5
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
     690:	464d      	mov	r5, r9
     692:	555f      	strb	r7, [r3, r5]
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = mask;
     694:	2780      	movs	r7, #128	; 0x80
     696:	01bf      	lsls	r7, r7, #6
     698:	6067      	str	r7, [r4, #4]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     69a:	4f26      	ldr	r7, [pc, #152]	; (734 <EXTERNAL_IRQ_init+0x2ec>)
     69c:	629f      	str	r7, [r3, #40]	; 0x28
     69e:	4d1c      	ldr	r5, [pc, #112]	; (710 <EXTERNAL_IRQ_init+0x2c8>)
     6a0:	629d      	str	r5, [r3, #40]	; 0x28
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg &= ~PORT_PINCFG_PULLEN;
     6a2:	254d      	movs	r5, #77	; 0x4d
     6a4:	5d5f      	ldrb	r7, [r3, r5]
     6a6:	4387      	bics	r7, r0
     6a8:	555f      	strb	r7, [r3, r5]
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     6aa:	5d5f      	ldrb	r7, [r3, r5]
	tmp &= ~PORT_PINCFG_PMUXEN;
     6ac:	438f      	bics	r7, r1
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
     6ae:	4317      	orrs	r7, r2
     6b0:	b2ff      	uxtb	r7, r7
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     6b2:	555f      	strb	r7, [r3, r5]
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
     6b4:	464d      	mov	r5, r9
     6b6:	5d5f      	ldrb	r7, [r3, r5]
	tmp &= ~PORT_PMUX_PMUXO_Msk;
     6b8:	4645      	mov	r5, r8
     6ba:	402f      	ands	r7, r5
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
     6bc:	464d      	mov	r5, r9
     6be:	555f      	strb	r7, [r3, r5]
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = mask;
     6c0:	2780      	movs	r7, #128	; 0x80
     6c2:	01ff      	lsls	r7, r7, #7
     6c4:	465d      	mov	r5, fp
     6c6:	5167      	str	r7, [r4, r5]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     6c8:	4c1b      	ldr	r4, [pc, #108]	; (738 <EXTERNAL_IRQ_init+0x2f0>)
     6ca:	4665      	mov	r5, ip
     6cc:	515c      	str	r4, [r3, r5]
     6ce:	4664      	mov	r4, ip
     6d0:	4d0f      	ldr	r5, [pc, #60]	; (710 <EXTERNAL_IRQ_init+0x2c8>)
     6d2:	511d      	str	r5, [r3, r4]
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg &= ~PORT_PINCFG_PULLEN;
     6d4:	3426      	adds	r4, #38	; 0x26
     6d6:	5d1e      	ldrb	r6, [r3, r4]
     6d8:	4386      	bics	r6, r0
     6da:	551e      	strb	r6, [r3, r4]
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     6dc:	5d18      	ldrb	r0, [r3, r4]
	tmp &= ~PORT_PINCFG_PMUXEN;
     6de:	4388      	bics	r0, r1
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
     6e0:	4302      	orrs	r2, r0
     6e2:	b2d2      	uxtb	r2, r2
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     6e4:	551a      	strb	r2, [r3, r4]
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
     6e6:	31b6      	adds	r1, #182	; 0xb6
     6e8:	5c5a      	ldrb	r2, [r3, r1]
	tmp &= ~PORT_PMUX_PMUXE_Msk;
     6ea:	200f      	movs	r0, #15
     6ec:	4382      	bics	r2, r0
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
     6ee:	545a      	strb	r2, [r3, r1]
	                       // <GPIO_PULL_DOWN"> Pull-down
	                       GPIO_PULL_OFF);

	gpio_set_pin_function(FET_DRV_FAULT, PINMUX_PB14A_EIC_EXTINT14);

	ext_irq_init();
     6f0:	4b12      	ldr	r3, [pc, #72]	; (73c <EXTERNAL_IRQ_init+0x2f4>)
     6f2:	4798      	blx	r3
}
     6f4:	b003      	add	sp, #12
     6f6:	bc3c      	pop	{r2, r3, r4, r5}
     6f8:	4690      	mov	r8, r2
     6fa:	4699      	mov	r9, r3
     6fc:	46a2      	mov	sl, r4
     6fe:	46ab      	mov	fp, r5
     700:	bdf0      	pop	{r4, r5, r6, r7, pc}
     702:	46c0      	nop			; (mov r8, r8)
     704:	40001c00 	.word	0x40001c00
     708:	40000800 	.word	0x40000800
     70c:	40020100 	.word	0x40020100
     710:	c0020000 	.word	0xc0020000
     714:	40020000 	.word	0x40020000
     718:	c0020200 	.word	0xc0020200
     71c:	c0020400 	.word	0xc0020400
     720:	40020800 	.word	0x40020800
     724:	c0020040 	.word	0xc0020040
     728:	c0020100 	.word	0xc0020100
     72c:	40020400 	.word	0x40020400
     730:	40021000 	.word	0x40021000
     734:	40022000 	.word	0x40022000
     738:	40024000 	.word	0x40024000
     73c:	00001101 	.word	0x00001101

00000740 <FG_I2C_PORT_init>:

void FG_I2C_PORT_init(void)
{
     740:	b570      	push	{r4, r5, r6, lr}
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg &= ~PORT_PINCFG_PULLEN;
     742:	2382      	movs	r3, #130	; 0x82
     744:	05db      	lsls	r3, r3, #23
     746:	2048      	movs	r0, #72	; 0x48
     748:	5c19      	ldrb	r1, [r3, r0]
     74a:	2204      	movs	r2, #4
     74c:	4391      	bics	r1, r2
     74e:	5419      	strb	r1, [r3, r0]
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     750:	5c19      	ldrb	r1, [r3, r0]
	tmp &= ~PORT_PINCFG_PMUXEN;
     752:	2501      	movs	r5, #1
     754:	43a9      	bics	r1, r5
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
     756:	2401      	movs	r4, #1
     758:	4321      	orrs	r1, r4
     75a:	b2c9      	uxtb	r1, r1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     75c:	5419      	strb	r1, [r3, r0]
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
     75e:	3814      	subs	r0, #20
     760:	5c19      	ldrb	r1, [r3, r0]
	tmp &= ~PORT_PMUX_PMUXE_Msk;
     762:	260f      	movs	r6, #15
     764:	43b1      	bics	r1, r6
	tmp |= PORT_PMUX_PMUXE(data);
     766:	2602      	movs	r6, #2
     768:	4331      	orrs	r1, r6
     76a:	b2c9      	uxtb	r1, r1
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
     76c:	5419      	strb	r1, [r3, r0]
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg &= ~PORT_PINCFG_PULLEN;
     76e:	2149      	movs	r1, #73	; 0x49
     770:	5c5e      	ldrb	r6, [r3, r1]
     772:	4396      	bics	r6, r2
     774:	545e      	strb	r6, [r3, r1]
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     776:	5c5a      	ldrb	r2, [r3, r1]
	tmp &= ~PORT_PINCFG_PMUXEN;
     778:	43aa      	bics	r2, r5
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
     77a:	4322      	orrs	r2, r4
     77c:	b2d2      	uxtb	r2, r2
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     77e:	545a      	strb	r2, [r3, r1]
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
     780:	5c1a      	ldrb	r2, [r3, r0]
	tmp &= ~PORT_PMUX_PMUXO_Msk;
     782:	393a      	subs	r1, #58	; 0x3a
     784:	400a      	ands	r2, r1
	tmp |= PORT_PMUX_PMUXO(data);
     786:	2120      	movs	r1, #32
     788:	430a      	orrs	r2, r1
     78a:	b2d2      	uxtb	r2, r2
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
     78c:	541a      	strb	r2, [r3, r0]
	                       // <GPIO_PULL_UP"> Pull-up
	                       // <GPIO_PULL_DOWN"> Pull-down
	                       GPIO_PULL_OFF);

	gpio_set_pin_function(FG_SCL, PINMUX_PA09C_SERCOM0_PAD1);
}
     78e:	bd70      	pop	{r4, r5, r6, pc}

00000790 <FG_I2C_CLOCK_init>:
     790:	4b06      	ldr	r3, [pc, #24]	; (7ac <FG_I2C_CLOCK_init+0x1c>)
     792:	2140      	movs	r1, #64	; 0x40
     794:	22cc      	movs	r2, #204	; 0xcc
     796:	5099      	str	r1, [r3, r2]
     798:	3103      	adds	r1, #3
     79a:	3a04      	subs	r2, #4
     79c:	5099      	str	r1, [r3, r2]
	((Mclk *)hw)->APBCMASK.reg |= MCLK_APBCMASK_SERCOM0;
     79e:	4a04      	ldr	r2, [pc, #16]	; (7b0 <FG_I2C_CLOCK_init+0x20>)
     7a0:	69d3      	ldr	r3, [r2, #28]
     7a2:	3941      	subs	r1, #65	; 0x41
     7a4:	430b      	orrs	r3, r1
     7a6:	61d3      	str	r3, [r2, #28]
{
	hri_gclk_write_PCHCTRL_reg(GCLK, SERCOM0_GCLK_ID_CORE, CONF_GCLK_SERCOM0_CORE_SRC | (1 << GCLK_PCHCTRL_CHEN_Pos));
	hri_gclk_write_PCHCTRL_reg(GCLK, SERCOM0_GCLK_ID_SLOW, CONF_GCLK_SERCOM0_SLOW_SRC | (1 << GCLK_PCHCTRL_CHEN_Pos));

	hri_mclk_set_APBCMASK_SERCOM0_bit(MCLK);
}
     7a8:	4770      	bx	lr
     7aa:	46c0      	nop			; (mov r8, r8)
     7ac:	40001c00 	.word	0x40001c00
     7b0:	40000800 	.word	0x40000800

000007b4 <FG_I2C_init>:

void FG_I2C_init(void)
{
     7b4:	b510      	push	{r4, lr}
	FG_I2C_CLOCK_init();
     7b6:	4b04      	ldr	r3, [pc, #16]	; (7c8 <FG_I2C_init+0x14>)
     7b8:	4798      	blx	r3
	i2c_m_sync_init(&FG_I2C, SERCOM0);
     7ba:	4904      	ldr	r1, [pc, #16]	; (7cc <FG_I2C_init+0x18>)
     7bc:	4804      	ldr	r0, [pc, #16]	; (7d0 <FG_I2C_init+0x1c>)
     7be:	4b05      	ldr	r3, [pc, #20]	; (7d4 <FG_I2C_init+0x20>)
     7c0:	4798      	blx	r3
	FG_I2C_PORT_init();
     7c2:	4b05      	ldr	r3, [pc, #20]	; (7d8 <FG_I2C_init+0x24>)
     7c4:	4798      	blx	r3
}
     7c6:	bd10      	pop	{r4, pc}
     7c8:	00000791 	.word	0x00000791
     7cc:	42000400 	.word	0x42000400
     7d0:	20000204 	.word	0x20000204
     7d4:	0000119d 	.word	0x0000119d
     7d8:	00000741 	.word	0x00000741

000007dc <AFE_I2C_PORT_init>:

void AFE_I2C_PORT_init(void)
{
     7dc:	b5f0      	push	{r4, r5, r6, r7, lr}
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = mask;
     7de:	24c0      	movs	r4, #192	; 0xc0
     7e0:	05e4      	lsls	r4, r4, #23
     7e2:	2580      	movs	r5, #128	; 0x80
     7e4:	026d      	lsls	r5, r5, #9
     7e6:	6065      	str	r5, [r4, #4]
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg |= PORT_PINCFG_PULLEN;
     7e8:	2382      	movs	r3, #130	; 0x82
     7ea:	05db      	lsls	r3, r3, #23
     7ec:	2050      	movs	r0, #80	; 0x50
     7ee:	5c19      	ldrb	r1, [r3, r0]
     7f0:	2204      	movs	r2, #4
     7f2:	4311      	orrs	r1, r2
     7f4:	b2c9      	uxtb	r1, r1
     7f6:	5419      	strb	r1, [r3, r0]
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
     7f8:	61a5      	str	r5, [r4, #24]
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     7fa:	5c19      	ldrb	r1, [r3, r0]
	tmp &= ~PORT_PINCFG_PMUXEN;
     7fc:	2601      	movs	r6, #1
     7fe:	43b1      	bics	r1, r6
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
     800:	2501      	movs	r5, #1
     802:	4329      	orrs	r1, r5
     804:	b2c9      	uxtb	r1, r1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     806:	5419      	strb	r1, [r3, r0]
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
     808:	3818      	subs	r0, #24
     80a:	5c19      	ldrb	r1, [r3, r0]
	tmp &= ~PORT_PMUX_PMUXE_Msk;
     80c:	270f      	movs	r7, #15
     80e:	43b9      	bics	r1, r7
	tmp |= PORT_PMUX_PMUXE(data);
     810:	2702      	movs	r7, #2
     812:	4339      	orrs	r1, r7
     814:	b2c9      	uxtb	r1, r1
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
     816:	5419      	strb	r1, [r3, r0]
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = mask;
     818:	2180      	movs	r1, #128	; 0x80
     81a:	0289      	lsls	r1, r1, #10
     81c:	468c      	mov	ip, r1
     81e:	6061      	str	r1, [r4, #4]
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg |= PORT_PINCFG_PULLEN;
     820:	2151      	movs	r1, #81	; 0x51
     822:	5c5f      	ldrb	r7, [r3, r1]
     824:	433a      	orrs	r2, r7
     826:	b2d2      	uxtb	r2, r2
     828:	545a      	strb	r2, [r3, r1]
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
     82a:	4662      	mov	r2, ip
     82c:	61a2      	str	r2, [r4, #24]
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     82e:	5c5a      	ldrb	r2, [r3, r1]
	tmp &= ~PORT_PINCFG_PMUXEN;
     830:	43b2      	bics	r2, r6
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
     832:	432a      	orrs	r2, r5
     834:	b2d2      	uxtb	r2, r2
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     836:	545a      	strb	r2, [r3, r1]
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
     838:	5c1a      	ldrb	r2, [r3, r0]
	tmp &= ~PORT_PMUX_PMUXO_Msk;
     83a:	3942      	subs	r1, #66	; 0x42
     83c:	400a      	ands	r2, r1
	tmp |= PORT_PMUX_PMUXO(data);
     83e:	2120      	movs	r1, #32
     840:	430a      	orrs	r2, r1
     842:	b2d2      	uxtb	r2, r2
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
     844:	541a      	strb	r2, [r3, r0]
	                       // <GPIO_PULL_UP"> Pull-up
	                       // <GPIO_PULL_DOWN"> Pull-down
	                       GPIO_PULL_UP);

	gpio_set_pin_function(AFE_SCL, PINMUX_PA17C_SERCOM1_PAD1);
}
     846:	bdf0      	pop	{r4, r5, r6, r7, pc}

00000848 <AFE_I2C_CLOCK_init>:
     848:	4b06      	ldr	r3, [pc, #24]	; (864 <AFE_I2C_CLOCK_init+0x1c>)
     84a:	2140      	movs	r1, #64	; 0x40
     84c:	22d0      	movs	r2, #208	; 0xd0
     84e:	5099      	str	r1, [r3, r2]
     850:	3103      	adds	r1, #3
     852:	3a08      	subs	r2, #8
     854:	5099      	str	r1, [r3, r2]
	((Mclk *)hw)->APBCMASK.reg |= MCLK_APBCMASK_SERCOM1;
     856:	4a04      	ldr	r2, [pc, #16]	; (868 <AFE_I2C_CLOCK_init+0x20>)
     858:	69d3      	ldr	r3, [r2, #28]
     85a:	393f      	subs	r1, #63	; 0x3f
     85c:	430b      	orrs	r3, r1
     85e:	61d3      	str	r3, [r2, #28]
{
	hri_gclk_write_PCHCTRL_reg(GCLK, SERCOM1_GCLK_ID_CORE, CONF_GCLK_SERCOM1_CORE_SRC | (1 << GCLK_PCHCTRL_CHEN_Pos));
	hri_gclk_write_PCHCTRL_reg(GCLK, SERCOM1_GCLK_ID_SLOW, CONF_GCLK_SERCOM1_SLOW_SRC | (1 << GCLK_PCHCTRL_CHEN_Pos));

	hri_mclk_set_APBCMASK_SERCOM1_bit(MCLK);
}
     860:	4770      	bx	lr
     862:	46c0      	nop			; (mov r8, r8)
     864:	40001c00 	.word	0x40001c00
     868:	40000800 	.word	0x40000800

0000086c <AFE_I2C_init>:

void AFE_I2C_init(void)
{
     86c:	b510      	push	{r4, lr}
	AFE_I2C_CLOCK_init();
     86e:	4b04      	ldr	r3, [pc, #16]	; (880 <AFE_I2C_init+0x14>)
     870:	4798      	blx	r3
	i2c_m_sync_init(&AFE_I2C, SERCOM1);
     872:	4904      	ldr	r1, [pc, #16]	; (884 <AFE_I2C_init+0x18>)
     874:	4804      	ldr	r0, [pc, #16]	; (888 <AFE_I2C_init+0x1c>)
     876:	4b05      	ldr	r3, [pc, #20]	; (88c <AFE_I2C_init+0x20>)
     878:	4798      	blx	r3
	AFE_I2C_PORT_init();
     87a:	4b05      	ldr	r3, [pc, #20]	; (890 <AFE_I2C_init+0x24>)
     87c:	4798      	blx	r3
}
     87e:	bd10      	pop	{r4, pc}
     880:	00000849 	.word	0x00000849
     884:	42000800 	.word	0x42000800
     888:	2000029c 	.word	0x2000029c
     88c:	0000119d 	.word	0x0000119d
     890:	000007dd 	.word	0x000007dd

00000894 <FLASH_PORT_init>:

void FLASH_PORT_init(void)
{
     894:	b5f0      	push	{r4, r5, r6, r7, lr}
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = mask;
     896:	24c0      	movs	r4, #192	; 0xc0
     898:	05e4      	lsls	r4, r4, #23
     89a:	2380      	movs	r3, #128	; 0x80
     89c:	03db      	lsls	r3, r3, #15
     89e:	6063      	str	r3, [r4, #4]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     8a0:	2382      	movs	r3, #130	; 0x82
     8a2:	05db      	lsls	r3, r3, #23
     8a4:	4a22      	ldr	r2, [pc, #136]	; (930 <FLASH_PORT_init+0x9c>)
     8a6:	629a      	str	r2, [r3, #40]	; 0x28
     8a8:	4a22      	ldr	r2, [pc, #136]	; (934 <FLASH_PORT_init+0xa0>)
     8aa:	629a      	str	r2, [r3, #40]	; 0x28
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg &= ~PORT_PINCFG_PULLEN;
     8ac:	2156      	movs	r1, #86	; 0x56
     8ae:	5c5a      	ldrb	r2, [r3, r1]
     8b0:	2004      	movs	r0, #4
     8b2:	4382      	bics	r2, r0
     8b4:	545a      	strb	r2, [r3, r1]
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     8b6:	5c5a      	ldrb	r2, [r3, r1]
	tmp &= ~PORT_PINCFG_PMUXEN;
     8b8:	3803      	subs	r0, #3
     8ba:	4684      	mov	ip, r0
     8bc:	4382      	bics	r2, r0
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
     8be:	2701      	movs	r7, #1
     8c0:	433a      	orrs	r2, r7
     8c2:	b2d2      	uxtb	r2, r2
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     8c4:	545a      	strb	r2, [r3, r1]
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
     8c6:	253b      	movs	r5, #59	; 0x3b
     8c8:	5d5a      	ldrb	r2, [r3, r5]
	tmp &= ~PORT_PMUX_PMUXE_Msk;
     8ca:	3947      	subs	r1, #71	; 0x47
     8cc:	438a      	bics	r2, r1
	tmp |= PORT_PMUX_PMUXE(data);
     8ce:	2102      	movs	r1, #2
     8d0:	430a      	orrs	r2, r1
     8d2:	b2d2      	uxtb	r2, r2
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
     8d4:	555a      	strb	r2, [r3, r5]
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
     8d6:	2280      	movs	r2, #128	; 0x80
     8d8:	0412      	lsls	r2, r2, #16
     8da:	6162      	str	r2, [r4, #20]
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     8dc:	60a2      	str	r2, [r4, #8]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     8de:	2180      	movs	r1, #128	; 0x80
     8e0:	05c9      	lsls	r1, r1, #23
     8e2:	6299      	str	r1, [r3, #40]	; 0x28
     8e4:	4a14      	ldr	r2, [pc, #80]	; (938 <FLASH_PORT_init+0xa4>)
     8e6:	629a      	str	r2, [r3, #40]	; 0x28
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     8e8:	3056      	adds	r0, #86	; 0x56
     8ea:	5c1a      	ldrb	r2, [r3, r0]
	tmp &= ~PORT_PINCFG_PMUXEN;
     8ec:	4666      	mov	r6, ip
     8ee:	43b2      	bics	r2, r6
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
     8f0:	433a      	orrs	r2, r7
     8f2:	b2d2      	uxtb	r2, r2
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     8f4:	541a      	strb	r2, [r3, r0]
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
     8f6:	5d58      	ldrb	r0, [r3, r5]
	tmp &= ~PORT_PMUX_PMUXO_Msk;
     8f8:	360e      	adds	r6, #14
     8fa:	4030      	ands	r0, r6
	tmp |= PORT_PMUX_PMUXO(data);
     8fc:	2220      	movs	r2, #32
     8fe:	4310      	orrs	r0, r2
     900:	b2c0      	uxtb	r0, r0
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
     902:	5558      	strb	r0, [r3, r5]
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
     904:	2280      	movs	r2, #128	; 0x80
     906:	0392      	lsls	r2, r2, #14
     908:	6162      	str	r2, [r4, #20]
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     90a:	60a2      	str	r2, [r4, #8]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     90c:	6299      	str	r1, [r3, #40]	; 0x28
     90e:	4a0b      	ldr	r2, [pc, #44]	; (93c <FLASH_PORT_init+0xa8>)
     910:	629a      	str	r2, [r3, #40]	; 0x28
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     912:	2255      	movs	r2, #85	; 0x55
     914:	5c99      	ldrb	r1, [r3, r2]
	tmp &= ~PORT_PINCFG_PMUXEN;
     916:	4660      	mov	r0, ip
     918:	4381      	bics	r1, r0
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
     91a:	4339      	orrs	r1, r7
     91c:	b2c9      	uxtb	r1, r1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     91e:	5499      	strb	r1, [r3, r2]
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
     920:	213a      	movs	r1, #58	; 0x3a
     922:	5c5a      	ldrb	r2, [r3, r1]
	tmp &= ~PORT_PMUX_PMUXO_Msk;
     924:	4032      	ands	r2, r6
	tmp |= PORT_PMUX_PMUXO(data);
     926:	2030      	movs	r0, #48	; 0x30
     928:	4302      	orrs	r2, r0
     92a:	b2d2      	uxtb	r2, r2
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
     92c:	545a      	strb	r2, [r3, r1]

	// Set pin direction to output
	gpio_set_pin_direction(FLASH_MOSI, GPIO_DIRECTION_OUT);

	gpio_set_pin_function(FLASH_MOSI, PINMUX_PA21D_SERCOM3_PAD3);
}
     92e:	bdf0      	pop	{r4, r5, r6, r7, pc}
     930:	40020000 	.word	0x40020000
     934:	c0020040 	.word	0xc0020040
     938:	c0000080 	.word	0xc0000080
     93c:	c0000020 	.word	0xc0000020

00000940 <FLASH_CLOCK_init>:
     940:	4b06      	ldr	r3, [pc, #24]	; (95c <FLASH_CLOCK_init+0x1c>)
     942:	2140      	movs	r1, #64	; 0x40
     944:	22d8      	movs	r2, #216	; 0xd8
     946:	5099      	str	r1, [r3, r2]
     948:	3103      	adds	r1, #3
     94a:	3a10      	subs	r2, #16
     94c:	5099      	str	r1, [r3, r2]
	((Mclk *)hw)->APBCMASK.reg |= MCLK_APBCMASK_SERCOM3;
     94e:	4a04      	ldr	r2, [pc, #16]	; (960 <FLASH_CLOCK_init+0x20>)
     950:	69d3      	ldr	r3, [r2, #28]
     952:	3933      	subs	r1, #51	; 0x33
     954:	430b      	orrs	r3, r1
     956:	61d3      	str	r3, [r2, #28]
{
	hri_gclk_write_PCHCTRL_reg(GCLK, SERCOM3_GCLK_ID_CORE, CONF_GCLK_SERCOM3_CORE_SRC | (1 << GCLK_PCHCTRL_CHEN_Pos));
	hri_gclk_write_PCHCTRL_reg(GCLK, SERCOM3_GCLK_ID_SLOW, CONF_GCLK_SERCOM3_SLOW_SRC | (1 << GCLK_PCHCTRL_CHEN_Pos));

	hri_mclk_set_APBCMASK_SERCOM3_bit(MCLK);
}
     958:	4770      	bx	lr
     95a:	46c0      	nop			; (mov r8, r8)
     95c:	40001c00 	.word	0x40001c00
     960:	40000800 	.word	0x40000800

00000964 <FLASH_init>:

void FLASH_init(void)
{
     964:	b510      	push	{r4, lr}
	FLASH_CLOCK_init();
     966:	4b04      	ldr	r3, [pc, #16]	; (978 <FLASH_init+0x14>)
     968:	4798      	blx	r3
	spi_m_sync_init(&FLASH, SERCOM3);
     96a:	4904      	ldr	r1, [pc, #16]	; (97c <FLASH_init+0x18>)
     96c:	4804      	ldr	r0, [pc, #16]	; (980 <FLASH_init+0x1c>)
     96e:	4b05      	ldr	r3, [pc, #20]	; (984 <FLASH_init+0x20>)
     970:	4798      	blx	r3
	FLASH_PORT_init();
     972:	4b05      	ldr	r3, [pc, #20]	; (988 <FLASH_init+0x24>)
     974:	4798      	blx	r3
}
     976:	bd10      	pop	{r4, pc}
     978:	00000941 	.word	0x00000941
     97c:	42001000 	.word	0x42001000
     980:	20000224 	.word	0x20000224
     984:	00001275 	.word	0x00001275
     988:	00000895 	.word	0x00000895

0000098c <I2C_0_PORT_init>:

void I2C_0_PORT_init(void)
{
     98c:	b570      	push	{r4, r5, r6, lr}
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg &= ~PORT_PINCFG_PULLEN;
     98e:	2382      	movs	r3, #130	; 0x82
     990:	05db      	lsls	r3, r3, #23
     992:	20cc      	movs	r0, #204	; 0xcc
     994:	5c19      	ldrb	r1, [r3, r0]
     996:	2204      	movs	r2, #4
     998:	4391      	bics	r1, r2
     99a:	5419      	strb	r1, [r3, r0]
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     99c:	5c19      	ldrb	r1, [r3, r0]
	tmp &= ~PORT_PINCFG_PMUXEN;
     99e:	2501      	movs	r5, #1
     9a0:	43a9      	bics	r1, r5
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
     9a2:	2401      	movs	r4, #1
     9a4:	4321      	orrs	r1, r4
     9a6:	b2c9      	uxtb	r1, r1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     9a8:	5419      	strb	r1, [r3, r0]
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
     9aa:	3816      	subs	r0, #22
     9ac:	5c19      	ldrb	r1, [r3, r0]
	tmp &= ~PORT_PMUX_PMUXE_Msk;
     9ae:	260f      	movs	r6, #15
     9b0:	43b1      	bics	r1, r6
	tmp |= PORT_PMUX_PMUXE(data);
     9b2:	2602      	movs	r6, #2
     9b4:	4331      	orrs	r1, r6
     9b6:	b2c9      	uxtb	r1, r1
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
     9b8:	5419      	strb	r1, [r3, r0]
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg &= ~PORT_PINCFG_PULLEN;
     9ba:	21cd      	movs	r1, #205	; 0xcd
     9bc:	5c5e      	ldrb	r6, [r3, r1]
     9be:	4396      	bics	r6, r2
     9c0:	545e      	strb	r6, [r3, r1]
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     9c2:	5c5a      	ldrb	r2, [r3, r1]
	tmp &= ~PORT_PINCFG_PMUXEN;
     9c4:	43aa      	bics	r2, r5
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
     9c6:	4322      	orrs	r2, r4
     9c8:	b2d2      	uxtb	r2, r2
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     9ca:	545a      	strb	r2, [r3, r1]
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
     9cc:	5c1a      	ldrb	r2, [r3, r0]
	tmp &= ~PORT_PMUX_PMUXO_Msk;
     9ce:	39be      	subs	r1, #190	; 0xbe
     9d0:	400a      	ands	r2, r1
	tmp |= PORT_PMUX_PMUXO(data);
     9d2:	2120      	movs	r1, #32
     9d4:	430a      	orrs	r2, r1
     9d6:	b2d2      	uxtb	r2, r2
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
     9d8:	541a      	strb	r2, [r3, r0]
	                       // <GPIO_PULL_UP"> Pull-up
	                       // <GPIO_PULL_DOWN"> Pull-down
	                       GPIO_PULL_OFF);

	gpio_set_pin_function(SCL__B_24V_POT, PINMUX_PB13C_SERCOM4_PAD1);
}
     9da:	bd70      	pop	{r4, r5, r6, pc}

000009dc <I2C_0_CLOCK_init>:
     9dc:	4b06      	ldr	r3, [pc, #24]	; (9f8 <I2C_0_CLOCK_init+0x1c>)
     9de:	2140      	movs	r1, #64	; 0x40
     9e0:	22dc      	movs	r2, #220	; 0xdc
     9e2:	5099      	str	r1, [r3, r2]
     9e4:	3103      	adds	r1, #3
     9e6:	3a14      	subs	r2, #20
     9e8:	5099      	str	r1, [r3, r2]
	((Mclk *)hw)->APBCMASK.reg |= MCLK_APBCMASK_SERCOM4;
     9ea:	4a04      	ldr	r2, [pc, #16]	; (9fc <I2C_0_CLOCK_init+0x20>)
     9ec:	69d3      	ldr	r3, [r2, #28]
     9ee:	3923      	subs	r1, #35	; 0x23
     9f0:	430b      	orrs	r3, r1
     9f2:	61d3      	str	r3, [r2, #28]
{
	hri_gclk_write_PCHCTRL_reg(GCLK, SERCOM4_GCLK_ID_CORE, CONF_GCLK_SERCOM4_CORE_SRC | (1 << GCLK_PCHCTRL_CHEN_Pos));
	hri_gclk_write_PCHCTRL_reg(GCLK, SERCOM4_GCLK_ID_SLOW, CONF_GCLK_SERCOM4_SLOW_SRC | (1 << GCLK_PCHCTRL_CHEN_Pos));

	hri_mclk_set_APBCMASK_SERCOM4_bit(MCLK);
}
     9f4:	4770      	bx	lr
     9f6:	46c0      	nop			; (mov r8, r8)
     9f8:	40001c00 	.word	0x40001c00
     9fc:	40000800 	.word	0x40000800

00000a00 <I2C_0_init>:

void I2C_0_init(void)
{
     a00:	b510      	push	{r4, lr}
	I2C_0_CLOCK_init();
     a02:	4b04      	ldr	r3, [pc, #16]	; (a14 <I2C_0_init+0x14>)
     a04:	4798      	blx	r3
	i2c_m_sync_init(&I2C_0, SERCOM4);
     a06:	4904      	ldr	r1, [pc, #16]	; (a18 <I2C_0_init+0x18>)
     a08:	4804      	ldr	r0, [pc, #16]	; (a1c <I2C_0_init+0x1c>)
     a0a:	4b05      	ldr	r3, [pc, #20]	; (a20 <I2C_0_init+0x20>)
     a0c:	4798      	blx	r3
	I2C_0_PORT_init();
     a0e:	4b05      	ldr	r3, [pc, #20]	; (a24 <I2C_0_init+0x24>)
     a10:	4798      	blx	r3
}
     a12:	bd10      	pop	{r4, pc}
     a14:	000009dd 	.word	0x000009dd
     a18:	42001400 	.word	0x42001400
     a1c:	200002bc 	.word	0x200002bc
     a20:	0000119d 	.word	0x0000119d
     a24:	0000098d 	.word	0x0000098d

00000a28 <CHG_POT_PORT_init>:

void CHG_POT_PORT_init(void)
{
     a28:	b5f0      	push	{r4, r5, r6, r7, lr}
     a2a:	46ce      	mov	lr, r9
     a2c:	4647      	mov	r7, r8
     a2e:	b580      	push	{r7, lr}
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = mask;
     a30:	24c0      	movs	r4, #192	; 0xc0
     a32:	05e4      	lsls	r4, r4, #23
     a34:	2384      	movs	r3, #132	; 0x84
     a36:	469c      	mov	ip, r3
     a38:	2180      	movs	r1, #128	; 0x80
     a3a:	0249      	lsls	r1, r1, #9
     a3c:	50e1      	str	r1, [r4, r3]
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg |= PORT_PINCFG_PULLEN;
     a3e:	2382      	movs	r3, #130	; 0x82
     a40:	05db      	lsls	r3, r3, #23
     a42:	20d0      	movs	r0, #208	; 0xd0
     a44:	5c1a      	ldrb	r2, [r3, r0]
     a46:	2704      	movs	r7, #4
     a48:	433a      	orrs	r2, r7
     a4a:	b2d2      	uxtb	r2, r2
     a4c:	541a      	strb	r2, [r3, r0]
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
     a4e:	2298      	movs	r2, #152	; 0x98
     a50:	4691      	mov	r9, r2
     a52:	50a1      	str	r1, [r4, r2]
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     a54:	5c19      	ldrb	r1, [r3, r0]
	tmp &= ~PORT_PINCFG_PMUXEN;
     a56:	2601      	movs	r6, #1
     a58:	43b1      	bics	r1, r6
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
     a5a:	2501      	movs	r5, #1
     a5c:	4329      	orrs	r1, r5
     a5e:	b2c9      	uxtb	r1, r1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     a60:	5419      	strb	r1, [r3, r0]
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
     a62:	3818      	subs	r0, #24
     a64:	5c19      	ldrb	r1, [r3, r0]
	tmp &= ~PORT_PMUX_PMUXE_Msk;
     a66:	3a89      	subs	r2, #137	; 0x89
     a68:	4391      	bics	r1, r2
	tmp |= PORT_PMUX_PMUXE(data);
     a6a:	2202      	movs	r2, #2
     a6c:	4690      	mov	r8, r2
     a6e:	4642      	mov	r2, r8
     a70:	4311      	orrs	r1, r2
     a72:	b2c9      	uxtb	r1, r1
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
     a74:	5419      	strb	r1, [r3, r0]
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = mask;
     a76:	2280      	movs	r2, #128	; 0x80
     a78:	0292      	lsls	r2, r2, #10
     a7a:	4690      	mov	r8, r2
     a7c:	4662      	mov	r2, ip
     a7e:	4641      	mov	r1, r8
     a80:	50a1      	str	r1, [r4, r2]
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg |= PORT_PINCFG_PULLEN;
     a82:	21d1      	movs	r1, #209	; 0xd1
     a84:	5c5a      	ldrb	r2, [r3, r1]
     a86:	4317      	orrs	r7, r2
     a88:	b2ff      	uxtb	r7, r7
     a8a:	545f      	strb	r7, [r3, r1]
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
     a8c:	4642      	mov	r2, r8
     a8e:	464f      	mov	r7, r9
     a90:	51e2      	str	r2, [r4, r7]
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     a92:	5c5a      	ldrb	r2, [r3, r1]
	tmp &= ~PORT_PINCFG_PMUXEN;
     a94:	43b2      	bics	r2, r6
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
     a96:	432a      	orrs	r2, r5
     a98:	b2d2      	uxtb	r2, r2
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     a9a:	545a      	strb	r2, [r3, r1]
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
     a9c:	5c1a      	ldrb	r2, [r3, r0]
	tmp &= ~PORT_PMUX_PMUXO_Msk;
     a9e:	39c2      	subs	r1, #194	; 0xc2
     aa0:	400a      	ands	r2, r1
	tmp |= PORT_PMUX_PMUXO(data);
     aa2:	2120      	movs	r1, #32
     aa4:	430a      	orrs	r2, r1
     aa6:	b2d2      	uxtb	r2, r2
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
     aa8:	541a      	strb	r2, [r3, r0]
	                       // <GPIO_PULL_UP"> Pull-up
	                       // <GPIO_PULL_DOWN"> Pull-down
	                       GPIO_PULL_UP);

	gpio_set_pin_function(SCL_CHG_POT, PINMUX_PB17C_SERCOM5_PAD1);
}
     aaa:	bc0c      	pop	{r2, r3}
     aac:	4690      	mov	r8, r2
     aae:	4699      	mov	r9, r3
     ab0:	bdf0      	pop	{r4, r5, r6, r7, pc}
	...

00000ab4 <CHG_POT_CLOCK_init>:
     ab4:	4b05      	ldr	r3, [pc, #20]	; (acc <CHG_POT_CLOCK_init+0x18>)
     ab6:	2140      	movs	r1, #64	; 0x40
     ab8:	22e4      	movs	r2, #228	; 0xe4
     aba:	5099      	str	r1, [r3, r2]
     abc:	2043      	movs	r0, #67	; 0x43
     abe:	3a04      	subs	r2, #4
     ac0:	5098      	str	r0, [r3, r2]
	((Mclk *)hw)->APBCMASK.reg |= MCLK_APBCMASK_SERCOM5;
     ac2:	4a03      	ldr	r2, [pc, #12]	; (ad0 <CHG_POT_CLOCK_init+0x1c>)
     ac4:	69d3      	ldr	r3, [r2, #28]
     ac6:	430b      	orrs	r3, r1
     ac8:	61d3      	str	r3, [r2, #28]
{
	hri_gclk_write_PCHCTRL_reg(GCLK, SERCOM5_GCLK_ID_CORE, CONF_GCLK_SERCOM5_CORE_SRC | (1 << GCLK_PCHCTRL_CHEN_Pos));
	hri_gclk_write_PCHCTRL_reg(GCLK, SERCOM5_GCLK_ID_SLOW, CONF_GCLK_SERCOM5_SLOW_SRC | (1 << GCLK_PCHCTRL_CHEN_Pos));

	hri_mclk_set_APBCMASK_SERCOM5_bit(MCLK);
}
     aca:	4770      	bx	lr
     acc:	40001c00 	.word	0x40001c00
     ad0:	40000800 	.word	0x40000800

00000ad4 <CHG_POT_init>:

void CHG_POT_init(void)
{
     ad4:	b510      	push	{r4, lr}
	CHG_POT_CLOCK_init();
     ad6:	4b04      	ldr	r3, [pc, #16]	; (ae8 <CHG_POT_init+0x14>)
     ad8:	4798      	blx	r3
	i2c_m_sync_init(&CHG_POT, SERCOM5);
     ada:	4904      	ldr	r1, [pc, #16]	; (aec <CHG_POT_init+0x18>)
     adc:	4804      	ldr	r0, [pc, #16]	; (af0 <CHG_POT_init+0x1c>)
     ade:	4b05      	ldr	r3, [pc, #20]	; (af4 <CHG_POT_init+0x20>)
     ae0:	4798      	blx	r3
	CHG_POT_PORT_init();
     ae2:	4b05      	ldr	r3, [pc, #20]	; (af8 <CHG_POT_init+0x24>)
     ae4:	4798      	blx	r3
}
     ae6:	bd10      	pop	{r4, pc}
     ae8:	00000ab5 	.word	0x00000ab5
     aec:	42001800 	.word	0x42001800
     af0:	2000023c 	.word	0x2000023c
     af4:	0000119d 	.word	0x0000119d
     af8:	00000a29 	.word	0x00000a29

00000afc <system_init>:

void system_init(void)
{
     afc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
     afe:	46de      	mov	lr, fp
     b00:	4657      	mov	r7, sl
     b02:	464e      	mov	r6, r9
     b04:	4645      	mov	r5, r8
     b06:	b5e0      	push	{r5, r6, r7, lr}
 * Currently the following initialization functions are supported:
 *  - System clock initialization
 */
static inline void init_mcu(void)
{
	_init_chip();
     b08:	4bfe      	ldr	r3, [pc, #1016]	; (f04 <system_init+0x408>)
     b0a:	4798      	blx	r3
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = mask;
     b0c:	22c0      	movs	r2, #192	; 0xc0
     b0e:	05d2      	lsls	r2, r2, #23
     b10:	2380      	movs	r3, #128	; 0x80
     b12:	02db      	lsls	r3, r3, #11
     b14:	6053      	str	r3, [r2, #4]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     b16:	2382      	movs	r3, #130	; 0x82
     b18:	05db      	lsls	r3, r3, #23
     b1a:	49fb      	ldr	r1, [pc, #1004]	; (f08 <system_init+0x40c>)
     b1c:	6299      	str	r1, [r3, #40]	; 0x28
     b1e:	49fb      	ldr	r1, [pc, #1004]	; (f0c <system_init+0x410>)
     b20:	6299      	str	r1, [r3, #40]	; 0x28
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg &= ~PORT_PINCFG_PULLEN;
     b22:	2052      	movs	r0, #82	; 0x52
     b24:	5c19      	ldrb	r1, [r3, r0]
     b26:	2404      	movs	r4, #4
     b28:	46a2      	mov	sl, r4
     b2a:	43a1      	bics	r1, r4
     b2c:	5419      	strb	r1, [r3, r0]
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     b2e:	5c1d      	ldrb	r5, [r3, r0]
	tmp &= ~PORT_PINCFG_PMUXEN;
     b30:	2101      	movs	r1, #1
     b32:	438d      	bics	r5, r1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     b34:	541d      	strb	r5, [r3, r0]
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     b36:	2553      	movs	r5, #83	; 0x53
     b38:	5d58      	ldrb	r0, [r3, r5]
	tmp &= ~PORT_PINCFG_PMUXEN;
     b3a:	4388      	bics	r0, r1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     b3c:	5558      	strb	r0, [r3, r5]
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     b3e:	3501      	adds	r5, #1
     b40:	5d58      	ldrb	r0, [r3, r5]
	tmp &= ~PORT_PINCFG_PMUXEN;
     b42:	4388      	bics	r0, r1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     b44:	5558      	strb	r0, [r3, r5]
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = mask;
     b46:	2080      	movs	r0, #128	; 0x80
     b48:	0440      	lsls	r0, r0, #17
     b4a:	6050      	str	r0, [r2, #4]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     b4c:	48ee      	ldr	r0, [pc, #952]	; (f08 <system_init+0x40c>)
     b4e:	6298      	str	r0, [r3, #40]	; 0x28
     b50:	48ef      	ldr	r0, [pc, #956]	; (f10 <system_init+0x414>)
     b52:	6298      	str	r0, [r3, #40]	; 0x28
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = mask;
     b54:	2080      	movs	r0, #128	; 0x80
     b56:	0440      	lsls	r0, r0, #17
     b58:	6050      	str	r0, [r2, #4]
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg |= PORT_PINCFG_PULLEN;
     b5a:	3504      	adds	r5, #4
     b5c:	5d58      	ldrb	r0, [r3, r5]
     b5e:	2604      	movs	r6, #4
     b60:	4330      	orrs	r0, r6
     b62:	b2c0      	uxtb	r0, r0
     b64:	5558      	strb	r0, [r3, r5]
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
     b66:	2080      	movs	r0, #128	; 0x80
     b68:	0440      	lsls	r0, r0, #17
     b6a:	6190      	str	r0, [r2, #24]
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     b6c:	5d58      	ldrb	r0, [r3, r5]
	tmp &= ~PORT_PINCFG_PMUXEN;
     b6e:	4388      	bics	r0, r1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     b70:	5558      	strb	r0, [r3, r5]
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = mask;
     b72:	2080      	movs	r0, #128	; 0x80
     b74:	0480      	lsls	r0, r0, #18
     b76:	4681      	mov	r9, r0
     b78:	6050      	str	r0, [r2, #4]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     b7a:	48e3      	ldr	r0, [pc, #908]	; (f08 <system_init+0x40c>)
     b7c:	6298      	str	r0, [r3, #40]	; 0x28
     b7e:	48e5      	ldr	r0, [pc, #916]	; (f14 <system_init+0x418>)
     b80:	6298      	str	r0, [r3, #40]	; 0x28
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = mask;
     b82:	4648      	mov	r0, r9
     b84:	6050      	str	r0, [r2, #4]
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg |= PORT_PINCFG_PULLEN;
     b86:	3501      	adds	r5, #1
     b88:	5d58      	ldrb	r0, [r3, r5]
     b8a:	4330      	orrs	r0, r6
     b8c:	b2c0      	uxtb	r0, r0
     b8e:	5558      	strb	r0, [r3, r5]
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
     b90:	4648      	mov	r0, r9
     b92:	6190      	str	r0, [r2, #24]
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     b94:	5d58      	ldrb	r0, [r3, r5]
	tmp &= ~PORT_PINCFG_PMUXEN;
     b96:	4388      	bics	r0, r1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     b98:	5558      	strb	r0, [r3, r5]
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
     b9a:	3694      	adds	r6, #148	; 0x94
     b9c:	5191      	str	r1, [r2, r6]
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     b9e:	352f      	adds	r5, #47	; 0x2f
     ba0:	5151      	str	r1, [r2, r5]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     ba2:	20a8      	movs	r0, #168	; 0xa8
     ba4:	4fdc      	ldr	r7, [pc, #880]	; (f18 <system_init+0x41c>)
     ba6:	501f      	str	r7, [r3, r0]
     ba8:	24c0      	movs	r4, #192	; 0xc0
     baa:	0624      	lsls	r4, r4, #24
     bac:	501c      	str	r4, [r3, r0]
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     bae:	27c0      	movs	r7, #192	; 0xc0
     bb0:	46b8      	mov	r8, r7
     bb2:	5ddf      	ldrb	r7, [r3, r7]
	tmp &= ~PORT_PINCFG_PMUXEN;
     bb4:	438f      	bics	r7, r1
     bb6:	46bc      	mov	ip, r7
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     bb8:	4647      	mov	r7, r8
     bba:	4664      	mov	r4, ip
     bbc:	55dc      	strb	r4, [r3, r7]
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
     bbe:	2402      	movs	r4, #2
     bc0:	5194      	str	r4, [r2, r6]
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     bc2:	5154      	str	r4, [r2, r5]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     bc4:	4cd5      	ldr	r4, [pc, #852]	; (f1c <system_init+0x420>)
     bc6:	501c      	str	r4, [r3, r0]
     bc8:	24c0      	movs	r4, #192	; 0xc0
     bca:	0624      	lsls	r4, r4, #24
     bcc:	501c      	str	r4, [r3, r0]
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     bce:	24c1      	movs	r4, #193	; 0xc1
     bd0:	46a0      	mov	r8, r4
     bd2:	5d1c      	ldrb	r4, [r3, r4]
	tmp &= ~PORT_PINCFG_PMUXEN;
     bd4:	0027      	movs	r7, r4
     bd6:	438f      	bics	r7, r1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     bd8:	4644      	mov	r4, r8
     bda:	551f      	strb	r7, [r3, r4]
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
     bdc:	4654      	mov	r4, sl
     bde:	5194      	str	r4, [r2, r6]
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     be0:	5154      	str	r4, [r2, r5]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     be2:	4ccf      	ldr	r4, [pc, #828]	; (f20 <system_init+0x424>)
     be4:	501c      	str	r4, [r3, r0]
     be6:	24c0      	movs	r4, #192	; 0xc0
     be8:	0624      	lsls	r4, r4, #24
     bea:	501c      	str	r4, [r3, r0]
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     bec:	24c2      	movs	r4, #194	; 0xc2
     bee:	46a4      	mov	ip, r4
     bf0:	5d1c      	ldrb	r4, [r3, r4]
	tmp &= ~PORT_PINCFG_PMUXEN;
     bf2:	438c      	bics	r4, r1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     bf4:	4667      	mov	r7, ip
     bf6:	55dc      	strb	r4, [r3, r7]
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
     bf8:	2408      	movs	r4, #8
     bfa:	5194      	str	r4, [r2, r6]
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     bfc:	5154      	str	r4, [r2, r5]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     bfe:	4cc9      	ldr	r4, [pc, #804]	; (f24 <system_init+0x428>)
     c00:	501c      	str	r4, [r3, r0]
     c02:	24c0      	movs	r4, #192	; 0xc0
     c04:	0624      	lsls	r4, r4, #24
     c06:	501c      	str	r4, [r3, r0]
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     c08:	24c3      	movs	r4, #195	; 0xc3
     c0a:	46a4      	mov	ip, r4
     c0c:	5d1c      	ldrb	r4, [r3, r4]
	tmp &= ~PORT_PINCFG_PMUXEN;
     c0e:	438c      	bics	r4, r1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     c10:	4667      	mov	r7, ip
     c12:	55dc      	strb	r4, [r3, r7]
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
     c14:	2480      	movs	r4, #128	; 0x80
     c16:	0224      	lsls	r4, r4, #8
     c18:	5194      	str	r4, [r2, r6]
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     c1a:	5154      	str	r4, [r2, r5]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     c1c:	4cc2      	ldr	r4, [pc, #776]	; (f28 <system_init+0x42c>)
     c1e:	501c      	str	r4, [r3, r0]
     c20:	24c0      	movs	r4, #192	; 0xc0
     c22:	0624      	lsls	r4, r4, #24
     c24:	501c      	str	r4, [r3, r0]
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     c26:	24cf      	movs	r4, #207	; 0xcf
     c28:	46a4      	mov	ip, r4
     c2a:	5d1c      	ldrb	r4, [r3, r4]
	tmp &= ~PORT_PINCFG_PMUXEN;
     c2c:	438c      	bics	r4, r1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     c2e:	4667      	mov	r7, ip
     c30:	55dc      	strb	r4, [r3, r7]
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
     c32:	2494      	movs	r4, #148	; 0x94
     c34:	2780      	movs	r7, #128	; 0x80
     c36:	02ff      	lsls	r7, r7, #11
     c38:	5117      	str	r7, [r2, r4]
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     c3a:	5157      	str	r7, [r2, r5]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     c3c:	2480      	movs	r4, #128	; 0x80
     c3e:	05e4      	lsls	r4, r4, #23
     c40:	501c      	str	r4, [r3, r0]
     c42:	4fba      	ldr	r7, [pc, #744]	; (f2c <system_init+0x430>)
     c44:	501f      	str	r7, [r3, r0]
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     c46:	27d2      	movs	r7, #210	; 0xd2
     c48:	46b8      	mov	r8, r7
     c4a:	5ddf      	ldrb	r7, [r3, r7]
	tmp &= ~PORT_PINCFG_PMUXEN;
     c4c:	438f      	bics	r7, r1
     c4e:	46bc      	mov	ip, r7
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     c50:	4647      	mov	r7, r8
     c52:	4664      	mov	r4, ip
     c54:	55dc      	strb	r4, [r3, r7]
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
     c56:	2480      	movs	r4, #128	; 0x80
     c58:	0324      	lsls	r4, r4, #12
     c5a:	5194      	str	r4, [r2, r6]
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     c5c:	5154      	str	r4, [r2, r5]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     c5e:	2480      	movs	r4, #128	; 0x80
     c60:	05e4      	lsls	r4, r4, #23
     c62:	501c      	str	r4, [r3, r0]
     c64:	4cb2      	ldr	r4, [pc, #712]	; (f30 <system_init+0x434>)
     c66:	501c      	str	r4, [r3, r0]
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     c68:	24d3      	movs	r4, #211	; 0xd3
     c6a:	46a0      	mov	r8, r4
     c6c:	5d1c      	ldrb	r4, [r3, r4]
	tmp &= ~PORT_PINCFG_PMUXEN;
     c6e:	0027      	movs	r7, r4
     c70:	438f      	bics	r7, r1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     c72:	4644      	mov	r4, r8
     c74:	551f      	strb	r7, [r3, r4]
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
     c76:	2480      	movs	r4, #128	; 0x80
     c78:	0364      	lsls	r4, r4, #13
     c7a:	46a0      	mov	r8, r4
     c7c:	5194      	str	r4, [r2, r6]
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     c7e:	5154      	str	r4, [r2, r5]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     c80:	2480      	movs	r4, #128	; 0x80
     c82:	05e4      	lsls	r4, r4, #23
     c84:	501c      	str	r4, [r3, r0]
     c86:	4cab      	ldr	r4, [pc, #684]	; (f34 <system_init+0x438>)
     c88:	501c      	str	r4, [r3, r0]
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     c8a:	24d4      	movs	r4, #212	; 0xd4
     c8c:	46a2      	mov	sl, r4
     c8e:	5d1c      	ldrb	r4, [r3, r4]
	tmp &= ~PORT_PINCFG_PMUXEN;
     c90:	0027      	movs	r7, r4
     c92:	438f      	bics	r7, r1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     c94:	4654      	mov	r4, sl
     c96:	551f      	strb	r7, [r3, r4]
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
     c98:	2480      	movs	r4, #128	; 0x80
     c9a:	03a4      	lsls	r4, r4, #14
     c9c:	46a4      	mov	ip, r4
     c9e:	5194      	str	r4, [r2, r6]
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     ca0:	5154      	str	r4, [r2, r5]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     ca2:	2480      	movs	r4, #128	; 0x80
     ca4:	05e4      	lsls	r4, r4, #23
     ca6:	501c      	str	r4, [r3, r0]
     ca8:	4ca3      	ldr	r4, [pc, #652]	; (f38 <system_init+0x43c>)
     caa:	501c      	str	r4, [r3, r0]
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     cac:	24d5      	movs	r4, #213	; 0xd5
     cae:	46a3      	mov	fp, r4
     cb0:	5d1c      	ldrb	r4, [r3, r4]
	tmp &= ~PORT_PINCFG_PMUXEN;
     cb2:	0027      	movs	r7, r4
     cb4:	438f      	bics	r7, r1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     cb6:	465c      	mov	r4, fp
     cb8:	551f      	strb	r7, [r3, r4]
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
     cba:	2480      	movs	r4, #128	; 0x80
     cbc:	0424      	lsls	r4, r4, #16
     cbe:	5194      	str	r4, [r2, r6]
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     cc0:	5154      	str	r4, [r2, r5]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     cc2:	2480      	movs	r4, #128	; 0x80
     cc4:	05e4      	lsls	r4, r4, #23
     cc6:	501c      	str	r4, [r3, r0]
     cc8:	4c9c      	ldr	r4, [pc, #624]	; (f3c <system_init+0x440>)
     cca:	501c      	str	r4, [r3, r0]
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     ccc:	24d7      	movs	r4, #215	; 0xd7
     cce:	46a3      	mov	fp, r4
     cd0:	5d1c      	ldrb	r4, [r3, r4]
	tmp &= ~PORT_PINCFG_PMUXEN;
     cd2:	0027      	movs	r7, r4
     cd4:	438f      	bics	r7, r1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     cd6:	465c      	mov	r4, fp
     cd8:	551f      	strb	r7, [r3, r4]
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
     cda:	464c      	mov	r4, r9
     cdc:	5194      	str	r4, [r2, r6]
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     cde:	5154      	str	r4, [r2, r5]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     ce0:	2480      	movs	r4, #128	; 0x80
     ce2:	05e4      	lsls	r4, r4, #23
     ce4:	501c      	str	r4, [r3, r0]
     ce6:	4c96      	ldr	r4, [pc, #600]	; (f40 <system_init+0x444>)
     ce8:	501c      	str	r4, [r3, r0]
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     cea:	24d9      	movs	r4, #217	; 0xd9
     cec:	46a2      	mov	sl, r4
     cee:	5d1c      	ldrb	r4, [r3, r4]
	tmp &= ~PORT_PINCFG_PMUXEN;
     cf0:	0027      	movs	r7, r4
     cf2:	438f      	bics	r7, r1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     cf4:	4654      	mov	r4, sl
     cf6:	551f      	strb	r7, [r3, r4]
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
     cf8:	2480      	movs	r4, #128	; 0x80
     cfa:	0624      	lsls	r4, r4, #24
     cfc:	5194      	str	r4, [r2, r6]
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     cfe:	5154      	str	r4, [r2, r5]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     d00:	2480      	movs	r4, #128	; 0x80
     d02:	05e4      	lsls	r4, r4, #23
     d04:	501c      	str	r4, [r3, r0]
     d06:	4d8f      	ldr	r5, [pc, #572]	; (f44 <system_init+0x448>)
     d08:	501d      	str	r5, [r3, r0]
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     d0a:	25df      	movs	r5, #223	; 0xdf
     d0c:	5d58      	ldrb	r0, [r3, r5]
	tmp &= ~PORT_PINCFG_PMUXEN;
     d0e:	4388      	bics	r0, r1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     d10:	5558      	strb	r0, [r3, r5]
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
     d12:	3680      	adds	r6, #128	; 0x80
     d14:	2040      	movs	r0, #64	; 0x40
     d16:	5190      	str	r0, [r2, r6]
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     d18:	3529      	adds	r5, #41	; 0x29
     d1a:	5150      	str	r0, [r2, r5]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     d1c:	30e8      	adds	r0, #232	; 0xe8
     d1e:	4c8a      	ldr	r4, [pc, #552]	; (f48 <system_init+0x44c>)
     d20:	501c      	str	r4, [r3, r0]
     d22:	24c0      	movs	r4, #192	; 0xc0
     d24:	0624      	lsls	r4, r4, #24
     d26:	501c      	str	r4, [r3, r0]
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     d28:	24a3      	movs	r4, #163	; 0xa3
     d2a:	0064      	lsls	r4, r4, #1
     d2c:	46a2      	mov	sl, r4
     d2e:	5d1c      	ldrb	r4, [r3, r4]
	tmp &= ~PORT_PINCFG_PMUXEN;
     d30:	0027      	movs	r7, r4
     d32:	438f      	bics	r7, r1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     d34:	4654      	mov	r4, sl
     d36:	551f      	strb	r7, [r3, r4]
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
     d38:	3cc6      	subs	r4, #198	; 0xc6
     d3a:	5194      	str	r4, [r2, r6]
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     d3c:	5154      	str	r4, [r2, r5]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     d3e:	4c83      	ldr	r4, [pc, #524]	; (f4c <system_init+0x450>)
     d40:	501c      	str	r4, [r3, r0]
     d42:	24c0      	movs	r4, #192	; 0xc0
     d44:	0624      	lsls	r4, r4, #24
     d46:	501c      	str	r4, [r3, r0]
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     d48:	2448      	movs	r4, #72	; 0x48
     d4a:	34ff      	adds	r4, #255	; 0xff
     d4c:	46a2      	mov	sl, r4
     d4e:	5d1c      	ldrb	r4, [r3, r4]
	tmp &= ~PORT_PINCFG_PMUXEN;
     d50:	0027      	movs	r7, r4
     d52:	438f      	bics	r7, r1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     d54:	4654      	mov	r4, sl
     d56:	551f      	strb	r7, [r3, r4]
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
     d58:	34b9      	adds	r4, #185	; 0xb9
     d5a:	5194      	str	r4, [r2, r6]
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
     d5c:	3cec      	subs	r4, #236	; 0xec
     d5e:	46a1      	mov	r9, r4
     d60:	2480      	movs	r4, #128	; 0x80
     d62:	00e4      	lsls	r4, r4, #3
     d64:	46a2      	mov	sl, r4
     d66:	464c      	mov	r4, r9
     d68:	4657      	mov	r7, sl
     d6a:	5117      	str	r7, [r2, r4]
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     d6c:	5157      	str	r7, [r2, r5]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     d6e:	4c78      	ldr	r4, [pc, #480]	; (f50 <system_init+0x454>)
     d70:	501c      	str	r4, [r3, r0]
     d72:	24c0      	movs	r4, #192	; 0xc0
     d74:	0624      	lsls	r4, r4, #24
     d76:	501c      	str	r4, [r3, r0]
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     d78:	24a5      	movs	r4, #165	; 0xa5
     d7a:	0064      	lsls	r4, r4, #1
     d7c:	46a3      	mov	fp, r4
     d7e:	5d1c      	ldrb	r4, [r3, r4]
	tmp &= ~PORT_PINCFG_PMUXEN;
     d80:	0027      	movs	r7, r4
     d82:	438f      	bics	r7, r1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     d84:	465c      	mov	r4, fp
     d86:	551f      	strb	r7, [r3, r4]
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
     d88:	2480      	movs	r4, #128	; 0x80
     d8a:	0164      	lsls	r4, r4, #5
     d8c:	5194      	str	r4, [r2, r6]
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     d8e:	5154      	str	r4, [r2, r5]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     d90:	4c70      	ldr	r4, [pc, #448]	; (f54 <system_init+0x458>)
     d92:	501c      	str	r4, [r3, r0]
     d94:	24c0      	movs	r4, #192	; 0xc0
     d96:	0624      	lsls	r4, r4, #24
     d98:	501c      	str	r4, [r3, r0]
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     d9a:	24a6      	movs	r4, #166	; 0xa6
     d9c:	0064      	lsls	r4, r4, #1
     d9e:	46a3      	mov	fp, r4
     da0:	5d1c      	ldrb	r4, [r3, r4]
	tmp &= ~PORT_PINCFG_PMUXEN;
     da2:	0027      	movs	r7, r4
     da4:	438f      	bics	r7, r1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     da6:	465c      	mov	r4, fp
     da8:	551f      	strb	r7, [r3, r4]
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
     daa:	2480      	movs	r4, #128	; 0x80
     dac:	01a4      	lsls	r4, r4, #6
     dae:	5194      	str	r4, [r2, r6]
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     db0:	5154      	str	r4, [r2, r5]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     db2:	4c69      	ldr	r4, [pc, #420]	; (f58 <system_init+0x45c>)
     db4:	501c      	str	r4, [r3, r0]
     db6:	24c0      	movs	r4, #192	; 0xc0
     db8:	0624      	lsls	r4, r4, #24
     dba:	501c      	str	r4, [r3, r0]
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     dbc:	244e      	movs	r4, #78	; 0x4e
     dbe:	34ff      	adds	r4, #255	; 0xff
     dc0:	46a3      	mov	fp, r4
     dc2:	5d1c      	ldrb	r4, [r3, r4]
	tmp &= ~PORT_PINCFG_PMUXEN;
     dc4:	0027      	movs	r7, r4
     dc6:	438f      	bics	r7, r1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     dc8:	465c      	mov	r4, fp
     dca:	551f      	strb	r7, [r3, r4]
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
     dcc:	2480      	movs	r4, #128	; 0x80
     dce:	01e4      	lsls	r4, r4, #7
     dd0:	5194      	str	r4, [r2, r6]
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     dd2:	5154      	str	r4, [r2, r5]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     dd4:	4c61      	ldr	r4, [pc, #388]	; (f5c <system_init+0x460>)
     dd6:	501c      	str	r4, [r3, r0]
     dd8:	24c0      	movs	r4, #192	; 0xc0
     dda:	0624      	lsls	r4, r4, #24
     ddc:	501c      	str	r4, [r3, r0]
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     dde:	24a7      	movs	r4, #167	; 0xa7
     de0:	0064      	lsls	r4, r4, #1
     de2:	46a3      	mov	fp, r4
     de4:	5d1c      	ldrb	r4, [r3, r4]
	tmp &= ~PORT_PINCFG_PMUXEN;
     de6:	0027      	movs	r7, r4
     de8:	438f      	bics	r7, r1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     dea:	465c      	mov	r4, fp
     dec:	551f      	strb	r7, [r3, r4]
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
     dee:	2480      	movs	r4, #128	; 0x80
     df0:	0224      	lsls	r4, r4, #8
     df2:	5194      	str	r4, [r2, r6]
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     df4:	5154      	str	r4, [r2, r5]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     df6:	4c4c      	ldr	r4, [pc, #304]	; (f28 <system_init+0x42c>)
     df8:	501c      	str	r4, [r3, r0]
     dfa:	24c0      	movs	r4, #192	; 0xc0
     dfc:	0624      	lsls	r4, r4, #24
     dfe:	501c      	str	r4, [r3, r0]
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     e00:	2450      	movs	r4, #80	; 0x50
     e02:	34ff      	adds	r4, #255	; 0xff
     e04:	5d1f      	ldrb	r7, [r3, r4]
	tmp &= ~PORT_PINCFG_PMUXEN;
     e06:	438f      	bics	r7, r1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     e08:	551f      	strb	r7, [r3, r4]
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
     e0a:	2780      	movs	r7, #128	; 0x80
     e0c:	027f      	lsls	r7, r7, #9
     e0e:	464c      	mov	r4, r9
     e10:	5117      	str	r7, [r2, r4]
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     e12:	5157      	str	r7, [r2, r5]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     e14:	2480      	movs	r4, #128	; 0x80
     e16:	05e4      	lsls	r4, r4, #23
     e18:	501c      	str	r4, [r3, r0]
     e1a:	4f51      	ldr	r7, [pc, #324]	; (f60 <system_init+0x464>)
     e1c:	501f      	str	r7, [r3, r0]
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     e1e:	24a8      	movs	r4, #168	; 0xa8
     e20:	0064      	lsls	r4, r4, #1
     e22:	5d1f      	ldrb	r7, [r3, r4]
	tmp &= ~PORT_PINCFG_PMUXEN;
     e24:	438f      	bics	r7, r1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     e26:	551f      	strb	r7, [r3, r4]
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
     e28:	2780      	movs	r7, #128	; 0x80
     e2a:	02bf      	lsls	r7, r7, #10
     e2c:	464c      	mov	r4, r9
     e2e:	5117      	str	r7, [r2, r4]
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     e30:	5157      	str	r7, [r2, r5]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     e32:	2480      	movs	r4, #128	; 0x80
     e34:	05e4      	lsls	r4, r4, #23
     e36:	501c      	str	r4, [r3, r0]
     e38:	4f4a      	ldr	r7, [pc, #296]	; (f64 <system_init+0x468>)
     e3a:	501f      	str	r7, [r3, r0]
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     e3c:	2452      	movs	r4, #82	; 0x52
     e3e:	34ff      	adds	r4, #255	; 0xff
     e40:	5d1f      	ldrb	r7, [r3, r4]
	tmp &= ~PORT_PINCFG_PMUXEN;
     e42:	438f      	bics	r7, r1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     e44:	551f      	strb	r7, [r3, r4]
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
     e46:	464c      	mov	r4, r9
     e48:	2780      	movs	r7, #128	; 0x80
     e4a:	02ff      	lsls	r7, r7, #11
     e4c:	5117      	str	r7, [r2, r4]
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     e4e:	5157      	str	r7, [r2, r5]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     e50:	2480      	movs	r4, #128	; 0x80
     e52:	05e4      	lsls	r4, r4, #23
     e54:	501c      	str	r4, [r3, r0]
     e56:	4c35      	ldr	r4, [pc, #212]	; (f2c <system_init+0x430>)
     e58:	501c      	str	r4, [r3, r0]
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     e5a:	24a9      	movs	r4, #169	; 0xa9
     e5c:	0064      	lsls	r4, r4, #1
     e5e:	5d1f      	ldrb	r7, [r3, r4]
	tmp &= ~PORT_PINCFG_PMUXEN;
     e60:	438f      	bics	r7, r1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     e62:	551f      	strb	r7, [r3, r4]
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
     e64:	2480      	movs	r4, #128	; 0x80
     e66:	0324      	lsls	r4, r4, #12
     e68:	5194      	str	r4, [r2, r6]
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     e6a:	5154      	str	r4, [r2, r5]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     e6c:	2480      	movs	r4, #128	; 0x80
     e6e:	05e4      	lsls	r4, r4, #23
     e70:	501c      	str	r4, [r3, r0]
     e72:	4c2f      	ldr	r4, [pc, #188]	; (f30 <system_init+0x434>)
     e74:	501c      	str	r4, [r3, r0]
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     e76:	2454      	movs	r4, #84	; 0x54
     e78:	34ff      	adds	r4, #255	; 0xff
     e7a:	5d1f      	ldrb	r7, [r3, r4]
	tmp &= ~PORT_PINCFG_PMUXEN;
     e7c:	438f      	bics	r7, r1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     e7e:	551f      	strb	r7, [r3, r4]
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = mask;
     e80:	3c4f      	subs	r4, #79	; 0x4f
     e82:	46a1      	mov	r9, r4
     e84:	4647      	mov	r7, r8
     e86:	5117      	str	r7, [r2, r4]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     e88:	4c1f      	ldr	r4, [pc, #124]	; (f08 <system_init+0x40c>)
     e8a:	501c      	str	r4, [r3, r0]
     e8c:	4f36      	ldr	r7, [pc, #216]	; (f68 <system_init+0x46c>)
     e8e:	501f      	str	r7, [r3, r0]
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = mask;
     e90:	464c      	mov	r4, r9
     e92:	4647      	mov	r7, r8
     e94:	5117      	str	r7, [r2, r4]
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg |= PORT_PINCFG_PULLEN;
     e96:	3450      	adds	r4, #80	; 0x50
     e98:	46a2      	mov	sl, r4
     e9a:	5d1f      	ldrb	r7, [r3, r4]
     e9c:	3c51      	subs	r4, #81	; 0x51
     e9e:	3cff      	subs	r4, #255	; 0xff
     ea0:	4327      	orrs	r7, r4
     ea2:	b2ff      	uxtb	r7, r7
     ea4:	4654      	mov	r4, sl
     ea6:	551f      	strb	r7, [r3, r4]
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
     ea8:	4644      	mov	r4, r8
     eaa:	5194      	str	r4, [r2, r6]
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     eac:	4654      	mov	r4, sl
     eae:	5d1f      	ldrb	r7, [r3, r4]
	tmp &= ~PORT_PINCFG_PMUXEN;
     eb0:	438f      	bics	r7, r1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     eb2:	551f      	strb	r7, [r3, r4]
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = mask;
     eb4:	464c      	mov	r4, r9
     eb6:	4667      	mov	r7, ip
     eb8:	5117      	str	r7, [r2, r4]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     eba:	4c13      	ldr	r4, [pc, #76]	; (f08 <system_init+0x40c>)
     ebc:	501c      	str	r4, [r3, r0]
     ebe:	4f2b      	ldr	r7, [pc, #172]	; (f6c <system_init+0x470>)
     ec0:	501f      	str	r7, [r3, r0]
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = mask;
     ec2:	464c      	mov	r4, r9
     ec4:	4667      	mov	r7, ip
     ec6:	5117      	str	r7, [r2, r4]
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg |= PORT_PINCFG_PULLEN;
     ec8:	2456      	movs	r4, #86	; 0x56
     eca:	34ff      	adds	r4, #255	; 0xff
     ecc:	46a0      	mov	r8, r4
     ece:	5d1f      	ldrb	r7, [r3, r4]
     ed0:	3c52      	subs	r4, #82	; 0x52
     ed2:	3cff      	subs	r4, #255	; 0xff
     ed4:	4327      	orrs	r7, r4
     ed6:	b2ff      	uxtb	r7, r7
     ed8:	4644      	mov	r4, r8
     eda:	551f      	strb	r7, [r3, r4]
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
     edc:	4664      	mov	r4, ip
     ede:	5194      	str	r4, [r2, r6]
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     ee0:	4644      	mov	r4, r8
     ee2:	5d1f      	ldrb	r7, [r3, r4]
	tmp &= ~PORT_PINCFG_PMUXEN;
     ee4:	438f      	bics	r7, r1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     ee6:	551f      	strb	r7, [r3, r4]
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
     ee8:	2480      	movs	r4, #128	; 0x80
     eea:	0464      	lsls	r4, r4, #17
     eec:	5194      	str	r4, [r2, r6]
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     eee:	5154      	str	r4, [r2, r5]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     ef0:	2480      	movs	r4, #128	; 0x80
     ef2:	05e4      	lsls	r4, r4, #23
     ef4:	501c      	str	r4, [r3, r0]
     ef6:	4f1e      	ldr	r7, [pc, #120]	; (f70 <system_init+0x474>)
     ef8:	501f      	str	r7, [r3, r0]
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     efa:	24ac      	movs	r4, #172	; 0xac
     efc:	0064      	lsls	r4, r4, #1
     efe:	5d1f      	ldrb	r7, [r3, r4]
     f00:	e038      	b.n	f74 <system_init+0x478>
     f02:	46c0      	nop			; (mov r8, r8)
     f04:	000015a9 	.word	0x000015a9
     f08:	40020000 	.word	0x40020000
     f0c:	c0020004 	.word	0xc0020004
     f10:	c0020100 	.word	0xc0020100
     f14:	c0020200 	.word	0xc0020200
     f18:	40000001 	.word	0x40000001
     f1c:	40000002 	.word	0x40000002
     f20:	40000004 	.word	0x40000004
     f24:	40000008 	.word	0x40000008
     f28:	40008000 	.word	0x40008000
     f2c:	c0000004 	.word	0xc0000004
     f30:	c0000008 	.word	0xc0000008
     f34:	c0000010 	.word	0xc0000010
     f38:	c0000020 	.word	0xc0000020
     f3c:	c0000080 	.word	0xc0000080
     f40:	c0000200 	.word	0xc0000200
     f44:	c0008000 	.word	0xc0008000
     f48:	40000040 	.word	0x40000040
     f4c:	40000080 	.word	0x40000080
     f50:	40000400 	.word	0x40000400
     f54:	40001000 	.word	0x40001000
     f58:	40002000 	.word	0x40002000
     f5c:	40004000 	.word	0x40004000
     f60:	c0000001 	.word	0xc0000001
     f64:	c0000002 	.word	0xc0000002
     f68:	c0020010 	.word	0xc0020010
     f6c:	c0020020 	.word	0xc0020020
     f70:	c0000100 	.word	0xc0000100
	tmp &= ~PORT_PINCFG_PMUXEN;
     f74:	438f      	bics	r7, r1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     f76:	551f      	strb	r7, [r3, r4]
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
     f78:	2780      	movs	r7, #128	; 0x80
     f7a:	053f      	lsls	r7, r7, #20
     f7c:	5197      	str	r7, [r2, r6]
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     f7e:	5157      	str	r7, [r2, r5]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     f80:	2480      	movs	r4, #128	; 0x80
     f82:	05e4      	lsls	r4, r4, #23
     f84:	501c      	str	r4, [r3, r0]
     f86:	4f15      	ldr	r7, [pc, #84]	; (fdc <system_init+0x4e0>)
     f88:	501f      	str	r7, [r3, r0]
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     f8a:	245c      	movs	r4, #92	; 0x5c
     f8c:	34ff      	adds	r4, #255	; 0xff
     f8e:	5d1f      	ldrb	r7, [r3, r4]
	tmp &= ~PORT_PINCFG_PMUXEN;
     f90:	438f      	bics	r7, r1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     f92:	551f      	strb	r7, [r3, r4]
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
     f94:	2780      	movs	r7, #128	; 0x80
     f96:	057f      	lsls	r7, r7, #21
     f98:	5197      	str	r7, [r2, r6]
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     f9a:	5157      	str	r7, [r2, r5]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     f9c:	2280      	movs	r2, #128	; 0x80
     f9e:	05d2      	lsls	r2, r2, #23
     fa0:	501a      	str	r2, [r3, r0]
     fa2:	4a0f      	ldr	r2, [pc, #60]	; (fe0 <system_init+0x4e4>)
     fa4:	501a      	str	r2, [r3, r0]
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     fa6:	3034      	adds	r0, #52	; 0x34
     fa8:	5c1a      	ldrb	r2, [r3, r0]
	tmp &= ~PORT_PINCFG_PMUXEN;
     faa:	438a      	bics	r2, r1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     fac:	541a      	strb	r2, [r3, r0]
	// Set pin direction to output
	gpio_set_pin_direction(MCU_FUSE, GPIO_DIRECTION_OUT);

	gpio_set_pin_function(MCU_FUSE, GPIO_PIN_FUNCTION_OFF);

	ADC_B_init();
     fae:	4b0d      	ldr	r3, [pc, #52]	; (fe4 <system_init+0x4e8>)
     fb0:	4798      	blx	r3
	ADC_A_init();
     fb2:	4b0d      	ldr	r3, [pc, #52]	; (fe8 <system_init+0x4ec>)
     fb4:	4798      	blx	r3

	EXTERNAL_IRQ_init();
     fb6:	4b0d      	ldr	r3, [pc, #52]	; (fec <system_init+0x4f0>)
     fb8:	4798      	blx	r3

	FG_I2C_init();
     fba:	4b0d      	ldr	r3, [pc, #52]	; (ff0 <system_init+0x4f4>)
     fbc:	4798      	blx	r3

	AFE_I2C_init();
     fbe:	4b0d      	ldr	r3, [pc, #52]	; (ff4 <system_init+0x4f8>)
     fc0:	4798      	blx	r3

	FLASH_init();
     fc2:	4b0d      	ldr	r3, [pc, #52]	; (ff8 <system_init+0x4fc>)
     fc4:	4798      	blx	r3

	I2C_0_init();
     fc6:	4b0d      	ldr	r3, [pc, #52]	; (ffc <system_init+0x500>)
     fc8:	4798      	blx	r3

	CHG_POT_init();
     fca:	4b0d      	ldr	r3, [pc, #52]	; (1000 <system_init+0x504>)
     fcc:	4798      	blx	r3
}
     fce:	bc3c      	pop	{r2, r3, r4, r5}
     fd0:	4690      	mov	r8, r2
     fd2:	4699      	mov	r9, r3
     fd4:	46a2      	mov	sl, r4
     fd6:	46ab      	mov	fp, r5
     fd8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
     fda:	46c0      	nop			; (mov r8, r8)
     fdc:	c0000800 	.word	0xc0000800
     fe0:	c0001000 	.word	0xc0001000
     fe4:	00000209 	.word	0x00000209
     fe8:	00000195 	.word	0x00000195
     fec:	00000449 	.word	0x00000449
     ff0:	000007b5 	.word	0x000007b5
     ff4:	0000086d 	.word	0x0000086d
     ff8:	00000965 	.word	0x00000965
     ffc:	00000a01 	.word	0x00000a01
    1000:	00000ad5 	.word	0x00000ad5

00001004 <adc_dma_complete>:
 *
 * \param[in] device The pointer to ADC device structure
 * \param[in] data Converted data
 */
static void adc_dma_complete(struct _dma_resource *resource)
{
    1004:	b510      	push	{r4, lr}
	struct adc_dma_descriptor *const descr = (struct adc_dma_descriptor *)resource->back;
    1006:	6880      	ldr	r0, [r0, #8]

	if (descr->adc_dma_cb.convert_done) {
    1008:	6943      	ldr	r3, [r0, #20]
    100a:	2b00      	cmp	r3, #0
    100c:	d000      	beq.n	1010 <adc_dma_complete+0xc>
		descr->adc_dma_cb.convert_done(descr);
    100e:	4798      	blx	r3
	}
}
    1010:	bd10      	pop	{r4, pc}

00001012 <adc_dma_error_occured>:

static void adc_dma_error_occured(struct _dma_resource *resource)
{
    1012:	b510      	push	{r4, lr}
	struct adc_dma_descriptor *const descr = (struct adc_dma_descriptor *)resource->back;
    1014:	6880      	ldr	r0, [r0, #8]

	if (descr->adc_dma_cb.error) {
    1016:	6983      	ldr	r3, [r0, #24]
    1018:	2b00      	cmp	r3, #0
    101a:	d000      	beq.n	101e <adc_dma_error_occured+0xc>
		descr->adc_dma_cb.error(descr);
    101c:	4798      	blx	r3
	}
}
    101e:	bd10      	pop	{r4, pc}

00001020 <adc_dma_init>:
{
    1020:	b570      	push	{r4, r5, r6, lr}
    1022:	0004      	movs	r4, r0
    1024:	000d      	movs	r5, r1
	ASSERT(descr && hw);
    1026:	2800      	cmp	r0, #0
    1028:	d010      	beq.n	104c <adc_dma_init+0x2c>
    102a:	2900      	cmp	r1, #0
    102c:	d00c      	beq.n	1048 <adc_dma_init+0x28>
    102e:	2001      	movs	r0, #1
    1030:	223d      	movs	r2, #61	; 0x3d
    1032:	4912      	ldr	r1, [pc, #72]	; (107c <adc_dma_init+0x5c>)
    1034:	4b12      	ldr	r3, [pc, #72]	; (1080 <adc_dma_init+0x60>)
    1036:	4798      	blx	r3
	init_status = _adc_dma_init(device, hw);
    1038:	0029      	movs	r1, r5
    103a:	0020      	movs	r0, r4
    103c:	4b11      	ldr	r3, [pc, #68]	; (1084 <adc_dma_init+0x64>)
    103e:	4798      	blx	r3
    1040:	1e05      	subs	r5, r0, #0
	if (init_status) {
    1042:	d005      	beq.n	1050 <adc_dma_init+0x30>
}
    1044:	0028      	movs	r0, r5
    1046:	bd70      	pop	{r4, r5, r6, pc}
	ASSERT(descr && hw);
    1048:	2000      	movs	r0, #0
    104a:	e7f1      	b.n	1030 <adc_dma_init+0x10>
    104c:	2000      	movs	r0, #0
    104e:	e7ef      	b.n	1030 <adc_dma_init+0x10>
	_dma_set_source_address(CONF_DMA_ADC_CHANNEL, (void *)_adc_get_source_for_dma(device));
    1050:	0020      	movs	r0, r4
    1052:	4b0d      	ldr	r3, [pc, #52]	; (1088 <adc_dma_init+0x68>)
    1054:	4798      	blx	r3
    1056:	0001      	movs	r1, r0
    1058:	2000      	movs	r0, #0
    105a:	4b0c      	ldr	r3, [pc, #48]	; (108c <adc_dma_init+0x6c>)
    105c:	4798      	blx	r3
	_dma_get_channel_resource(&descr->resource, CONF_DMA_ADC_CHANNEL);
    105e:	0020      	movs	r0, r4
    1060:	301c      	adds	r0, #28
    1062:	2100      	movs	r1, #0
    1064:	4b0a      	ldr	r3, [pc, #40]	; (1090 <adc_dma_init+0x70>)
    1066:	4798      	blx	r3
	descr->resource->back                 = descr;
    1068:	69e3      	ldr	r3, [r4, #28]
    106a:	609c      	str	r4, [r3, #8]
	descr->resource->dma_cb.transfer_done = adc_dma_complete;
    106c:	69e3      	ldr	r3, [r4, #28]
    106e:	4a09      	ldr	r2, [pc, #36]	; (1094 <adc_dma_init+0x74>)
    1070:	601a      	str	r2, [r3, #0]
	descr->resource->dma_cb.error         = adc_dma_error_occured;
    1072:	69e3      	ldr	r3, [r4, #28]
    1074:	4a08      	ldr	r2, [pc, #32]	; (1098 <adc_dma_init+0x78>)
    1076:	605a      	str	r2, [r3, #4]
	return ERR_NONE;
    1078:	e7e4      	b.n	1044 <adc_dma_init+0x24>
    107a:	46c0      	nop			; (mov r8, r8)
    107c:	00002680 	.word	0x00002680
    1080:	0000138d 	.word	0x0000138d
    1084:	00001541 	.word	0x00001541
    1088:	00001579 	.word	0x00001579
    108c:	0000162d 	.word	0x0000162d
    1090:	0000163d 	.word	0x0000163d
    1094:	00001005 	.word	0x00001005
    1098:	00001013 	.word	0x00001013

0000109c <delay_ms>:

/**
 * \brief Perform delay in ms
 */
void delay_ms(const uint16_t ms)
{
    109c:	b510      	push	{r4, lr}
	_delay_cycles(hardware, _get_cycles_for_ms(ms));
    109e:	4b04      	ldr	r3, [pc, #16]	; (10b0 <delay_ms+0x14>)
    10a0:	681c      	ldr	r4, [r3, #0]
    10a2:	4b04      	ldr	r3, [pc, #16]	; (10b4 <delay_ms+0x18>)
    10a4:	4798      	blx	r3
    10a6:	0001      	movs	r1, r0
    10a8:	0020      	movs	r0, r4
    10aa:	4b03      	ldr	r3, [pc, #12]	; (10b8 <delay_ms+0x1c>)
    10ac:	4798      	blx	r3
}
    10ae:	bd10      	pop	{r4, pc}
    10b0:	2000001c 	.word	0x2000001c
    10b4:	00001581 	.word	0x00001581
    10b8:	000015a1 	.word	0x000015a1

000010bc <process_ext_irq>:
 * \brief Interrupt processing routine
 *
 * \param[in] pin The pin which triggered the interrupt
 */
static void process_ext_irq(const uint32_t pin)
{
    10bc:	b570      	push	{r4, r5, r6, lr}
	uint8_t lower = 0, middle, upper = EXT_IRQ_AMOUNT;
    10be:	250b      	movs	r5, #11
    10c0:	2400      	movs	r4, #0

	while (upper >= lower) {
    10c2:	e007      	b.n	10d4 <process_ext_irq+0x18>
		if (middle >= EXT_IRQ_AMOUNT) {
			return;
		}

		if (ext_irqs[middle].pin == pin) {
			if (ext_irqs[middle].cb) {
    10c4:	4a0d      	ldr	r2, [pc, #52]	; (10fc <process_ext_irq+0x40>)
    10c6:	58b3      	ldr	r3, [r6, r2]
    10c8:	2b00      	cmp	r3, #0
    10ca:	d000      	beq.n	10ce <process_ext_irq+0x12>
				ext_irqs[middle].cb();
    10cc:	4798      	blx	r3
			lower = middle + 1;
		} else {
			upper = middle - 1;
		}
	}
}
    10ce:	bd70      	pop	{r4, r5, r6, pc}
			upper = middle - 1;
    10d0:	3a01      	subs	r2, #1
    10d2:	b2d5      	uxtb	r5, r2
	while (upper >= lower) {
    10d4:	42ac      	cmp	r4, r5
    10d6:	d8fa      	bhi.n	10ce <process_ext_irq+0x12>
		middle = (upper + lower) >> 1;
    10d8:	192b      	adds	r3, r5, r4
    10da:	105b      	asrs	r3, r3, #1
    10dc:	b2da      	uxtb	r2, r3
		if (middle >= EXT_IRQ_AMOUNT) {
    10de:	2a0a      	cmp	r2, #10
    10e0:	d8f5      	bhi.n	10ce <process_ext_irq+0x12>
    10e2:	21ff      	movs	r1, #255	; 0xff
    10e4:	400b      	ands	r3, r1
		if (ext_irqs[middle].pin == pin) {
    10e6:	00de      	lsls	r6, r3, #3
    10e8:	4904      	ldr	r1, [pc, #16]	; (10fc <process_ext_irq+0x40>)
    10ea:	1989      	adds	r1, r1, r6
    10ec:	6849      	ldr	r1, [r1, #4]
    10ee:	4281      	cmp	r1, r0
    10f0:	d0e8      	beq.n	10c4 <process_ext_irq+0x8>
		if (ext_irqs[middle].pin < pin) {
    10f2:	d2ed      	bcs.n	10d0 <process_ext_irq+0x14>
			lower = middle + 1;
    10f4:	3201      	adds	r2, #1
    10f6:	b2d4      	uxtb	r4, r2
    10f8:	e7ec      	b.n	10d4 <process_ext_irq+0x18>
    10fa:	46c0      	nop			; (mov r8, r8)
    10fc:	20000020 	.word	0x20000020

00001100 <ext_irq_init>:
{
    1100:	b510      	push	{r4, lr}
	for (i = 0; i < EXT_IRQ_AMOUNT; i++) {
    1102:	2300      	movs	r3, #0
    1104:	e009      	b.n	111a <ext_irq_init+0x1a>
		ext_irqs[i].pin = 0xFFFFFFFF;
    1106:	4a08      	ldr	r2, [pc, #32]	; (1128 <ext_irq_init+0x28>)
    1108:	00d9      	lsls	r1, r3, #3
    110a:	1850      	adds	r0, r2, r1
    110c:	2401      	movs	r4, #1
    110e:	4264      	negs	r4, r4
    1110:	6044      	str	r4, [r0, #4]
		ext_irqs[i].cb  = NULL;
    1112:	2000      	movs	r0, #0
    1114:	5088      	str	r0, [r1, r2]
	for (i = 0; i < EXT_IRQ_AMOUNT; i++) {
    1116:	3301      	adds	r3, #1
    1118:	b29b      	uxth	r3, r3
    111a:	2b0a      	cmp	r3, #10
    111c:	d9f3      	bls.n	1106 <ext_irq_init+0x6>
	return _ext_irq_init(process_ext_irq);
    111e:	4803      	ldr	r0, [pc, #12]	; (112c <ext_irq_init+0x2c>)
    1120:	4b03      	ldr	r3, [pc, #12]	; (1130 <ext_irq_init+0x30>)
    1122:	4798      	blx	r3
}
    1124:	bd10      	pop	{r4, pc}
    1126:	46c0      	nop			; (mov r8, r8)
    1128:	20000020 	.word	0x20000020
    112c:	000010bd 	.word	0x000010bd
    1130:	00001765 	.word	0x00001765

00001134 <i2c_m_sync_write>:

/**
 * \brief Sync version of I2C I/O write
 */
static int32_t i2c_m_sync_write(struct io_descriptor *io, const uint8_t *buf, const uint16_t n)
{
    1134:	b510      	push	{r4, lr}
    1136:	b084      	sub	sp, #16
	struct i2c_m_sync_desc *i2c = CONTAINER_OF(io, struct i2c_m_sync_desc, io);
	struct _i2c_m_msg       msg;
	int32_t                 ret;

	msg.addr   = i2c->slave_addr;
    1138:	3814      	subs	r0, #20
    113a:	8b84      	ldrh	r4, [r0, #28]
    113c:	ab01      	add	r3, sp, #4
    113e:	801c      	strh	r4, [r3, #0]
	msg.len    = n;
    1140:	0014      	movs	r4, r2
    1142:	9202      	str	r2, [sp, #8]
	msg.flags  = I2C_M_STOP;
    1144:	4a06      	ldr	r2, [pc, #24]	; (1160 <i2c_m_sync_write+0x2c>)
    1146:	805a      	strh	r2, [r3, #2]
	msg.buffer = (uint8_t *)buf;
    1148:	9103      	str	r1, [sp, #12]

	ret = _i2c_m_sync_transfer(&i2c->device, &msg);
    114a:	0019      	movs	r1, r3
    114c:	4b05      	ldr	r3, [pc, #20]	; (1164 <i2c_m_sync_write+0x30>)
    114e:	4798      	blx	r3

	if (ret) {
    1150:	2800      	cmp	r0, #0
    1152:	d102      	bne.n	115a <i2c_m_sync_write+0x26>
		return ret;
	}

	return n;
}
    1154:	0020      	movs	r0, r4
    1156:	b004      	add	sp, #16
    1158:	bd10      	pop	{r4, pc}
		return ret;
    115a:	0004      	movs	r4, r0
    115c:	e7fa      	b.n	1154 <i2c_m_sync_write+0x20>
    115e:	46c0      	nop			; (mov r8, r8)
    1160:	ffff8000 	.word	0xffff8000
    1164:	00001d29 	.word	0x00001d29

00001168 <i2c_m_sync_read>:
{
    1168:	b510      	push	{r4, lr}
    116a:	b084      	sub	sp, #16
	msg.addr   = i2c->slave_addr;
    116c:	3814      	subs	r0, #20
    116e:	8b84      	ldrh	r4, [r0, #28]
    1170:	ab01      	add	r3, sp, #4
    1172:	801c      	strh	r4, [r3, #0]
	msg.len    = n;
    1174:	0014      	movs	r4, r2
    1176:	9202      	str	r2, [sp, #8]
	msg.flags  = I2C_M_STOP | I2C_M_RD;
    1178:	4a06      	ldr	r2, [pc, #24]	; (1194 <i2c_m_sync_read+0x2c>)
    117a:	805a      	strh	r2, [r3, #2]
	msg.buffer = buf;
    117c:	9103      	str	r1, [sp, #12]
	ret = _i2c_m_sync_transfer(&i2c->device, &msg);
    117e:	0019      	movs	r1, r3
    1180:	4b05      	ldr	r3, [pc, #20]	; (1198 <i2c_m_sync_read+0x30>)
    1182:	4798      	blx	r3
	if (ret) {
    1184:	2800      	cmp	r0, #0
    1186:	d102      	bne.n	118e <i2c_m_sync_read+0x26>
}
    1188:	0020      	movs	r0, r4
    118a:	b004      	add	sp, #16
    118c:	bd10      	pop	{r4, pc}
		return ret;
    118e:	0004      	movs	r4, r0
    1190:	e7fa      	b.n	1188 <i2c_m_sync_read+0x20>
    1192:	46c0      	nop			; (mov r8, r8)
    1194:	ffff8001 	.word	0xffff8001
    1198:	00001d29 	.word	0x00001d29

0000119c <i2c_m_sync_init>:

/**
 * \brief Sync version of i2c initialize
 */
int32_t i2c_m_sync_init(struct i2c_m_sync_desc *i2c, void *hw)
{
    119c:	b570      	push	{r4, r5, r6, lr}
    119e:	0004      	movs	r4, r0
    11a0:	000d      	movs	r5, r1
	int32_t init_status;
	ASSERT(i2c);
    11a2:	1e43      	subs	r3, r0, #1
    11a4:	4198      	sbcs	r0, r3
    11a6:	b2c0      	uxtb	r0, r0
    11a8:	225e      	movs	r2, #94	; 0x5e
    11aa:	4907      	ldr	r1, [pc, #28]	; (11c8 <i2c_m_sync_init+0x2c>)
    11ac:	4b07      	ldr	r3, [pc, #28]	; (11cc <i2c_m_sync_init+0x30>)
    11ae:	4798      	blx	r3

	init_status = _i2c_m_sync_init(&i2c->device, hw);
    11b0:	0029      	movs	r1, r5
    11b2:	0020      	movs	r0, r4
    11b4:	4b06      	ldr	r3, [pc, #24]	; (11d0 <i2c_m_sync_init+0x34>)
    11b6:	4798      	blx	r3
	if (init_status) {
    11b8:	2800      	cmp	r0, #0
    11ba:	d103      	bne.n	11c4 <i2c_m_sync_init+0x28>
		return init_status;
	}

	/* Init I/O */
	i2c->io.read  = i2c_m_sync_read;
    11bc:	4b05      	ldr	r3, [pc, #20]	; (11d4 <i2c_m_sync_init+0x38>)
    11be:	61a3      	str	r3, [r4, #24]
	i2c->io.write = i2c_m_sync_write;
    11c0:	4b05      	ldr	r3, [pc, #20]	; (11d8 <i2c_m_sync_init+0x3c>)
    11c2:	6163      	str	r3, [r4, #20]

	return ERR_NONE;
}
    11c4:	bd70      	pop	{r4, r5, r6, pc}
    11c6:	46c0      	nop			; (mov r8, r8)
    11c8:	0000269c 	.word	0x0000269c
    11cc:	0000138d 	.word	0x0000138d
    11d0:	00001c79 	.word	0x00001c79
    11d4:	00001169 	.word	0x00001169
    11d8:	00001135 	.word	0x00001135

000011dc <i2c_m_sync_enable>:

/**
 * \brief Sync version of i2c enable
 */
int32_t i2c_m_sync_enable(struct i2c_m_sync_desc *i2c)
{
    11dc:	b510      	push	{r4, lr}
	return _i2c_m_sync_enable(&i2c->device);
    11de:	4b01      	ldr	r3, [pc, #4]	; (11e4 <i2c_m_sync_enable+0x8>)
    11e0:	4798      	blx	r3
}
    11e2:	bd10      	pop	{r4, pc}
    11e4:	00001ca9 	.word	0x00001ca9

000011e8 <i2c_m_sync_set_slaveaddr>:
/**
 * \brief Sync version of i2c set slave address
 */
int32_t i2c_m_sync_set_slaveaddr(struct i2c_m_sync_desc *i2c, int16_t addr, int32_t addr_len)
{
	return i2c->slave_addr = (addr & 0x3ff) | (addr_len & I2C_M_TEN);
    11e8:	0589      	lsls	r1, r1, #22
    11ea:	0d89      	lsrs	r1, r1, #22
    11ec:	2380      	movs	r3, #128	; 0x80
    11ee:	00db      	lsls	r3, r3, #3
    11f0:	401a      	ands	r2, r3
    11f2:	430a      	orrs	r2, r1
    11f4:	8382      	strh	r2, [r0, #28]
}
    11f6:	0010      	movs	r0, r2
    11f8:	4770      	bx	lr

000011fa <i2c_m_sync_get_io_descriptor>:
/**
 * \brief Retrieve I/O descriptor
 */
int32_t i2c_m_sync_get_io_descriptor(struct i2c_m_sync_desc *const i2c, struct io_descriptor **io)
{
	*io = &i2c->io;
    11fa:	3014      	adds	r0, #20
    11fc:	6008      	str	r0, [r1, #0]
	return ERR_NONE;
}
    11fe:	2000      	movs	r0, #0
    1200:	4770      	bx	lr
	...

00001204 <io_write>:

/**
 * \brief I/O write interface
 */
int32_t io_write(struct io_descriptor *const io_descr, const uint8_t *const buf, const uint16_t length)
{
    1204:	b570      	push	{r4, r5, r6, lr}
    1206:	0004      	movs	r4, r0
    1208:	000d      	movs	r5, r1
    120a:	0016      	movs	r6, r2
	ASSERT(io_descr && buf);
    120c:	2800      	cmp	r0, #0
    120e:	d00e      	beq.n	122e <io_write+0x2a>
    1210:	2900      	cmp	r1, #0
    1212:	d00a      	beq.n	122a <io_write+0x26>
    1214:	2001      	movs	r0, #1
    1216:	2234      	movs	r2, #52	; 0x34
    1218:	4906      	ldr	r1, [pc, #24]	; (1234 <io_write+0x30>)
    121a:	4b07      	ldr	r3, [pc, #28]	; (1238 <io_write+0x34>)
    121c:	4798      	blx	r3
	return io_descr->write(io_descr, buf, length);
    121e:	6823      	ldr	r3, [r4, #0]
    1220:	0032      	movs	r2, r6
    1222:	0029      	movs	r1, r5
    1224:	0020      	movs	r0, r4
    1226:	4798      	blx	r3
}
    1228:	bd70      	pop	{r4, r5, r6, pc}
	ASSERT(io_descr && buf);
    122a:	2000      	movs	r0, #0
    122c:	e7f3      	b.n	1216 <io_write+0x12>
    122e:	2000      	movs	r0, #0
    1230:	e7f1      	b.n	1216 <io_write+0x12>
    1232:	46c0      	nop			; (mov r8, r8)
    1234:	000026b8 	.word	0x000026b8
    1238:	0000138d 	.word	0x0000138d

0000123c <io_read>:

/**
 * \brief I/O read interface
 */
int32_t io_read(struct io_descriptor *const io_descr, uint8_t *const buf, const uint16_t length)
{
    123c:	b570      	push	{r4, r5, r6, lr}
    123e:	0004      	movs	r4, r0
    1240:	000d      	movs	r5, r1
    1242:	0016      	movs	r6, r2
	ASSERT(io_descr && buf);
    1244:	2800      	cmp	r0, #0
    1246:	d00e      	beq.n	1266 <io_read+0x2a>
    1248:	2900      	cmp	r1, #0
    124a:	d00a      	beq.n	1262 <io_read+0x26>
    124c:	2001      	movs	r0, #1
    124e:	223d      	movs	r2, #61	; 0x3d
    1250:	4906      	ldr	r1, [pc, #24]	; (126c <io_read+0x30>)
    1252:	4b07      	ldr	r3, [pc, #28]	; (1270 <io_read+0x34>)
    1254:	4798      	blx	r3
	return io_descr->read(io_descr, buf, length);
    1256:	6863      	ldr	r3, [r4, #4]
    1258:	0032      	movs	r2, r6
    125a:	0029      	movs	r1, r5
    125c:	0020      	movs	r0, r4
    125e:	4798      	blx	r3
}
    1260:	bd70      	pop	{r4, r5, r6, pc}
	ASSERT(io_descr && buf);
    1262:	2000      	movs	r0, #0
    1264:	e7f3      	b.n	124e <io_read+0x12>
    1266:	2000      	movs	r0, #0
    1268:	e7f1      	b.n	124e <io_read+0x12>
    126a:	46c0      	nop			; (mov r8, r8)
    126c:	000026b8 	.word	0x000026b8
    1270:	0000138d 	.word	0x0000138d

00001274 <spi_m_sync_init>:
	ASSERT(spi);
	spi->func = (struct _spi_m_sync_hpl_interface *)func;
}

int32_t spi_m_sync_init(struct spi_m_sync_descriptor *spi, void *const hw)
{
    1274:	b570      	push	{r4, r5, r6, lr}
    1276:	0004      	movs	r4, r0
    1278:	000d      	movs	r5, r1
	int32_t rc = 0;
	ASSERT(spi && hw);
    127a:	2800      	cmp	r0, #0
    127c:	d017      	beq.n	12ae <spi_m_sync_init+0x3a>
    127e:	2900      	cmp	r1, #0
    1280:	d013      	beq.n	12aa <spi_m_sync_init+0x36>
    1282:	2001      	movs	r0, #1
    1284:	2240      	movs	r2, #64	; 0x40
    1286:	490b      	ldr	r1, [pc, #44]	; (12b4 <spi_m_sync_init+0x40>)
    1288:	4b0b      	ldr	r3, [pc, #44]	; (12b8 <spi_m_sync_init+0x44>)
    128a:	4798      	blx	r3
	spi->dev.prvt = (void *)hw;
    128c:	6065      	str	r5, [r4, #4]
	rc            = _spi_m_sync_init(&spi->dev, hw);
    128e:	1d20      	adds	r0, r4, #4
    1290:	0029      	movs	r1, r5
    1292:	4b0a      	ldr	r3, [pc, #40]	; (12bc <spi_m_sync_init+0x48>)
    1294:	4798      	blx	r3

	if (rc < 0) {
    1296:	2800      	cmp	r0, #0
    1298:	db06      	blt.n	12a8 <spi_m_sync_init+0x34>
		return rc;
	}

	spi->flags    = SPI_DEACTIVATE_NEXT;
    129a:	4b09      	ldr	r3, [pc, #36]	; (12c0 <spi_m_sync_init+0x4c>)
    129c:	82a3      	strh	r3, [r4, #20]
	spi->io.read  = _spi_m_sync_io_read;
    129e:	4b09      	ldr	r3, [pc, #36]	; (12c4 <spi_m_sync_init+0x50>)
    12a0:	6123      	str	r3, [r4, #16]
	spi->io.write = _spi_m_sync_io_write;
    12a2:	4b09      	ldr	r3, [pc, #36]	; (12c8 <spi_m_sync_init+0x54>)
    12a4:	60e3      	str	r3, [r4, #12]

	return ERR_NONE;
    12a6:	2000      	movs	r0, #0
}
    12a8:	bd70      	pop	{r4, r5, r6, pc}
	ASSERT(spi && hw);
    12aa:	2000      	movs	r0, #0
    12ac:	e7ea      	b.n	1284 <spi_m_sync_init+0x10>
    12ae:	2000      	movs	r0, #0
    12b0:	e7e8      	b.n	1284 <spi_m_sync_init+0x10>
    12b2:	46c0      	nop			; (mov r8, r8)
    12b4:	000026cc 	.word	0x000026cc
    12b8:	0000138d 	.word	0x0000138d
    12bc:	00001fa5 	.word	0x00001fa5
    12c0:	ffff8000 	.word	0xffff8000
    12c4:	00001351 	.word	0x00001351
    12c8:	00001315 	.word	0x00001315

000012cc <spi_m_sync_transfer>:

	return spi_m_sync_transfer(spi, &xfer);
}

int32_t spi_m_sync_transfer(struct spi_m_sync_descriptor *spi, const struct spi_xfer *p_xfer)
{
    12cc:	b530      	push	{r4, r5, lr}
    12ce:	b087      	sub	sp, #28
    12d0:	0004      	movs	r4, r0
    12d2:	000d      	movs	r5, r1
	struct spi_msg msg;

	ASSERT(spi && p_xfer);
    12d4:	2800      	cmp	r0, #0
    12d6:	d015      	beq.n	1304 <spi_m_sync_transfer+0x38>
    12d8:	2900      	cmp	r1, #0
    12da:	d011      	beq.n	1300 <spi_m_sync_transfer+0x34>
    12dc:	2001      	movs	r0, #1
    12de:	22b3      	movs	r2, #179	; 0xb3
    12e0:	4909      	ldr	r1, [pc, #36]	; (1308 <spi_m_sync_transfer+0x3c>)
    12e2:	4b0a      	ldr	r3, [pc, #40]	; (130c <spi_m_sync_transfer+0x40>)
    12e4:	4798      	blx	r3

	msg.txbuf = p_xfer->txbuf;
    12e6:	682b      	ldr	r3, [r5, #0]
    12e8:	9303      	str	r3, [sp, #12]
	msg.rxbuf = p_xfer->rxbuf;
    12ea:	686b      	ldr	r3, [r5, #4]
    12ec:	9304      	str	r3, [sp, #16]
	msg.size  = p_xfer->size;
    12ee:	68ab      	ldr	r3, [r5, #8]
    12f0:	9301      	str	r3, [sp, #4]
    12f2:	9305      	str	r3, [sp, #20]
	return _spi_m_sync_trans(&spi->dev, &msg);
    12f4:	1d20      	adds	r0, r4, #4
    12f6:	a903      	add	r1, sp, #12
    12f8:	4b05      	ldr	r3, [pc, #20]	; (1310 <spi_m_sync_transfer+0x44>)
    12fa:	4798      	blx	r3
}
    12fc:	b007      	add	sp, #28
    12fe:	bd30      	pop	{r4, r5, pc}
	ASSERT(spi && p_xfer);
    1300:	2000      	movs	r0, #0
    1302:	e7ec      	b.n	12de <spi_m_sync_transfer+0x12>
    1304:	2000      	movs	r0, #0
    1306:	e7ea      	b.n	12de <spi_m_sync_transfer+0x12>
    1308:	000026cc 	.word	0x000026cc
    130c:	0000138d 	.word	0x0000138d
    1310:	000021a1 	.word	0x000021a1

00001314 <_spi_m_sync_io_write>:
{
    1314:	b570      	push	{r4, r5, r6, lr}
    1316:	b084      	sub	sp, #16
    1318:	0004      	movs	r4, r0
    131a:	000e      	movs	r6, r1
    131c:	0015      	movs	r5, r2
	ASSERT(io);
    131e:	1e43      	subs	r3, r0, #1
    1320:	4198      	sbcs	r0, r3
    1322:	b2c0      	uxtb	r0, r0
    1324:	22a3      	movs	r2, #163	; 0xa3
    1326:	4907      	ldr	r1, [pc, #28]	; (1344 <_spi_m_sync_io_write+0x30>)
    1328:	4b07      	ldr	r3, [pc, #28]	; (1348 <_spi_m_sync_io_write+0x34>)
    132a:	4798      	blx	r3
	struct spi_m_sync_descriptor *spi = CONTAINER_OF(io, struct spi_m_sync_descriptor, io);
    132c:	0020      	movs	r0, r4
    132e:	380c      	subs	r0, #12
	xfer.rxbuf = 0;
    1330:	2300      	movs	r3, #0
    1332:	9302      	str	r3, [sp, #8]
	xfer.txbuf = (uint8_t *)buf;
    1334:	9601      	str	r6, [sp, #4]
	xfer.size  = length;
    1336:	9503      	str	r5, [sp, #12]
	return spi_m_sync_transfer(spi, &xfer);
    1338:	a901      	add	r1, sp, #4
    133a:	4b04      	ldr	r3, [pc, #16]	; (134c <_spi_m_sync_io_write+0x38>)
    133c:	4798      	blx	r3
}
    133e:	b004      	add	sp, #16
    1340:	bd70      	pop	{r4, r5, r6, pc}
    1342:	46c0      	nop			; (mov r8, r8)
    1344:	000026cc 	.word	0x000026cc
    1348:	0000138d 	.word	0x0000138d
    134c:	000012cd 	.word	0x000012cd

00001350 <_spi_m_sync_io_read>:
{
    1350:	b570      	push	{r4, r5, r6, lr}
    1352:	b084      	sub	sp, #16
    1354:	0004      	movs	r4, r0
    1356:	000e      	movs	r6, r1
    1358:	0015      	movs	r5, r2
	ASSERT(io);
    135a:	1e43      	subs	r3, r0, #1
    135c:	4198      	sbcs	r0, r3
    135e:	b2c0      	uxtb	r0, r0
    1360:	2287      	movs	r2, #135	; 0x87
    1362:	4907      	ldr	r1, [pc, #28]	; (1380 <_spi_m_sync_io_read+0x30>)
    1364:	4b07      	ldr	r3, [pc, #28]	; (1384 <_spi_m_sync_io_read+0x34>)
    1366:	4798      	blx	r3
	struct spi_m_sync_descriptor *spi = CONTAINER_OF(io, struct spi_m_sync_descriptor, io);
    1368:	0020      	movs	r0, r4
    136a:	380c      	subs	r0, #12
	xfer.rxbuf = buf;
    136c:	9602      	str	r6, [sp, #8]
	xfer.txbuf = 0;
    136e:	2300      	movs	r3, #0
    1370:	9301      	str	r3, [sp, #4]
	xfer.size  = length;
    1372:	9503      	str	r5, [sp, #12]
	return spi_m_sync_transfer(spi, &xfer);
    1374:	a901      	add	r1, sp, #4
    1376:	4b04      	ldr	r3, [pc, #16]	; (1388 <_spi_m_sync_io_read+0x38>)
    1378:	4798      	blx	r3
}
    137a:	b004      	add	sp, #16
    137c:	bd70      	pop	{r4, r5, r6, pc}
    137e:	46c0      	nop			; (mov r8, r8)
    1380:	000026cc 	.word	0x000026cc
    1384:	0000138d 	.word	0x0000138d
    1388:	000012cd 	.word	0x000012cd

0000138c <assert>:
/**
 * \brief Assert function
 */
void assert(const bool condition, const char *const file, const int line)
{
	if (!(condition)) {
    138c:	2800      	cmp	r0, #0
    138e:	d100      	bne.n	1392 <assert+0x6>
		__asm("BKPT #0");
    1390:	be00      	bkpt	0x0000
	}
	(void)file;
	(void)line;
}
    1392:	4770      	bx	lr

00001394 <_adc_get_hardware_index>:
/**
 * \brief Retrieve ordinal number of the given adc hardware instance
 */
static uint8_t _adc_get_hardware_index(const void *const hw)
{
	return ((uint32_t)hw - (uint32_t)ADC0) >> 10;
    1394:	4b02      	ldr	r3, [pc, #8]	; (13a0 <_adc_get_hardware_index+0xc>)
    1396:	469c      	mov	ip, r3
    1398:	4460      	add	r0, ip
    139a:	0a80      	lsrs	r0, r0, #10
    139c:	b2c0      	uxtb	r0, r0
}
    139e:	4770      	bx	lr
    13a0:	bdffbc00 	.word	0xbdffbc00

000013a4 <_adc_init>:
 *
 * \param[in] hw The pointer to hardware instance
 * \param[in] i The number of hardware instance
 */
static int32_t _adc_init(void *const hw, const uint8_t i)
{
    13a4:	b530      	push	{r4, r5, lr}
	uint16_t calib_reg = 0;
	if (hw == ADC0) {
    13a6:	4b52      	ldr	r3, [pc, #328]	; (14f0 <_adc_init+0x14c>)
    13a8:	4298      	cmp	r0, r3
    13aa:	d100      	bne.n	13ae <_adc_init+0xa>
    13ac:	e089      	b.n	14c2 <_adc_init+0x11e>
		calib_reg = ADC_CALIB_BIASREFBUF((*(uint32_t *)ADC0_FUSES_BIASREFBUF_ADDR >> ADC0_FUSES_BIASREFBUF_Pos))
		            | ADC_CALIB_BIASCOMP((*(uint32_t *)ADC0_FUSES_BIASCOMP_ADDR >> ADC0_FUSES_BIASCOMP_Pos));
	} else if (hw == ADC1) {
    13ae:	4b51      	ldr	r3, [pc, #324]	; (14f4 <_adc_init+0x150>)
    13b0:	4298      	cmp	r0, r3
    13b2:	d100      	bne.n	13b6 <_adc_init+0x12>
    13b4:	e090      	b.n	14d8 <_adc_init+0x134>
	uint16_t calib_reg = 0;
    13b6:	2200      	movs	r2, #0
	};
}

static inline bool hri_adc_is_syncing(const void *const hw, hri_adc_syncbusy_reg_t reg)
{
	return ((Adc *)hw)->SYNCBUSY.reg & reg;
    13b8:	8c03      	ldrh	r3, [r0, #32]
		calib_reg = ADC_CALIB_BIASREFBUF((*(uint32_t *)ADC1_FUSES_BIASREFBUF_ADDR >> ADC1_FUSES_BIASREFBUF_Pos))
		            | ADC_CALIB_BIASCOMP((*(uint32_t *)ADC1_FUSES_BIASCOMP_ADDR >> ADC1_FUSES_BIASCOMP_Pos));
	}

	if (!hri_adc_is_syncing(hw, ADC_SYNCBUSY_SWRST)) {
    13ba:	07db      	lsls	r3, r3, #31
    13bc:	d414      	bmi.n	13e8 <_adc_init+0x44>
	while (((Adc *)hw)->SYNCBUSY.reg & reg) {
    13be:	8c03      	ldrh	r3, [r0, #32]
    13c0:	079b      	lsls	r3, r3, #30
    13c2:	d1fc      	bne.n	13be <_adc_init+0x1a>

static inline hri_adc_ctrla_reg_t hri_adc_get_CTRLA_reg(const void *const hw, hri_adc_ctrla_reg_t mask)
{
	uint8_t tmp;
	hri_adc_wait_for_sync(hw, ADC_SYNCBUSY_SWRST | ADC_SYNCBUSY_ENABLE);
	tmp = ((Adc *)hw)->CTRLA.reg;
    13c4:	7803      	ldrb	r3, [r0, #0]
		if (hri_adc_get_CTRLA_reg(hw, ADC_CTRLA_ENABLE)) {
    13c6:	079b      	lsls	r3, r3, #30
    13c8:	d509      	bpl.n	13de <_adc_init+0x3a>
	((Adc *)hw)->CTRLA.reg &= ~ADC_CTRLA_ENABLE;
    13ca:	7803      	ldrb	r3, [r0, #0]
    13cc:	2402      	movs	r4, #2
    13ce:	43a3      	bics	r3, r4
    13d0:	7003      	strb	r3, [r0, #0]
	while (((Adc *)hw)->SYNCBUSY.reg & reg) {
    13d2:	8c03      	ldrh	r3, [r0, #32]
    13d4:	079b      	lsls	r3, r3, #30
    13d6:	d1fc      	bne.n	13d2 <_adc_init+0x2e>
    13d8:	8c03      	ldrh	r3, [r0, #32]
    13da:	079b      	lsls	r3, r3, #30
    13dc:	d4fc      	bmi.n	13d8 <_adc_init+0x34>
}

static inline void hri_adc_write_CTRLA_reg(const void *const hw, hri_adc_ctrla_reg_t data)
{
	ADC_CRITICAL_SECTION_ENTER();
	((Adc *)hw)->CTRLA.reg = data;
    13de:	2301      	movs	r3, #1
    13e0:	7003      	strb	r3, [r0, #0]
	while (((Adc *)hw)->SYNCBUSY.reg & reg) {
    13e2:	8c03      	ldrh	r3, [r0, #32]
    13e4:	079b      	lsls	r3, r3, #30
    13e6:	d1fc      	bne.n	13e2 <_adc_init+0x3e>
    13e8:	8c03      	ldrh	r3, [r0, #32]
    13ea:	07db      	lsls	r3, r3, #31
    13ec:	d4fc      	bmi.n	13e8 <_adc_init+0x44>
}

static inline void hri_adc_write_CALIB_reg(const void *const hw, hri_adc_calib_reg_t data)
{
	ADC_CRITICAL_SECTION_ENTER();
	((Adc *)hw)->CALIB.reg = data;
    13ee:	8582      	strh	r2, [r0, #44]	; 0x2c
		hri_adc_write_CTRLA_reg(hw, ADC_CTRLA_SWRST);
	}
	hri_adc_wait_for_sync(hw, ADC_SYNCBUSY_SWRST);

	hri_adc_write_CALIB_reg(hw, calib_reg);
	hri_adc_write_CTRLB_reg(hw, _adcs[i].ctrl_b);
    13f0:	00ca      	lsls	r2, r1, #3
    13f2:	1a52      	subs	r2, r2, r1
    13f4:	0094      	lsls	r4, r2, #2
    13f6:	4b40      	ldr	r3, [pc, #256]	; (14f8 <_adc_init+0x154>)
    13f8:	191b      	adds	r3, r3, r4
    13fa:	789a      	ldrb	r2, [r3, #2]
	((Adc *)hw)->CTRLB.reg = data;
    13fc:	7042      	strb	r2, [r0, #1]
	hri_adc_write_REFCTRL_reg(hw, _adcs[i].ref_ctrl);
    13fe:	78da      	ldrb	r2, [r3, #3]
	((Adc *)hw)->REFCTRL.reg = data;
    1400:	7082      	strb	r2, [r0, #2]
	hri_adc_write_EVCTRL_reg(hw, _adcs[i].ev_ctrl);
    1402:	791a      	ldrb	r2, [r3, #4]
	((Adc *)hw)->EVCTRL.reg = data;
    1404:	70c2      	strb	r2, [r0, #3]
	hri_adc_write_INPUTCTRL_reg(hw, _adcs[i].input_ctrl);
    1406:	88db      	ldrh	r3, [r3, #6]
	((Adc *)hw)->INPUTCTRL.reg = data;
    1408:	8103      	strh	r3, [r0, #8]
	while (((Adc *)hw)->SYNCBUSY.reg & reg) {
    140a:	8c03      	ldrh	r3, [r0, #32]
    140c:	055b      	lsls	r3, r3, #21
    140e:	d1fc      	bne.n	140a <_adc_init+0x66>
	hri_adc_write_CTRLC_reg(hw, _adcs[i].ctrl_c);
    1410:	00cb      	lsls	r3, r1, #3
    1412:	1a5b      	subs	r3, r3, r1
    1414:	009a      	lsls	r2, r3, #2
    1416:	4b38      	ldr	r3, [pc, #224]	; (14f8 <_adc_init+0x154>)
    1418:	189b      	adds	r3, r3, r2
    141a:	891b      	ldrh	r3, [r3, #8]
	((Adc *)hw)->CTRLC.reg = data;
    141c:	8143      	strh	r3, [r0, #10]
	while (((Adc *)hw)->SYNCBUSY.reg & reg) {
    141e:	8c03      	ldrh	r3, [r0, #32]
    1420:	055b      	lsls	r3, r3, #21
    1422:	d1fc      	bne.n	141e <_adc_init+0x7a>
	hri_adc_write_AVGCTRL_reg(hw, _adcs[i].avg_ctrl);
    1424:	00cb      	lsls	r3, r1, #3
    1426:	1a5b      	subs	r3, r3, r1
    1428:	009a      	lsls	r2, r3, #2
    142a:	4b33      	ldr	r3, [pc, #204]	; (14f8 <_adc_init+0x154>)
    142c:	189b      	adds	r3, r3, r2
    142e:	7a9b      	ldrb	r3, [r3, #10]
	((Adc *)hw)->AVGCTRL.reg = data;
    1430:	7303      	strb	r3, [r0, #12]
	while (((Adc *)hw)->SYNCBUSY.reg & reg) {
    1432:	8c03      	ldrh	r3, [r0, #32]
    1434:	055b      	lsls	r3, r3, #21
    1436:	d1fc      	bne.n	1432 <_adc_init+0x8e>
	hri_adc_write_SAMPCTRL_reg(hw, _adcs[i].samp_ctrl);
    1438:	00cb      	lsls	r3, r1, #3
    143a:	1a5b      	subs	r3, r3, r1
    143c:	009a      	lsls	r2, r3, #2
    143e:	4b2e      	ldr	r3, [pc, #184]	; (14f8 <_adc_init+0x154>)
    1440:	189b      	adds	r3, r3, r2
    1442:	7adb      	ldrb	r3, [r3, #11]
	((Adc *)hw)->SAMPCTRL.reg = data;
    1444:	7343      	strb	r3, [r0, #13]
	while (((Adc *)hw)->SYNCBUSY.reg & reg) {
    1446:	8c03      	ldrh	r3, [r0, #32]
    1448:	055b      	lsls	r3, r3, #21
    144a:	d1fc      	bne.n	1446 <_adc_init+0xa2>
	hri_adc_write_WINLT_reg(hw, _adcs[i].win_lt);
    144c:	00cb      	lsls	r3, r1, #3
    144e:	1a5b      	subs	r3, r3, r1
    1450:	009a      	lsls	r2, r3, #2
    1452:	4b29      	ldr	r3, [pc, #164]	; (14f8 <_adc_init+0x154>)
    1454:	189b      	adds	r3, r3, r2
    1456:	899b      	ldrh	r3, [r3, #12]
	((Adc *)hw)->WINLT.reg = data;
    1458:	81c3      	strh	r3, [r0, #14]
	while (((Adc *)hw)->SYNCBUSY.reg & reg) {
    145a:	8c03      	ldrh	r3, [r0, #32]
    145c:	065b      	lsls	r3, r3, #25
    145e:	d4fc      	bmi.n	145a <_adc_init+0xb6>
	hri_adc_write_WINUT_reg(hw, _adcs[i].win_ut);
    1460:	00cb      	lsls	r3, r1, #3
    1462:	1a5b      	subs	r3, r3, r1
    1464:	009a      	lsls	r2, r3, #2
    1466:	4b24      	ldr	r3, [pc, #144]	; (14f8 <_adc_init+0x154>)
    1468:	189b      	adds	r3, r3, r2
    146a:	89db      	ldrh	r3, [r3, #14]
	((Adc *)hw)->WINUT.reg = data;
    146c:	8203      	strh	r3, [r0, #16]
	while (((Adc *)hw)->SYNCBUSY.reg & reg) {
    146e:	8c03      	ldrh	r3, [r0, #32]
    1470:	061b      	lsls	r3, r3, #24
    1472:	d4fc      	bmi.n	146e <_adc_init+0xca>
	hri_adc_write_GAINCORR_reg(hw, _adcs[i].gain_corr);
    1474:	00cb      	lsls	r3, r1, #3
    1476:	1a5b      	subs	r3, r3, r1
    1478:	009a      	lsls	r2, r3, #2
    147a:	4b1f      	ldr	r3, [pc, #124]	; (14f8 <_adc_init+0x154>)
    147c:	189b      	adds	r3, r3, r2
    147e:	8a1b      	ldrh	r3, [r3, #16]
	((Adc *)hw)->GAINCORR.reg = data;
    1480:	8243      	strh	r3, [r0, #18]
	while (((Adc *)hw)->SYNCBUSY.reg & reg) {
    1482:	8c03      	ldrh	r3, [r0, #32]
    1484:	05db      	lsls	r3, r3, #23
    1486:	d4fc      	bmi.n	1482 <_adc_init+0xde>
	hri_adc_write_OFFSETCORR_reg(hw, _adcs[i].offset_corr);
    1488:	00cb      	lsls	r3, r1, #3
    148a:	1a5b      	subs	r3, r3, r1
    148c:	009a      	lsls	r2, r3, #2
    148e:	4b1a      	ldr	r3, [pc, #104]	; (14f8 <_adc_init+0x154>)
    1490:	189b      	adds	r3, r3, r2
    1492:	8a5b      	ldrh	r3, [r3, #18]
	((Adc *)hw)->OFFSETCORR.reg = data;
    1494:	8283      	strh	r3, [r0, #20]
	while (((Adc *)hw)->SYNCBUSY.reg & reg) {
    1496:	8c03      	ldrh	r3, [r0, #32]
    1498:	059b      	lsls	r3, r3, #22
    149a:	d4fc      	bmi.n	1496 <_adc_init+0xf2>
	hri_adc_write_DBGCTRL_reg(hw, _adcs[i].dbg_ctrl);
    149c:	4c16      	ldr	r4, [pc, #88]	; (14f8 <_adc_init+0x154>)
    149e:	00cb      	lsls	r3, r1, #3
    14a0:	1a5d      	subs	r5, r3, r1
    14a2:	00aa      	lsls	r2, r5, #2
    14a4:	18a2      	adds	r2, r4, r2
    14a6:	7d15      	ldrb	r5, [r2, #20]
	((Adc *)hw)->DBGCTRL.reg = data;
    14a8:	7705      	strb	r5, [r0, #28]
	hri_adc_write_SEQCTRL_reg(hw, _adcs[i].seq_ctrl);
    14aa:	6992      	ldr	r2, [r2, #24]
	((Adc *)hw)->SEQCTRL.reg = data;
    14ac:	6282      	str	r2, [r0, #40]	; 0x28
	hri_adc_write_CTRLA_reg(hw, _adcs[i].ctrl_a);
    14ae:	1a59      	subs	r1, r3, r1
    14b0:	008b      	lsls	r3, r1, #2
    14b2:	18e4      	adds	r4, r4, r3
    14b4:	7863      	ldrb	r3, [r4, #1]
	((Adc *)hw)->CTRLA.reg = data;
    14b6:	7003      	strb	r3, [r0, #0]
	while (((Adc *)hw)->SYNCBUSY.reg & reg) {
    14b8:	8c03      	ldrh	r3, [r0, #32]
    14ba:	079b      	lsls	r3, r3, #30
    14bc:	d1fc      	bne.n	14b8 <_adc_init+0x114>

	return ERR_NONE;
}
    14be:	2000      	movs	r0, #0
    14c0:	bd30      	pop	{r4, r5, pc}
		calib_reg = ADC_CALIB_BIASREFBUF((*(uint32_t *)ADC0_FUSES_BIASREFBUF_ADDR >> ADC0_FUSES_BIASREFBUF_Pos))
    14c2:	4b0e      	ldr	r3, [pc, #56]	; (14fc <_adc_init+0x158>)
    14c4:	681b      	ldr	r3, [r3, #0]
    14c6:	021a      	lsls	r2, r3, #8
    14c8:	24e0      	movs	r4, #224	; 0xe0
    14ca:	00e4      	lsls	r4, r4, #3
    14cc:	4014      	ands	r4, r2
		            | ADC_CALIB_BIASCOMP((*(uint32_t *)ADC0_FUSES_BIASCOMP_ADDR >> ADC0_FUSES_BIASCOMP_Pos));
    14ce:	08db      	lsrs	r3, r3, #3
    14d0:	2207      	movs	r2, #7
    14d2:	401a      	ands	r2, r3
		calib_reg = ADC_CALIB_BIASREFBUF((*(uint32_t *)ADC0_FUSES_BIASREFBUF_ADDR >> ADC0_FUSES_BIASREFBUF_Pos))
    14d4:	4322      	orrs	r2, r4
    14d6:	e76f      	b.n	13b8 <_adc_init+0x14>
		calib_reg = ADC_CALIB_BIASREFBUF((*(uint32_t *)ADC1_FUSES_BIASREFBUF_ADDR >> ADC1_FUSES_BIASREFBUF_Pos))
    14d8:	4b08      	ldr	r3, [pc, #32]	; (14fc <_adc_init+0x158>)
    14da:	681b      	ldr	r3, [r3, #0]
    14dc:	099a      	lsrs	r2, r3, #6
    14de:	0212      	lsls	r2, r2, #8
    14e0:	24e0      	movs	r4, #224	; 0xe0
    14e2:	00e4      	lsls	r4, r4, #3
    14e4:	4022      	ands	r2, r4
		            | ADC_CALIB_BIASCOMP((*(uint32_t *)ADC1_FUSES_BIASCOMP_ADDR >> ADC1_FUSES_BIASCOMP_Pos));
    14e6:	0a5b      	lsrs	r3, r3, #9
    14e8:	2407      	movs	r4, #7
    14ea:	4023      	ands	r3, r4
		calib_reg = ADC_CALIB_BIASREFBUF((*(uint32_t *)ADC1_FUSES_BIASREFBUF_ADDR >> ADC1_FUSES_BIASREFBUF_Pos))
    14ec:	431a      	orrs	r2, r3
    14ee:	e763      	b.n	13b8 <_adc_init+0x14>
    14f0:	42004400 	.word	0x42004400
    14f4:	42004800 	.word	0x42004800
    14f8:	000026e8 	.word	0x000026e8
    14fc:	00806020 	.word	0x00806020

00001500 <_adc_get_regs>:
{
    1500:	b510      	push	{r4, lr}
	uint8_t n = _adc_get_hardware_index((const void *)hw_addr);
    1502:	4b0b      	ldr	r3, [pc, #44]	; (1530 <_adc_get_regs+0x30>)
    1504:	4798      	blx	r3
    1506:	0001      	movs	r1, r0
	for (i = 0; i < sizeof(_adcs) / sizeof(struct adc_configuration); i++) {
    1508:	2000      	movs	r0, #0
    150a:	2801      	cmp	r0, #1
    150c:	d809      	bhi.n	1522 <_adc_get_regs+0x22>
		if (_adcs[i].number == n) {
    150e:	00c3      	lsls	r3, r0, #3
    1510:	1a1b      	subs	r3, r3, r0
    1512:	009a      	lsls	r2, r3, #2
    1514:	4b07      	ldr	r3, [pc, #28]	; (1534 <_adc_get_regs+0x34>)
    1516:	5cd3      	ldrb	r3, [r2, r3]
    1518:	4299      	cmp	r1, r3
    151a:	d008      	beq.n	152e <_adc_get_regs+0x2e>
	for (i = 0; i < sizeof(_adcs) / sizeof(struct adc_configuration); i++) {
    151c:	3001      	adds	r0, #1
    151e:	b2c0      	uxtb	r0, r0
    1520:	e7f3      	b.n	150a <_adc_get_regs+0xa>
	ASSERT(false);
    1522:	228d      	movs	r2, #141	; 0x8d
    1524:	4904      	ldr	r1, [pc, #16]	; (1538 <_adc_get_regs+0x38>)
    1526:	2000      	movs	r0, #0
    1528:	4b04      	ldr	r3, [pc, #16]	; (153c <_adc_get_regs+0x3c>)
    152a:	4798      	blx	r3
	return 0;
    152c:	2000      	movs	r0, #0
}
    152e:	bd10      	pop	{r4, pc}
    1530:	00001395 	.word	0x00001395
    1534:	000026e8 	.word	0x000026e8
    1538:	00002720 	.word	0x00002720
    153c:	0000138d 	.word	0x0000138d

00001540 <_adc_dma_init>:

/**
 * \brief Initialize ADC
 */
int32_t _adc_dma_init(struct _adc_dma_device *const device, void *const hw)
{
    1540:	b570      	push	{r4, r5, r6, lr}
    1542:	0005      	movs	r5, r0
    1544:	000c      	movs	r4, r1
	ASSERT(device);
    1546:	1e43      	subs	r3, r0, #1
    1548:	4198      	sbcs	r0, r3
    154a:	b2c0      	uxtb	r0, r0
    154c:	22ff      	movs	r2, #255	; 0xff
    154e:	4906      	ldr	r1, [pc, #24]	; (1568 <_adc_dma_init+0x28>)
    1550:	4b06      	ldr	r3, [pc, #24]	; (156c <_adc_dma_init+0x2c>)
    1552:	4798      	blx	r3

	device->hw = hw;
    1554:	612c      	str	r4, [r5, #16]

	return _adc_init(hw, _adc_get_regs((uint32_t)hw));
    1556:	0020      	movs	r0, r4
    1558:	4b05      	ldr	r3, [pc, #20]	; (1570 <_adc_dma_init+0x30>)
    155a:	4798      	blx	r3
    155c:	0001      	movs	r1, r0
    155e:	0020      	movs	r0, r4
    1560:	4b04      	ldr	r3, [pc, #16]	; (1574 <_adc_dma_init+0x34>)
    1562:	4798      	blx	r3
}
    1564:	bd70      	pop	{r4, r5, r6, pc}
    1566:	46c0      	nop			; (mov r8, r8)
    1568:	00002720 	.word	0x00002720
    156c:	0000138d 	.word	0x0000138d
    1570:	00001501 	.word	0x00001501
    1574:	000013a5 	.word	0x000013a5

00001578 <_adc_get_source_for_dma>:
/**
 * \brief Return address of ADC DMA source
 */
uint32_t _adc_get_source_for_dma(struct _adc_dma_device *const device)
{
	return (uint32_t) & (((Adc *)(device->hw))->RESULT.reg);
    1578:	6900      	ldr	r0, [r0, #16]
    157a:	3024      	adds	r0, #36	; 0x24
}
    157c:	4770      	bx	lr
	...

00001580 <_get_cycles_for_ms>:

/**
 * \brief Retrieve the amount of cycles to delay for the given amount of ms
 */
uint32_t _get_cycles_for_ms(const uint16_t ms)
{
    1580:	b510      	push	{r4, lr}
    1582:	0003      	movs	r3, r0
		return (ms * (freq / 10000) + 2) / 3 * 10;
    1584:	20c8      	movs	r0, #200	; 0xc8
    1586:	0040      	lsls	r0, r0, #1
    1588:	4358      	muls	r0, r3
    158a:	3002      	adds	r0, #2
    158c:	2103      	movs	r1, #3
    158e:	4b03      	ldr	r3, [pc, #12]	; (159c <_get_cycles_for_ms+0x1c>)
    1590:	4798      	blx	r3
    1592:	0083      	lsls	r3, r0, #2
    1594:	181b      	adds	r3, r3, r0
    1596:	0058      	lsls	r0, r3, #1
	return _get_cycles_for_ms_internal(ms, CONF_CPU_FREQUENCY, CPU_FREQ_POWER);
}
    1598:	bd10      	pop	{r4, pc}
    159a:	46c0      	nop			; (mov r8, r8)
    159c:	000015f7 	.word	0x000015f7

000015a0 <_delay_cycles>:
{
#ifndef _UNIT_TEST_
	(void)hw;
	(void)cycles;
#if defined __GNUC__
	__asm(".syntax unified\n"
    15a0:	3901      	subs	r1, #1
    15a2:	d8fd      	bhi.n	15a0 <_delay_cycles>
	__asm("__delay:\n"
	      "subs r1, r1, #1\n"
	      "bhi __delay\n");
#endif
#endif
}
    15a4:	4770      	bx	lr
	...

000015a8 <_init_chip>:

/**
 * \brief Initialize the hardware abstraction layer
 */
void _init_chip(void)
{
    15a8:	b510      	push	{r4, lr}
}

static inline void hri_nvmctrl_set_CTRLB_RWS_bf(const void *const hw, hri_nvmctrl_ctrlb_reg_t mask)
{
	NVMCTRL_CRITICAL_SECTION_ENTER();
	((Nvmctrl *)hw)->CTRLB.reg |= NVMCTRL_CTRLB_RWS(mask);
    15aa:	4b08      	ldr	r3, [pc, #32]	; (15cc <_init_chip+0x24>)
    15ac:	685a      	ldr	r2, [r3, #4]
    15ae:	605a      	str	r2, [r3, #4]
	hri_nvmctrl_set_CTRLB_RWS_bf(NVMCTRL, CONF_NVM_WAIT_STATE);

	_osc32kctrl_init_sources();
    15b0:	4b07      	ldr	r3, [pc, #28]	; (15d0 <_init_chip+0x28>)
    15b2:	4798      	blx	r3
	_oscctrl_init_sources();
    15b4:	4b07      	ldr	r3, [pc, #28]	; (15d4 <_init_chip+0x2c>)
    15b6:	4798      	blx	r3
	_mclk_init();
    15b8:	4b07      	ldr	r3, [pc, #28]	; (15d8 <_init_chip+0x30>)
    15ba:	4798      	blx	r3
#if _GCLK_INIT_1ST
	_gclk_init_generators_by_fref(_GCLK_INIT_1ST);
#endif
	_oscctrl_init_referenced_generators();
    15bc:	4b07      	ldr	r3, [pc, #28]	; (15dc <_init_chip+0x34>)
    15be:	4798      	blx	r3
	_gclk_init_generators_by_fref(_GCLK_INIT_LAST);
    15c0:	20ff      	movs	r0, #255	; 0xff
    15c2:	4b07      	ldr	r3, [pc, #28]	; (15e0 <_init_chip+0x38>)
    15c4:	4798      	blx	r3

	_div_init();
    15c6:	4b07      	ldr	r3, [pc, #28]	; (15e4 <_init_chip+0x3c>)
    15c8:	4798      	blx	r3
#endif

#if (CONF_PORT_EVCTRL_PORT_0 | CONF_PORT_EVCTRL_PORT_1 | CONF_PORT_EVCTRL_PORT_2 | CONF_PORT_EVCTRL_PORT_3)
	_port_event_init();
#endif
}
    15ca:	bd10      	pop	{r4, pc}
    15cc:	41004000 	.word	0x41004000
    15d0:	00001851 	.word	0x00001851
    15d4:	00001875 	.word	0x00001875
    15d8:	00001845 	.word	0x00001845
    15dc:	000018b1 	.word	0x000018b1
    15e0:	00001821 	.word	0x00001821
    15e4:	000015e9 	.word	0x000015e9

000015e8 <_div_init>:

static inline void hri_divas_write_CTRLA_DLZ_bit(const void *const hw, bool value)
{
	uint8_t tmp;
	DIVAS_CRITICAL_SECTION_ENTER();
	tmp = ((Divas *)hw)->CTRLA.reg;
    15e8:	2290      	movs	r2, #144	; 0x90
    15ea:	05d2      	lsls	r2, r2, #23
    15ec:	7813      	ldrb	r3, [r2, #0]
	tmp &= ~DIVAS_CTRLA_DLZ;
    15ee:	2102      	movs	r1, #2
    15f0:	438b      	bics	r3, r1
	tmp |= value << DIVAS_CTRLA_DLZ_Pos;
	((Divas *)hw)->CTRLA.reg = tmp;
    15f2:	7013      	strb	r3, [r2, #0]
 * \brief Initialize hardware for division operation
 */
void _div_init(void)
{
	hri_divas_write_CTRLA_DLZ_bit(DIVAS, CONF_DIVAS_DLZ);
}
    15f4:	4770      	bx	lr

000015f6 <__aeabi_uidiv>:

/**
 * \brief Do unsigned division
 */
uint32_t __aeabi_uidiv(uint32_t numerator, uint32_t denominator)
{
    15f6:	b510      	push	{r4, lr}
    15f8:	b082      	sub	sp, #8
 */
__STATIC_FORCEINLINE uint32_t __get_PRIMASK(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
    15fa:	f3ef 8310 	mrs	r3, PRIMASK
	uint32_t res;
	_DIVAS_CRITICAL_ENTER();
    15fe:	9301      	str	r3, [sp, #4]
  __ASM volatile ("cpsid i" : : : "memory");
    1600:	b672      	cpsid	i
	DIVAS->CTRLA.bit.SIGNED = s;
    1602:	2390      	movs	r3, #144	; 0x90
    1604:	05db      	lsls	r3, r3, #23
    1606:	781a      	ldrb	r2, [r3, #0]
    1608:	2401      	movs	r4, #1
    160a:	43a2      	bics	r2, r4
    160c:	701a      	strb	r2, [r3, #0]
	DIVAS->DIVIDEND.reg     = n;
    160e:	6098      	str	r0, [r3, #8]
	DIVAS->DIVISOR.reg      = d;
    1610:	60d9      	str	r1, [r3, #12]
	while (DIVAS->STATUS.bit.BUSY) {
    1612:	2390      	movs	r3, #144	; 0x90
    1614:	05db      	lsls	r3, r3, #23
    1616:	791b      	ldrb	r3, [r3, #4]
    1618:	07db      	lsls	r3, r3, #31
    161a:	d4fa      	bmi.n	1612 <__aeabi_uidiv+0x1c>
	_divas_div(0, numerator, denominator);
	res = _divas_result32();
    161c:	2390      	movs	r3, #144	; 0x90
    161e:	05db      	lsls	r3, r3, #23
    1620:	6918      	ldr	r0, [r3, #16]
	_DIVAS_CRITICAL_LEAVE();
    1622:	9b01      	ldr	r3, [sp, #4]
  \details Assigns the given value to the Priority Mask Register.
  \param [in]    priMask  Priority Mask
 */
__STATIC_FORCEINLINE void __set_PRIMASK(uint32_t priMask)
{
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
    1624:	f383 8810 	msr	PRIMASK, r3
	return res;
}
    1628:	b002      	add	sp, #8
    162a:	bd10      	pop	{r4, pc}

0000162c <_dma_set_source_address>:
}

static inline void hri_dmacdescriptor_write_SRCADDR_reg(const void *const hw, hri_dmacdescriptor_srcaddr_reg_t data)
{
	DMAC_CRITICAL_SECTION_ENTER();
	((DmacDescriptor *)hw)->SRCADDR.reg = data;
    162c:	0103      	lsls	r3, r0, #4
    162e:	4802      	ldr	r0, [pc, #8]	; (1638 <_dma_set_source_address+0xc>)
    1630:	18c0      	adds	r0, r0, r3
    1632:	6041      	str	r1, [r0, #4]
int32_t _dma_set_source_address(const uint8_t channel, const void *const src)
{
	hri_dmacdescriptor_write_SRCADDR_reg(&_descriptor_section[channel], (uint32_t)src);

	return ERR_NONE;
}
    1634:	2000      	movs	r0, #0
    1636:	4770      	bx	lr
    1638:	200002e0 	.word	0x200002e0

0000163c <_dma_get_channel_resource>:
	return ERR_NONE;
}

int32_t _dma_get_channel_resource(struct _dma_resource **resource, const uint8_t channel)
{
	*resource = &_resources[channel];
    163c:	004b      	lsls	r3, r1, #1
    163e:	1859      	adds	r1, r3, r1
    1640:	008a      	lsls	r2, r1, #2
    1642:	4b02      	ldr	r3, [pc, #8]	; (164c <_dma_get_channel_resource+0x10>)
    1644:	189b      	adds	r3, r3, r2
    1646:	6003      	str	r3, [r0, #0]

	return ERR_NONE;
}
    1648:	2000      	movs	r0, #0
    164a:	4770      	bx	lr
    164c:	20000078 	.word	0x20000078

00001650 <DMAC_Handler>:

/**
 * \brief DMAC interrupt handler
 */
void DMAC_Handler(void)
{
    1650:	b570      	push	{r4, r5, r6, lr}
	tmp = ((Dmac *)hw)->INTPEND.reg;
    1652:	4a15      	ldr	r2, [pc, #84]	; (16a8 <DMAC_Handler+0x58>)
    1654:	8c11      	ldrh	r1, [r2, #32]
	uint8_t               channel         = hri_dmac_read_INTPEND_ID_bf(DMAC);
    1656:	230f      	movs	r3, #15
    1658:	400b      	ands	r3, r1
	return ((Dmac *)hw)->CHID.reg;
    165a:	253f      	movs	r5, #63	; 0x3f
    165c:	5d54      	ldrb	r4, [r2, r5]
    165e:	b2e4      	uxtb	r4, r4
	struct _dma_resource *tmp_resource = &_resources[channel];
    1660:	0059      	lsls	r1, r3, #1
    1662:	18c9      	adds	r1, r1, r3
    1664:	0088      	lsls	r0, r1, #2
    1666:	4911      	ldr	r1, [pc, #68]	; (16ac <DMAC_Handler+0x5c>)
    1668:	1808      	adds	r0, r1, r0
	((Dmac *)hw)->CHID.reg = data;
    166a:	5553      	strb	r3, [r2, r5]
	tmp = ((Dmac *)hw)->CHINTFLAG.reg;
    166c:	214e      	movs	r1, #78	; 0x4e
    166e:	5c52      	ldrb	r2, [r2, r1]
    1670:	b2d2      	uxtb	r2, r2
	if (flag_status & DMAC_CHINTFLAG_TERR) {
    1672:	07d1      	lsls	r1, r2, #31
    1674:	d405      	bmi.n	1682 <DMAC_Handler+0x32>
	} else if (flag_status & DMAC_CHINTFLAG_TCMPL) {
    1676:	0792      	lsls	r2, r2, #30
    1678:	d40a      	bmi.n	1690 <DMAC_Handler+0x40>
	((Dmac *)hw)->CHID.reg = data;
    167a:	233f      	movs	r3, #63	; 0x3f
    167c:	4a0a      	ldr	r2, [pc, #40]	; (16a8 <DMAC_Handler+0x58>)
    167e:	54d4      	strb	r4, [r2, r3]
	_dmac_handler();
}
    1680:	bd70      	pop	{r4, r5, r6, pc}
	((Dmac *)hw)->CHINTFLAG.reg = DMAC_CHINTFLAG_TERR;
    1682:	3d3e      	subs	r5, #62	; 0x3e
    1684:	224e      	movs	r2, #78	; 0x4e
    1686:	4908      	ldr	r1, [pc, #32]	; (16a8 <DMAC_Handler+0x58>)
    1688:	548d      	strb	r5, [r1, r2]
		tmp_resource->dma_cb.error(tmp_resource);
    168a:	6843      	ldr	r3, [r0, #4]
    168c:	4798      	blx	r3
    168e:	e7f4      	b.n	167a <DMAC_Handler+0x2a>
	((Dmac *)hw)->CHINTFLAG.reg = DMAC_CHINTFLAG_TCMPL;
    1690:	2502      	movs	r5, #2
    1692:	224e      	movs	r2, #78	; 0x4e
    1694:	4904      	ldr	r1, [pc, #16]	; (16a8 <DMAC_Handler+0x58>)
    1696:	548d      	strb	r5, [r1, r2]
		tmp_resource->dma_cb.transfer_done(tmp_resource);
    1698:	005a      	lsls	r2, r3, #1
    169a:	18d3      	adds	r3, r2, r3
    169c:	009a      	lsls	r2, r3, #2
    169e:	4b03      	ldr	r3, [pc, #12]	; (16ac <DMAC_Handler+0x5c>)
    16a0:	58d3      	ldr	r3, [r2, r3]
    16a2:	4798      	blx	r3
    16a4:	e7e9      	b.n	167a <DMAC_Handler+0x2a>
    16a6:	46c0      	nop			; (mov r8, r8)
    16a8:	41006000 	.word	0x41006000
    16ac:	20000078 	.word	0x20000078

000016b0 <_ext_irq_handler>:

/**
 * \brief Inter EIC interrupt handler
 */
static void _ext_irq_handler(void)
{
    16b0:	b5f0      	push	{r4, r5, r6, r7, lr}
    16b2:	b083      	sub	sp, #12
	return tmp;
}

static inline hri_eic_intflag_reg_t hri_eic_read_INTFLAG_reg(const void *const hw)
{
	return ((Eic *)hw)->INTFLAG.reg;
    16b4:	4b25      	ldr	r3, [pc, #148]	; (174c <_ext_irq_handler+0x9c>)
    16b6:	695a      	ldr	r2, [r3, #20]
	volatile uint32_t flags = hri_eic_read_INTFLAG_reg(EIC);
    16b8:	9201      	str	r2, [sp, #4]
	int8_t            pos;
	uint32_t          pin = INVALID_PIN_NUMBER;

	hri_eic_clear_INTFLAG_reg(EIC, flags);
    16ba:	9a01      	ldr	r2, [sp, #4]
}

static inline void hri_eic_clear_INTFLAG_reg(const void *const hw, hri_eic_intflag_reg_t mask)
{
	((Eic *)hw)->INTFLAG.reg = mask;
    16bc:	615a      	str	r2, [r3, #20]

	ASSERT(callback);
    16be:	4b24      	ldr	r3, [pc, #144]	; (1750 <_ext_irq_handler+0xa0>)
    16c0:	6818      	ldr	r0, [r3, #0]
    16c2:	1e43      	subs	r3, r0, #1
    16c4:	4198      	sbcs	r0, r3
    16c6:	b2c0      	uxtb	r0, r0
    16c8:	22e8      	movs	r2, #232	; 0xe8
    16ca:	4922      	ldr	r1, [pc, #136]	; (1754 <_ext_irq_handler+0xa4>)
    16cc:	4b22      	ldr	r3, [pc, #136]	; (1758 <_ext_irq_handler+0xa8>)
    16ce:	4798      	blx	r3
	uint32_t          pin = INVALID_PIN_NUMBER;
    16d0:	2501      	movs	r5, #1
    16d2:	426d      	negs	r5, r5

	while (flags) {
    16d4:	e02f      	b.n	1736 <_ext_irq_handler+0x86>
			uint8_t lower = 0, middle, upper = EXT_IRQ_AMOUNT;

			while (upper >= lower) {
				middle = (upper + lower) >> 1;
				if (_map[middle].extint == pos) {
					pin = _map[middle].pin;
    16d6:	00db      	lsls	r3, r3, #3
    16d8:	4a20      	ldr	r2, [pc, #128]	; (175c <_ext_irq_handler+0xac>)
    16da:	18d3      	adds	r3, r2, r3
    16dc:	685d      	ldr	r5, [r3, #4]
				} else {
					upper = middle - 1;
				}
			}

			if (INVALID_PIN_NUMBER != pin) {
    16de:	1c6b      	adds	r3, r5, #1
    16e0:	d003      	beq.n	16ea <_ext_irq_handler+0x3a>
				callback(pin);
    16e2:	4b1b      	ldr	r3, [pc, #108]	; (1750 <_ext_irq_handler+0xa0>)
    16e4:	681b      	ldr	r3, [r3, #0]
    16e6:	0028      	movs	r0, r5
    16e8:	4798      	blx	r3
			}
			flags &= ~(1ul << pos);
    16ea:	2201      	movs	r2, #1
    16ec:	40a2      	lsls	r2, r4
    16ee:	9b01      	ldr	r3, [sp, #4]
    16f0:	4393      	bics	r3, r2
    16f2:	9301      	str	r3, [sp, #4]
			pos = ffs(flags) - 1;
    16f4:	9801      	ldr	r0, [sp, #4]
    16f6:	4b1a      	ldr	r3, [pc, #104]	; (1760 <_ext_irq_handler+0xb0>)
    16f8:	4798      	blx	r3
    16fa:	3801      	subs	r0, #1
    16fc:	b244      	sxtb	r4, r0
		while (-1 != pos) {
    16fe:	1c63      	adds	r3, r4, #1
    1700:	d014      	beq.n	172c <_ext_irq_handler+0x7c>
    1702:	260b      	movs	r6, #11
    1704:	2000      	movs	r0, #0
    1706:	e001      	b.n	170c <_ext_irq_handler+0x5c>
					upper = middle - 1;
    1708:	3901      	subs	r1, #1
    170a:	b2ce      	uxtb	r6, r1
			while (upper >= lower) {
    170c:	42b0      	cmp	r0, r6
    170e:	d8e6      	bhi.n	16de <_ext_irq_handler+0x2e>
				middle = (upper + lower) >> 1;
    1710:	1833      	adds	r3, r6, r0
    1712:	105b      	asrs	r3, r3, #1
    1714:	b2d9      	uxtb	r1, r3
    1716:	22ff      	movs	r2, #255	; 0xff
    1718:	4013      	ands	r3, r2
				if (_map[middle].extint == pos) {
    171a:	00df      	lsls	r7, r3, #3
    171c:	4a0f      	ldr	r2, [pc, #60]	; (175c <_ext_irq_handler+0xac>)
    171e:	5cba      	ldrb	r2, [r7, r2]
    1720:	42a2      	cmp	r2, r4
    1722:	d0d8      	beq.n	16d6 <_ext_irq_handler+0x26>
				if (_map[middle].extint < pos) {
    1724:	daf0      	bge.n	1708 <_ext_irq_handler+0x58>
					lower = middle + 1;
    1726:	3101      	adds	r1, #1
    1728:	b2c8      	uxtb	r0, r1
    172a:	e7ef      	b.n	170c <_ext_irq_handler+0x5c>
	return ((Eic *)hw)->INTFLAG.reg;
    172c:	4b07      	ldr	r3, [pc, #28]	; (174c <_ext_irq_handler+0x9c>)
    172e:	695a      	ldr	r2, [r3, #20]
		}
		flags = hri_eic_read_INTFLAG_reg(EIC);
    1730:	9201      	str	r2, [sp, #4]
		hri_eic_clear_INTFLAG_reg(EIC, flags);
    1732:	9a01      	ldr	r2, [sp, #4]
	((Eic *)hw)->INTFLAG.reg = mask;
    1734:	615a      	str	r2, [r3, #20]
	while (flags) {
    1736:	9b01      	ldr	r3, [sp, #4]
    1738:	2b00      	cmp	r3, #0
    173a:	d005      	beq.n	1748 <_ext_irq_handler+0x98>
		pos = ffs(flags) - 1;
    173c:	9801      	ldr	r0, [sp, #4]
    173e:	4b08      	ldr	r3, [pc, #32]	; (1760 <_ext_irq_handler+0xb0>)
    1740:	4798      	blx	r3
    1742:	3801      	subs	r0, #1
    1744:	b244      	sxtb	r4, r0
		while (-1 != pos) {
    1746:	e7da      	b.n	16fe <_ext_irq_handler+0x4e>
	}
}
    1748:	b003      	add	sp, #12
    174a:	bdf0      	pop	{r4, r5, r6, r7, pc}
    174c:	40002800 	.word	0x40002800
    1750:	20000108 	.word	0x20000108
    1754:	00002790 	.word	0x00002790
    1758:	0000138d 	.word	0x0000138d
    175c:	00002738 	.word	0x00002738
    1760:	000025d5 	.word	0x000025d5

00001764 <_ext_irq_init>:
	return ((Eic *)hw)->SYNCBUSY.reg & reg;
    1764:	4b28      	ldr	r3, [pc, #160]	; (1808 <_ext_irq_init+0xa4>)
    1766:	685b      	ldr	r3, [r3, #4]
	if (!hri_eic_is_syncing(EIC, EIC_SYNCBUSY_SWRST)) {
    1768:	07db      	lsls	r3, r3, #31
    176a:	d41b      	bmi.n	17a4 <_ext_irq_init+0x40>
	while (((Eic *)hw)->SYNCBUSY.reg & reg) {
    176c:	4b26      	ldr	r3, [pc, #152]	; (1808 <_ext_irq_init+0xa4>)
    176e:	685b      	ldr	r3, [r3, #4]
    1770:	079b      	lsls	r3, r3, #30
    1772:	d1fb      	bne.n	176c <_ext_irq_init+0x8>

static inline hri_eic_ctrla_reg_t hri_eic_get_CTRLA_reg(const void *const hw, hri_eic_ctrla_reg_t mask)
{
	uint8_t tmp;
	hri_eic_wait_for_sync(hw, EIC_SYNCBUSY_MASK);
	tmp = ((Eic *)hw)->CTRLA.reg;
    1774:	4b24      	ldr	r3, [pc, #144]	; (1808 <_ext_irq_init+0xa4>)
    1776:	781b      	ldrb	r3, [r3, #0]
		if (hri_eic_get_CTRLA_reg(EIC, EIC_CTRLA_ENABLE)) {
    1778:	079b      	lsls	r3, r3, #30
    177a:	d50c      	bpl.n	1796 <_ext_irq_init+0x32>
	((Eic *)hw)->CTRLA.reg &= ~EIC_CTRLA_ENABLE;
    177c:	4a22      	ldr	r2, [pc, #136]	; (1808 <_ext_irq_init+0xa4>)
    177e:	7813      	ldrb	r3, [r2, #0]
    1780:	2102      	movs	r1, #2
    1782:	438b      	bics	r3, r1
    1784:	7013      	strb	r3, [r2, #0]
	while (((Eic *)hw)->SYNCBUSY.reg & reg) {
    1786:	4b20      	ldr	r3, [pc, #128]	; (1808 <_ext_irq_init+0xa4>)
    1788:	685b      	ldr	r3, [r3, #4]
    178a:	079b      	lsls	r3, r3, #30
    178c:	d1fb      	bne.n	1786 <_ext_irq_init+0x22>
    178e:	4b1e      	ldr	r3, [pc, #120]	; (1808 <_ext_irq_init+0xa4>)
    1790:	685b      	ldr	r3, [r3, #4]
    1792:	079b      	lsls	r3, r3, #30
    1794:	d4fb      	bmi.n	178e <_ext_irq_init+0x2a>
}

static inline void hri_eic_write_CTRLA_reg(const void *const hw, hri_eic_ctrla_reg_t data)
{
	EIC_CRITICAL_SECTION_ENTER();
	((Eic *)hw)->CTRLA.reg = data;
    1796:	2201      	movs	r2, #1
    1798:	4b1b      	ldr	r3, [pc, #108]	; (1808 <_ext_irq_init+0xa4>)
    179a:	701a      	strb	r2, [r3, #0]
	while (((Eic *)hw)->SYNCBUSY.reg & reg) {
    179c:	4b1a      	ldr	r3, [pc, #104]	; (1808 <_ext_irq_init+0xa4>)
    179e:	685b      	ldr	r3, [r3, #4]
    17a0:	079b      	lsls	r3, r3, #30
    17a2:	d1fb      	bne.n	179c <_ext_irq_init+0x38>
    17a4:	4b18      	ldr	r3, [pc, #96]	; (1808 <_ext_irq_init+0xa4>)
    17a6:	685b      	ldr	r3, [r3, #4]
    17a8:	07db      	lsls	r3, r3, #31
    17aa:	d4fb      	bmi.n	17a4 <_ext_irq_init+0x40>
	tmp = ((Eic *)hw)->CTRLA.reg;
    17ac:	4a16      	ldr	r2, [pc, #88]	; (1808 <_ext_irq_init+0xa4>)
    17ae:	7813      	ldrb	r3, [r2, #0]
	tmp &= ~EIC_CTRLA_CKSEL;
    17b0:	2110      	movs	r1, #16
    17b2:	438b      	bics	r3, r1
	((Eic *)hw)->CTRLA.reg = tmp;
    17b4:	7013      	strb	r3, [r2, #0]
	while (((Eic *)hw)->SYNCBUSY.reg & reg) {
    17b6:	4b14      	ldr	r3, [pc, #80]	; (1808 <_ext_irq_init+0xa4>)
    17b8:	685b      	ldr	r3, [r3, #4]
    17ba:	079b      	lsls	r3, r3, #30
    17bc:	d1fb      	bne.n	17b6 <_ext_irq_init+0x52>
}

static inline void hri_eic_write_NMICTRL_reg(const void *const hw, hri_eic_nmictrl_reg_t data)
{
	EIC_CRITICAL_SECTION_ENTER();
	((Eic *)hw)->NMICTRL.reg = data;
    17be:	4b12      	ldr	r3, [pc, #72]	; (1808 <_ext_irq_init+0xa4>)
    17c0:	2200      	movs	r2, #0
    17c2:	705a      	strb	r2, [r3, #1]
}

static inline void hri_eic_write_EVCTRL_reg(const void *const hw, hri_eic_evctrl_reg_t data)
{
	EIC_CRITICAL_SECTION_ENTER();
	((Eic *)hw)->EVCTRL.reg = data;
    17c4:	609a      	str	r2, [r3, #8]
}

static inline void hri_eic_write_ASYNCH_reg(const void *const hw, hri_eic_asynch_reg_t data)
{
	EIC_CRITICAL_SECTION_ENTER();
	((Eic *)hw)->ASYNCH.reg = data;
    17c6:	619a      	str	r2, [r3, #24]
}

static inline void hri_eic_write_DEBOUNCEN_reg(const void *const hw, hri_eic_debouncen_reg_t data)
{
	EIC_CRITICAL_SECTION_ENTER();
	((Eic *)hw)->DEBOUNCEN.reg = data;
    17c8:	2180      	movs	r1, #128	; 0x80
    17ca:	0209      	lsls	r1, r1, #8
    17cc:	6319      	str	r1, [r3, #48]	; 0x30
}

static inline void hri_eic_write_DPRESCALER_reg(const void *const hw, hri_eic_dprescaler_reg_t data)
{
	EIC_CRITICAL_SECTION_ENTER();
	((Eic *)hw)->DPRESCALER.reg = data;
    17ce:	635a      	str	r2, [r3, #52]	; 0x34
	((Eic *)hw)->CONFIG[index].reg = data;
    17d0:	2103      	movs	r1, #3
    17d2:	61d9      	str	r1, [r3, #28]
    17d4:	621a      	str	r2, [r3, #32]
	((Eic *)hw)->CTRLA.reg |= EIC_CTRLA_ENABLE;
    17d6:	781a      	ldrb	r2, [r3, #0]
    17d8:	2102      	movs	r1, #2
    17da:	430a      	orrs	r2, r1
    17dc:	b2d2      	uxtb	r2, r2
    17de:	701a      	strb	r2, [r3, #0]
	while (((Eic *)hw)->SYNCBUSY.reg & reg) {
    17e0:	4b09      	ldr	r3, [pc, #36]	; (1808 <_ext_irq_init+0xa4>)
    17e2:	685b      	ldr	r3, [r3, #4]
    17e4:	079b      	lsls	r3, r3, #30
    17e6:	d1fb      	bne.n	17e0 <_ext_irq_init+0x7c>
 */
__STATIC_INLINE void __NVIC_DisableIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
  {
    NVIC->ICER[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    17e8:	4b08      	ldr	r3, [pc, #32]	; (180c <_ext_irq_init+0xa8>)
    17ea:	2208      	movs	r2, #8
    17ec:	2180      	movs	r1, #128	; 0x80
    17ee:	505a      	str	r2, [r3, r1]
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__STATIC_FORCEINLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
    17f0:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    17f4:	f3bf 8f6f 	isb	sy
 */
__STATIC_INLINE void __NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
  {
    NVIC->ICPR[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    17f8:	3101      	adds	r1, #1
    17fa:	31ff      	adds	r1, #255	; 0xff
    17fc:	505a      	str	r2, [r3, r1]
    NVIC->ISER[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    17fe:	601a      	str	r2, [r3, #0]
	callback = cb;
    1800:	4b03      	ldr	r3, [pc, #12]	; (1810 <_ext_irq_init+0xac>)
    1802:	6018      	str	r0, [r3, #0]
}
    1804:	2000      	movs	r0, #0
    1806:	4770      	bx	lr
    1808:	40002800 	.word	0x40002800
    180c:	e000e100 	.word	0xe000e100
    1810:	20000108 	.word	0x20000108

00001814 <EIC_Handler>:

/**
 * \brief EIC interrupt handler
 */
void EIC_Handler(void)
{
    1814:	b510      	push	{r4, lr}
	_ext_irq_handler();
    1816:	4b01      	ldr	r3, [pc, #4]	; (181c <EIC_Handler+0x8>)
    1818:	4798      	blx	r3
}
    181a:	bd10      	pop	{r4, pc}
    181c:	000016b1 	.word	0x000016b1

00001820 <_gclk_init_generators_by_fref>:

void _gclk_init_generators_by_fref(uint32_t bm)
{

#if CONF_GCLK_GENERATOR_0_CONFIG == 1
	if (bm & (1ul << 0)) {
    1820:	07c3      	lsls	r3, r0, #31
    1822:	d507      	bpl.n	1834 <_gclk_init_generators_by_fref+0x14>
	((Gclk *)hw)->GENCTRL[index].reg = data;
    1824:	4a04      	ldr	r2, [pc, #16]	; (1838 <_gclk_init_generators_by_fref+0x18>)
    1826:	4b05      	ldr	r3, [pc, #20]	; (183c <_gclk_init_generators_by_fref+0x1c>)
    1828:	621a      	str	r2, [r3, #32]
	while (((Gclk *)hw)->SYNCBUSY.reg & reg) {
    182a:	4b04      	ldr	r3, [pc, #16]	; (183c <_gclk_init_generators_by_fref+0x1c>)
    182c:	685a      	ldr	r2, [r3, #4]
    182e:	4b04      	ldr	r3, [pc, #16]	; (1840 <_gclk_init_generators_by_fref+0x20>)
    1830:	421a      	tst	r2, r3
    1832:	d1fa      	bne.n	182a <_gclk_init_generators_by_fref+0xa>
		        | (CONF_GCLK_GEN_8_DIVSEL << GCLK_GENCTRL_DIVSEL_Pos) | (CONF_GCLK_GEN_8_OE << GCLK_GENCTRL_OE_Pos)
		        | (CONF_GCLK_GEN_8_OOV << GCLK_GENCTRL_OOV_Pos) | (CONF_GCLK_GEN_8_IDC << GCLK_GENCTRL_IDC_Pos)
		        | (CONF_GCLK_GENERATOR_8_CONFIG << GCLK_GENCTRL_GENEN_Pos) | CONF_GCLK_GEN_8_SOURCE);
	}
#endif
}
    1834:	4770      	bx	lr
    1836:	46c0      	nop			; (mov r8, r8)
    1838:	00012306 	.word	0x00012306
    183c:	40001c00 	.word	0x40001c00
    1840:	000007fd 	.word	0x000007fd

00001844 <_mclk_init>:
	((Mclk *)hw)->CPUDIV.reg = data;
    1844:	2201      	movs	r2, #1
    1846:	4b01      	ldr	r3, [pc, #4]	; (184c <_mclk_init+0x8>)
    1848:	711a      	strb	r2, [r3, #4]
 */
void _mclk_init(void)
{
	void *hw = (void *)MCLK;
	hri_mclk_write_CPUDIV_reg(hw, MCLK_CPUDIV_CPUDIV(CONF_MCLK_CPUDIV));
}
    184a:	4770      	bx	lr
    184c:	40000800 	.word	0x40000800

00001850 <_osc32kctrl_init_sources>:
}

static inline void hri_osc32kctrl_write_XOSC32K_reg(const void *const hw, hri_osc32kctrl_xosc32k_reg_t data)
{
	OSC32KCTRL_CRITICAL_SECTION_ENTER();
	((Osc32kctrl *)hw)->XOSC32K.reg = data;
    1850:	4a07      	ldr	r2, [pc, #28]	; (1870 <_osc32kctrl_init_sources+0x20>)
    1852:	2386      	movs	r3, #134	; 0x86
    1854:	8293      	strh	r3, [r2, #20]
}

static inline void hri_osc32kctrl_write_CFDCTRL_reg(const void *const hw, hri_osc32kctrl_cfdctrl_reg_t data)
{
	OSC32KCTRL_CRITICAL_SECTION_ENTER();
	((Osc32kctrl *)hw)->CFDCTRL.reg = data;
    1856:	2300      	movs	r3, #0
    1858:	7593      	strb	r3, [r2, #22]
}

static inline void hri_osc32kctrl_write_EVCTRL_reg(const void *const hw, hri_osc32kctrl_evctrl_reg_t data)
{
	OSC32KCTRL_CRITICAL_SECTION_ENTER();
	((Osc32kctrl *)hw)->EVCTRL.reg = data;
    185a:	75d3      	strb	r3, [r2, #23]
}

static inline hri_osc32kctrl_osculp32k_reg_t hri_osc32kctrl_read_OSCULP32K_CALIB_bf(const void *const hw)
{
	uint32_t tmp;
	tmp = ((Osc32kctrl *)hw)->OSCULP32K.reg;
    185c:	69d3      	ldr	r3, [r2, #28]
	tmp = (tmp & OSC32KCTRL_OSCULP32K_CALIB_Msk) >> OSC32KCTRL_OSCULP32K_CALIB_Pos;
    185e:	0a1b      	lsrs	r3, r3, #8
	calib = hri_osc32kctrl_read_OSCULP32K_CALIB_bf(hw);
	hri_osc32kctrl_write_OSCULP32K_reg(hw,
#if CONF_OSC32K_CALIB_ENABLE == 1
	                                   OSC32KCTRL_OSCULP32K_CALIB(CONF_OSC32K_CALIB)
#else
	                                   OSC32KCTRL_OSCULP32K_CALIB(calib)
    1860:	021b      	lsls	r3, r3, #8
    1862:	21f8      	movs	r1, #248	; 0xf8
    1864:	0149      	lsls	r1, r1, #5
    1866:	400b      	ands	r3, r1
}

static inline void hri_osc32kctrl_write_OSCULP32K_reg(const void *const hw, hri_osc32kctrl_osculp32k_reg_t data)
{
	OSC32KCTRL_CRITICAL_SECTION_ENTER();
	((Osc32kctrl *)hw)->OSCULP32K.reg = data;
    1868:	61d3      	str	r3, [r2, #28]
	((Osc32kctrl *)hw)->RTCCTRL.reg = data;
    186a:	2301      	movs	r3, #1
    186c:	6113      	str	r3, [r2, #16]
		;
#endif
#endif
	hri_osc32kctrl_write_RTCCTRL_reg(hw, OSC32KCTRL_RTCCTRL_RTCSEL(CONF_RTCCTRL));
	(void)calib;
}
    186e:	4770      	bx	lr
    1870:	40001400 	.word	0x40001400

00001874 <_oscctrl_init_sources>:
}

static inline void hri_oscctrl_write_OSC48MCTRL_reg(const void *const hw, hri_oscctrl_osc48mctrl_reg_t data)
{
	OSCCTRL_CRITICAL_SECTION_ENTER();
	((Oscctrl *)hw)->OSC48MCTRL.reg = data;
    1874:	4b0d      	ldr	r3, [pc, #52]	; (18ac <_oscctrl_init_sources+0x38>)
    1876:	2242      	movs	r2, #66	; 0x42
    1878:	751a      	strb	r2, [r3, #20]
}

static inline void hri_oscctrl_write_OSC48MDIV_reg(const void *const hw, hri_oscctrl_osc48mdiv_reg_t data)
{
	OSCCTRL_CRITICAL_SECTION_ENTER();
	((Oscctrl *)hw)->OSC48MDIV.reg = data;
    187a:	3a37      	subs	r2, #55	; 0x37
    187c:	755a      	strb	r2, [r3, #21]
	while (((Oscctrl *)hw)->OSC48MSYNCBUSY.reg & reg) {
    187e:	4b0b      	ldr	r3, [pc, #44]	; (18ac <_oscctrl_init_sources+0x38>)
    1880:	699b      	ldr	r3, [r3, #24]
    1882:	075b      	lsls	r3, r3, #29
    1884:	d4fb      	bmi.n	187e <_oscctrl_init_sources+0xa>
	return (((Oscctrl *)hw)->OSC48MSYNCBUSY.reg & OSCCTRL_OSC48MSYNCBUSY_OSC48MDIV)
    1886:	4b09      	ldr	r3, [pc, #36]	; (18ac <_oscctrl_init_sources+0x38>)
    1888:	699b      	ldr	r3, [r3, #24]
#if CONF_OSC48M_CONFIG == 1
	hri_oscctrl_write_OSC48MCTRL_reg(hw,
	                                 (CONF_OSC48M_RUNSTDBY << OSCCTRL_OSC48MCTRL_RUNSTDBY_Pos)
	                                     | (CONF_OSC48M_ENABLE << OSCCTRL_OSC48MCTRL_ENABLE_Pos));
	hri_oscctrl_write_OSC48MDIV_reg(hw, OSCCTRL_OSC48MDIV_DIV(CONF_OSC48M_DIV));
	while (hri_oscctrl_get_OSC48MSYNCBUSY_OSC48MDIV_bit(hw))
    188a:	075b      	lsls	r3, r3, #29
    188c:	d4fb      	bmi.n	1886 <_oscctrl_init_sources+0x12>
}

static inline void hri_oscctrl_write_OSC48MSTUP_reg(const void *const hw, hri_oscctrl_osc48mstup_reg_t data)
{
	OSCCTRL_CRITICAL_SECTION_ENTER();
	((Oscctrl *)hw)->OSC48MSTUP.reg = data;
    188e:	2207      	movs	r2, #7
    1890:	4b06      	ldr	r3, [pc, #24]	; (18ac <_oscctrl_init_sources+0x38>)
    1892:	759a      	strb	r2, [r3, #22]
	return (((Oscctrl *)hw)->STATUS.reg & OSCCTRL_STATUS_OSC48MRDY) >> OSCCTRL_STATUS_OSC48MRDY_Pos;
    1894:	4b05      	ldr	r3, [pc, #20]	; (18ac <_oscctrl_init_sources+0x38>)
    1896:	68db      	ldr	r3, [r3, #12]
#endif
#endif

#if CONF_OSC48M_CONFIG == 1
#if CONF_OSC48M_ENABLE == 1
	while (!hri_oscctrl_get_STATUS_OSC48MRDY_bit(hw))
    1898:	06db      	lsls	r3, r3, #27
    189a:	d5fb      	bpl.n	1894 <_oscctrl_init_sources+0x20>
	((Oscctrl *)hw)->OSC48MCTRL.reg |= OSCCTRL_OSC48MCTRL_ONDEMAND;
    189c:	4a03      	ldr	r2, [pc, #12]	; (18ac <_oscctrl_init_sources+0x38>)
    189e:	7d13      	ldrb	r3, [r2, #20]
    18a0:	2180      	movs	r1, #128	; 0x80
    18a2:	4249      	negs	r1, r1
    18a4:	430b      	orrs	r3, r1
    18a6:	b2db      	uxtb	r3, r3
    18a8:	7513      	strb	r3, [r2, #20]
#if CONF_OSC48M_ONDEMAND == 1
	hri_oscctrl_set_OSC48MCTRL_ONDEMAND_bit(hw);
#endif
#endif
	(void)hw;
}
    18aa:	4770      	bx	lr
    18ac:	40001000 	.word	0x40001000

000018b0 <_oscctrl_init_referenced_generators>:
#if CONF_DPLL_ONDEMAND == 1
	hri_oscctrl_set_DPLLCTRLA_ONDEMAND_bit(hw);
#endif
#endif
	(void)hw;
}
    18b0:	4770      	bx	lr
	...

000018b4 <_sercom_get_hardware_index>:

/**
 * \brief Retrieve ordinal number of the given sercom hardware instance
 */
static uint8_t _sercom_get_hardware_index(const void *const hw)
{
    18b4:	b530      	push	{r4, r5, lr}
    18b6:	b089      	sub	sp, #36	; 0x24
	Sercom *const sercom_modules[] = SERCOM_INSTS;
    18b8:	4c0b      	ldr	r4, [pc, #44]	; (18e8 <_sercom_get_hardware_index+0x34>)
    18ba:	466b      	mov	r3, sp
    18bc:	0022      	movs	r2, r4
    18be:	ca32      	ldmia	r2!, {r1, r4, r5}
    18c0:	c332      	stmia	r3!, {r1, r4, r5}
    18c2:	ca32      	ldmia	r2!, {r1, r4, r5}
    18c4:	c332      	stmia	r3!, {r1, r4, r5}
    18c6:	ca12      	ldmia	r2!, {r1, r4}
    18c8:	c312      	stmia	r3!, {r1, r4}
	/* Find index for SERCOM instance. */
	for (uint32_t i = 0; i < SERCOM_INST_NUM; i++) {
    18ca:	2300      	movs	r3, #0
    18cc:	2b07      	cmp	r3, #7
    18ce:	d808      	bhi.n	18e2 <_sercom_get_hardware_index+0x2e>
		if ((uint32_t)hw == (uint32_t)sercom_modules[i]) {
    18d0:	009a      	lsls	r2, r3, #2
    18d2:	4669      	mov	r1, sp
    18d4:	5852      	ldr	r2, [r2, r1]
    18d6:	4282      	cmp	r2, r0
    18d8:	d001      	beq.n	18de <_sercom_get_hardware_index+0x2a>
	for (uint32_t i = 0; i < SERCOM_INST_NUM; i++) {
    18da:	3301      	adds	r3, #1
    18dc:	e7f6      	b.n	18cc <_sercom_get_hardware_index+0x18>
			return i;
    18de:	b2d8      	uxtb	r0, r3
    18e0:	e000      	b.n	18e4 <_sercom_get_hardware_index+0x30>
		}
	}
	return 0;
    18e2:	2000      	movs	r0, #0
}
    18e4:	b009      	add	sp, #36	; 0x24
    18e6:	bd30      	pop	{r4, r5, pc}
    18e8:	000027a8 	.word	0x000027a8

000018ec <_get_i2cm_index>:
 * \param[in] hw The pointer to hardware instance

 * \return The ordinal number of the given sercom hardware instance
 */
static int8_t _get_i2cm_index(const void *const hw)
{
    18ec:	b510      	push	{r4, lr}
	uint8_t sercom_offset = _sercom_get_hardware_index(hw);
    18ee:	4b0d      	ldr	r3, [pc, #52]	; (1924 <_get_i2cm_index+0x38>)
    18f0:	4798      	blx	r3
	uint8_t i;

	for (i = 0; i < ARRAY_SIZE(_i2cms); i++) {
    18f2:	2300      	movs	r3, #0
    18f4:	2b03      	cmp	r3, #3
    18f6:	d80d      	bhi.n	1914 <_get_i2cm_index+0x28>
		if (_i2cms[i].number == sercom_offset) {
    18f8:	005a      	lsls	r2, r3, #1
    18fa:	18d2      	adds	r2, r2, r3
    18fc:	00d1      	lsls	r1, r2, #3
    18fe:	4a0a      	ldr	r2, [pc, #40]	; (1928 <_get_i2cm_index+0x3c>)
    1900:	1852      	adds	r2, r2, r1
    1902:	2134      	movs	r1, #52	; 0x34
    1904:	5c52      	ldrb	r2, [r2, r1]
    1906:	4290      	cmp	r0, r2
    1908:	d002      	beq.n	1910 <_get_i2cm_index+0x24>
	for (i = 0; i < ARRAY_SIZE(_i2cms); i++) {
    190a:	3301      	adds	r3, #1
    190c:	b2db      	uxtb	r3, r3
    190e:	e7f1      	b.n	18f4 <_get_i2cm_index+0x8>
			return i;
    1910:	b258      	sxtb	r0, r3
    1912:	e006      	b.n	1922 <_get_i2cm_index+0x36>
		}
	}

	ASSERT(false);
    1914:	4a05      	ldr	r2, [pc, #20]	; (192c <_get_i2cm_index+0x40>)
    1916:	4906      	ldr	r1, [pc, #24]	; (1930 <_get_i2cm_index+0x44>)
    1918:	2000      	movs	r0, #0
    191a:	4b06      	ldr	r3, [pc, #24]	; (1934 <_get_i2cm_index+0x48>)
    191c:	4798      	blx	r3
	return -1;
    191e:	2001      	movs	r0, #1
    1920:	4240      	negs	r0, r0
}
    1922:	bd10      	pop	{r4, pc}
    1924:	000018b5 	.word	0x000018b5
    1928:	000027a8 	.word	0x000027a8
    192c:	0000039b 	.word	0x0000039b
    1930:	00002860 	.word	0x00002860
    1934:	0000138d 	.word	0x0000138d

00001938 <_i2c_m_sync_init_impl>:
	}
	return ERR_NONE;
}

static int32_t _i2c_m_sync_init_impl(struct _i2c_m_service *const service, void *const hw)
{
    1938:	b570      	push	{r4, r5, r6, lr}
    193a:	0005      	movs	r5, r0
    193c:	000c      	movs	r4, r1
	uint8_t i = _get_i2cm_index(hw);
    193e:	0008      	movs	r0, r1
    1940:	4b2e      	ldr	r3, [pc, #184]	; (19fc <_i2c_m_sync_init_impl+0xc4>)
    1942:	4798      	blx	r3
    1944:	b2c0      	uxtb	r0, r0
	};
}

static inline bool hri_sercomi2cm_is_syncing(const void *const hw, hri_sercomi2cm_syncbusy_reg_t reg)
{
	return ((Sercom *)hw)->I2CM.SYNCBUSY.reg & reg;
    1946:	69e3      	ldr	r3, [r4, #28]

	if (!hri_sercomi2cm_is_syncing(hw, SERCOM_I2CM_SYNCBUSY_SWRST)) {
    1948:	07db      	lsls	r3, r3, #31
    194a:	d41d      	bmi.n	1988 <_i2c_m_sync_init_impl+0x50>
		uint32_t mode = _i2cms[i].ctrl_a & SERCOM_I2CM_CTRLA_MODE_Msk;
    194c:	0043      	lsls	r3, r0, #1
    194e:	181b      	adds	r3, r3, r0
    1950:	00da      	lsls	r2, r3, #3
    1952:	4b2b      	ldr	r3, [pc, #172]	; (1a00 <_i2c_m_sync_init_impl+0xc8>)
    1954:	189b      	adds	r3, r3, r2
    1956:	6b9a      	ldr	r2, [r3, #56]	; 0x38
    1958:	231c      	movs	r3, #28
    195a:	401a      	ands	r2, r3
	while (((Sercom *)hw)->I2CM.SYNCBUSY.reg & reg) {
    195c:	69e3      	ldr	r3, [r4, #28]
    195e:	079b      	lsls	r3, r3, #30
    1960:	d1fc      	bne.n	195c <_i2c_m_sync_init_impl+0x24>
static inline hri_sercomi2cm_ctrla_reg_t hri_sercomi2cm_get_CTRLA_reg(const void *const          hw,
                                                                      hri_sercomi2cm_ctrla_reg_t mask)
{
	uint32_t tmp;
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SWRST | SERCOM_I2CM_SYNCBUSY_ENABLE);
	tmp = ((Sercom *)hw)->I2CM.CTRLA.reg;
    1962:	6823      	ldr	r3, [r4, #0]
		if (hri_sercomi2cm_get_CTRLA_reg(hw, SERCOM_I2CM_CTRLA_ENABLE)) {
    1964:	079b      	lsls	r3, r3, #30
    1966:	d509      	bpl.n	197c <_i2c_m_sync_init_impl+0x44>
	((Sercom *)hw)->I2CM.CTRLA.reg &= ~SERCOM_I2CM_CTRLA_ENABLE;
    1968:	6823      	ldr	r3, [r4, #0]
    196a:	2102      	movs	r1, #2
    196c:	438b      	bics	r3, r1
    196e:	6023      	str	r3, [r4, #0]
	while (((Sercom *)hw)->I2CM.SYNCBUSY.reg & reg) {
    1970:	69e3      	ldr	r3, [r4, #28]
    1972:	079b      	lsls	r3, r3, #30
    1974:	d1fc      	bne.n	1970 <_i2c_m_sync_init_impl+0x38>
    1976:	69e3      	ldr	r3, [r4, #28]
    1978:	079b      	lsls	r3, r3, #30
    197a:	d4fc      	bmi.n	1976 <_i2c_m_sync_init_impl+0x3e>
			hri_sercomi2cm_clear_CTRLA_ENABLE_bit(hw);
			hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_ENABLE);
		}
		hri_sercomi2cm_write_CTRLA_reg(hw, SERCOM_I2CM_CTRLA_SWRST | mode);
    197c:	2301      	movs	r3, #1
    197e:	4313      	orrs	r3, r2
}

static inline void hri_sercomi2cm_write_CTRLA_reg(const void *const hw, hri_sercomi2cm_ctrla_reg_t data)
{
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->I2CM.CTRLA.reg = data;
    1980:	6023      	str	r3, [r4, #0]
	while (((Sercom *)hw)->I2CM.SYNCBUSY.reg & reg) {
    1982:	69e3      	ldr	r3, [r4, #28]
    1984:	079b      	lsls	r3, r3, #30
    1986:	d1fc      	bne.n	1982 <_i2c_m_sync_init_impl+0x4a>
    1988:	69e3      	ldr	r3, [r4, #28]
    198a:	07db      	lsls	r3, r3, #31
    198c:	d4fc      	bmi.n	1988 <_i2c_m_sync_init_impl+0x50>
	}
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SWRST);

	hri_sercomi2cm_write_CTRLA_reg(hw, _i2cms[i].ctrl_a);
    198e:	0043      	lsls	r3, r0, #1
    1990:	181b      	adds	r3, r3, r0
    1992:	00da      	lsls	r2, r3, #3
    1994:	4b1a      	ldr	r3, [pc, #104]	; (1a00 <_i2c_m_sync_init_impl+0xc8>)
    1996:	189b      	adds	r3, r3, r2
    1998:	6b9b      	ldr	r3, [r3, #56]	; 0x38
	((Sercom *)hw)->I2CM.CTRLA.reg = data;
    199a:	6023      	str	r3, [r4, #0]
	while (((Sercom *)hw)->I2CM.SYNCBUSY.reg & reg) {
    199c:	69e3      	ldr	r3, [r4, #28]
    199e:	079b      	lsls	r3, r3, #30
    19a0:	d1fc      	bne.n	199c <_i2c_m_sync_init_impl+0x64>
	hri_sercomi2cm_write_CTRLB_reg(hw, _i2cms[i].ctrl_b);
    19a2:	0043      	lsls	r3, r0, #1
    19a4:	181b      	adds	r3, r3, r0
    19a6:	00da      	lsls	r2, r3, #3
    19a8:	4b15      	ldr	r3, [pc, #84]	; (1a00 <_i2c_m_sync_init_impl+0xc8>)
    19aa:	189b      	adds	r3, r3, r2
    19ac:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
}

static inline void hri_sercomi2cm_write_CTRLB_reg(const void *const hw, hri_sercomi2cm_ctrlb_reg_t data)
{
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->I2CM.CTRLB.reg = data;
    19ae:	6063      	str	r3, [r4, #4]
	while (((Sercom *)hw)->I2CM.SYNCBUSY.reg & reg) {
    19b0:	69e3      	ldr	r3, [r4, #28]
    19b2:	075b      	lsls	r3, r3, #29
    19b4:	d1fc      	bne.n	19b0 <_i2c_m_sync_init_impl+0x78>
	hri_sercomi2cm_write_BAUD_reg(hw, _i2cms[i].baud);
    19b6:	0042      	lsls	r2, r0, #1
    19b8:	1812      	adds	r2, r2, r0
    19ba:	00d1      	lsls	r1, r2, #3
    19bc:	4b10      	ldr	r3, [pc, #64]	; (1a00 <_i2c_m_sync_init_impl+0xc8>)
    19be:	185b      	adds	r3, r3, r1
}

static inline void hri_sercomi2cm_write_BAUD_reg(const void *const hw, hri_sercomi2cm_baud_reg_t data)
{
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->I2CM.BAUD.reg = data;
    19c0:	6c1a      	ldr	r2, [r3, #64]	; 0x40
    19c2:	60e2      	str	r2, [r4, #12]

	service->mode = (_i2cms[i].ctrl_a & SERCOM_I2CM_CTRLA_SPEED_Msk) >> SERCOM_I2CM_CTRLA_SPEED_Pos;
    19c4:	6b9a      	ldr	r2, [r3, #56]	; 0x38
    19c6:	0e12      	lsrs	r2, r2, #24
    19c8:	2303      	movs	r3, #3
    19ca:	401a      	ands	r2, r3
    19cc:	81aa      	strh	r2, [r5, #12]
	hri_sercomi2cm_write_ADDR_HS_bit(hw, service->mode < I2C_HS ? 0 : 1);
    19ce:	3b02      	subs	r3, #2
    19d0:	4293      	cmp	r3, r2
    19d2:	419b      	sbcs	r3, r3
    19d4:	425b      	negs	r3, r3

static inline void hri_sercomi2cm_write_ADDR_HS_bit(const void *const hw, bool value)
{
	uint32_t tmp;
	SERCOM_CRITICAL_SECTION_ENTER();
	tmp = ((Sercom *)hw)->I2CM.ADDR.reg;
    19d6:	6a62      	ldr	r2, [r4, #36]	; 0x24
	tmp &= ~SERCOM_I2CM_ADDR_HS;
    19d8:	490a      	ldr	r1, [pc, #40]	; (1a04 <_i2c_m_sync_init_impl+0xcc>)
    19da:	400a      	ands	r2, r1
	tmp |= value << SERCOM_I2CM_ADDR_HS_Pos;
    19dc:	039b      	lsls	r3, r3, #14
    19de:	4313      	orrs	r3, r2
	((Sercom *)hw)->I2CM.ADDR.reg = tmp;
    19e0:	6263      	str	r3, [r4, #36]	; 0x24
	while (((Sercom *)hw)->I2CM.SYNCBUSY.reg & reg) {
    19e2:	69e3      	ldr	r3, [r4, #28]
    19e4:	075b      	lsls	r3, r3, #29
    19e6:	d4fc      	bmi.n	19e2 <_i2c_m_sync_init_impl+0xaa>

	service->trise = _i2cms[i].trise;
    19e8:	0043      	lsls	r3, r0, #1
    19ea:	1818      	adds	r0, r3, r0
    19ec:	00c2      	lsls	r2, r0, #3
    19ee:	4b04      	ldr	r3, [pc, #16]	; (1a00 <_i2c_m_sync_init_impl+0xc8>)
    19f0:	189b      	adds	r3, r3, r2
    19f2:	3346      	adds	r3, #70	; 0x46
    19f4:	881b      	ldrh	r3, [r3, #0]
    19f6:	81eb      	strh	r3, [r5, #14]

	return ERR_NONE;
}
    19f8:	2000      	movs	r0, #0
    19fa:	bd70      	pop	{r4, r5, r6, pc}
    19fc:	000018ed 	.word	0x000018ed
    1a00:	000027a8 	.word	0x000027a8
    1a04:	ffffbfff 	.word	0xffffbfff

00001a08 <_sercom_i2c_sync_send_address>:
{
    1a08:	b570      	push	{r4, r5, r6, lr}
    1a0a:	0005      	movs	r5, r0
	void *             hw    = i2c_dev->hw;
    1a0c:	6904      	ldr	r4, [r0, #16]
	tmp = ((Sercom *)hw)->I2CM.CTRLA.reg;
    1a0e:	6823      	ldr	r3, [r4, #0]
	tmp = (tmp & SERCOM_I2CM_CTRLA_SCLSM) >> SERCOM_I2CM_CTRLA_SCLSM_Pos;
    1a10:	0edb      	lsrs	r3, r3, #27
    1a12:	2601      	movs	r6, #1
    1a14:	401e      	ands	r6, r3
	ASSERT(i2c_dev);
    1a16:	1e43      	subs	r3, r0, #1
    1a18:	4198      	sbcs	r0, r3
    1a1a:	b2c0      	uxtb	r0, r0
    1a1c:	4a8e      	ldr	r2, [pc, #568]	; (1c58 <_sercom_i2c_sync_send_address+0x250>)
    1a1e:	498f      	ldr	r1, [pc, #572]	; (1c5c <_sercom_i2c_sync_send_address+0x254>)
    1a20:	4b8f      	ldr	r3, [pc, #572]	; (1c60 <_sercom_i2c_sync_send_address+0x258>)
    1a22:	4798      	blx	r3
	if (msg->len == 1 && sclsm) {
    1a24:	686b      	ldr	r3, [r5, #4]
    1a26:	2b01      	cmp	r3, #1
    1a28:	d04d      	beq.n	1ac6 <_sercom_i2c_sync_send_address+0xbe>
	((Sercom *)hw)->I2CM.CTRLB.reg &= ~SERCOM_I2CM_CTRLB_ACKACT;
    1a2a:	6863      	ldr	r3, [r4, #4]
    1a2c:	4a8d      	ldr	r2, [pc, #564]	; (1c64 <_sercom_i2c_sync_send_address+0x25c>)
    1a2e:	4013      	ands	r3, r2
    1a30:	6063      	str	r3, [r4, #4]
	while (((Sercom *)hw)->I2CM.SYNCBUSY.reg & reg) {
    1a32:	69e3      	ldr	r3, [r4, #28]
    1a34:	075b      	lsls	r3, r3, #29
    1a36:	d1fc      	bne.n	1a32 <_sercom_i2c_sync_send_address+0x2a>
	if (msg->addr & I2C_M_TEN) {
    1a38:	882b      	ldrh	r3, [r5, #0]
    1a3a:	055a      	lsls	r2, r3, #21
    1a3c:	d54e      	bpl.n	1adc <_sercom_i2c_sync_send_address+0xd4>
		if (msg->flags & I2C_M_RD) {
    1a3e:	886a      	ldrh	r2, [r5, #2]
    1a40:	07d2      	lsls	r2, r2, #31
    1a42:	d504      	bpl.n	1a4e <_sercom_i2c_sync_send_address+0x46>
			msg->flags |= I2C_M_TEN;
    1a44:	886a      	ldrh	r2, [r5, #2]
    1a46:	2180      	movs	r1, #128	; 0x80
    1a48:	00c9      	lsls	r1, r1, #3
    1a4a:	430a      	orrs	r2, r1
    1a4c:	806a      	strh	r2, [r5, #2]
		                              ((msg->addr & TEN_ADDR_MASK) << 1) | SERCOM_I2CM_ADDR_TENBITEN
    1a4e:	005b      	lsls	r3, r3, #1
		                                  | (hri_sercomi2cm_read_ADDR_reg(hw) & SERCOM_I2CM_ADDR_HS));
    1a50:	4a85      	ldr	r2, [pc, #532]	; (1c68 <_sercom_i2c_sync_send_address+0x260>)
    1a52:	401a      	ands	r2, r3
    1a54:	69e3      	ldr	r3, [r4, #28]
    1a56:	075b      	lsls	r3, r3, #29
    1a58:	d4fc      	bmi.n	1a54 <_sercom_i2c_sync_send_address+0x4c>
}

static inline hri_sercomi2cm_addr_reg_t hri_sercomi2cm_read_ADDR_reg(const void *const hw)
{
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SYSOP);
	return ((Sercom *)hw)->I2CM.ADDR.reg;
    1a5a:	6a63      	ldr	r3, [r4, #36]	; 0x24
    1a5c:	2180      	movs	r1, #128	; 0x80
    1a5e:	01c9      	lsls	r1, r1, #7
    1a60:	400b      	ands	r3, r1
    1a62:	4313      	orrs	r3, r2
		hri_sercomi2cm_write_ADDR_reg(hw,
    1a64:	2280      	movs	r2, #128	; 0x80
    1a66:	0212      	lsls	r2, r2, #8
    1a68:	4313      	orrs	r3, r2
	((Sercom *)hw)->I2CM.ADDR.reg = data;
    1a6a:	6263      	str	r3, [r4, #36]	; 0x24
	while (((Sercom *)hw)->I2CM.SYNCBUSY.reg & reg) {
    1a6c:	69e3      	ldr	r3, [r4, #28]
    1a6e:	075b      	lsls	r3, r3, #29
    1a70:	d4fc      	bmi.n	1a6c <_sercom_i2c_sync_send_address+0x64>
	void *   hw      = i2c_dev->hw;
    1a72:	692e      	ldr	r6, [r5, #16]
	uint32_t timeout = 65535;
    1a74:	4a7d      	ldr	r2, [pc, #500]	; (1c6c <_sercom_i2c_sync_send_address+0x264>)
	return ((Sercom *)hw)->I2CM.INTFLAG.reg;
    1a76:	7e33      	ldrb	r3, [r6, #24]
    1a78:	b2db      	uxtb	r3, r3
		*flags = hri_sercomi2cm_read_INTFLAG_reg(hw);
    1a7a:	0018      	movs	r0, r3
		if (timeout-- == 0) {
    1a7c:	1e51      	subs	r1, r2, #1
    1a7e:	2a00      	cmp	r2, #0
    1a80:	d002      	beq.n	1a88 <_sercom_i2c_sync_send_address+0x80>
    1a82:	000a      	movs	r2, r1
	} while (!(*flags & MB_FLAG) && !(*flags & SB_FLAG));
    1a84:	079b      	lsls	r3, r3, #30
    1a86:	d0f6      	beq.n	1a76 <_sercom_i2c_sync_send_address+0x6e>
	tmp = ((Sercom *)hw)->I2CM.CTRLA.reg;
    1a88:	6823      	ldr	r3, [r4, #0]
	tmp = (tmp & SERCOM_I2CM_CTRLA_SCLSM) >> SERCOM_I2CM_CTRLA_SCLSM_Pos;
    1a8a:	0edb      	lsrs	r3, r3, #27
    1a8c:	2201      	movs	r2, #1
    1a8e:	401a      	ands	r2, r3
	while (((Sercom *)hw)->I2CM.SYNCBUSY.reg & reg) {
    1a90:	69e3      	ldr	r3, [r4, #28]
    1a92:	075b      	lsls	r3, r3, #29
    1a94:	d4fc      	bmi.n	1a90 <_sercom_i2c_sync_send_address+0x88>
}

static inline hri_sercomi2cm_status_reg_t hri_sercomi2cm_read_STATUS_reg(const void *const hw)
{
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SYSOP);
	return ((Sercom *)hw)->I2CM.STATUS.reg;
    1a96:	8b63      	ldrh	r3, [r4, #26]
    1a98:	b29b      	uxth	r3, r3
	if (flags & MB_FLAG) {
    1a9a:	07c1      	lsls	r1, r0, #31
    1a9c:	d400      	bmi.n	1aa0 <_sercom_i2c_sync_send_address+0x98>
    1a9e:	e08f      	b.n	1bc0 <_sercom_i2c_sync_send_address+0x1b8>
		if (status & SERCOM_I2CM_STATUS_ARBLOST) {
    1aa0:	079a      	lsls	r2, r3, #30
    1aa2:	d52f      	bpl.n	1b04 <_sercom_i2c_sync_send_address+0xfc>
	((Sercom *)hw)->I2CM.INTFLAG.reg = SERCOM_I2CM_INTFLAG_MB;
    1aa4:	2201      	movs	r2, #1
    1aa6:	7622      	strb	r2, [r4, #24]
			msg->flags |= I2C_M_FAIL;
    1aa8:	886a      	ldrh	r2, [r5, #2]
    1aaa:	2180      	movs	r1, #128	; 0x80
    1aac:	0149      	lsls	r1, r1, #5
    1aae:	430a      	orrs	r2, r1
    1ab0:	806a      	strh	r2, [r5, #2]
			msg->flags &= ~I2C_M_BUSY;
    1ab2:	886a      	ldrh	r2, [r5, #2]
    1ab4:	496e      	ldr	r1, [pc, #440]	; (1c70 <_sercom_i2c_sync_send_address+0x268>)
    1ab6:	400a      	ands	r2, r1
    1ab8:	806a      	strh	r2, [r5, #2]
			if (status & SERCOM_I2CM_STATUS_BUSERR) {
    1aba:	07db      	lsls	r3, r3, #31
    1abc:	d400      	bmi.n	1ac0 <_sercom_i2c_sync_send_address+0xb8>
    1abe:	e0c6      	b.n	1c4e <_sercom_i2c_sync_send_address+0x246>
				return I2C_ERR_BUS;
    1ac0:	2005      	movs	r0, #5
    1ac2:	4240      	negs	r0, r0
    1ac4:	e0a2      	b.n	1c0c <_sercom_i2c_sync_send_address+0x204>
	if (msg->len == 1 && sclsm) {
    1ac6:	2e00      	cmp	r6, #0
    1ac8:	d0af      	beq.n	1a2a <_sercom_i2c_sync_send_address+0x22>
	((Sercom *)hw)->I2CM.CTRLB.reg |= SERCOM_I2CM_CTRLB_ACKACT;
    1aca:	6862      	ldr	r2, [r4, #4]
    1acc:	2380      	movs	r3, #128	; 0x80
    1ace:	02db      	lsls	r3, r3, #11
    1ad0:	4313      	orrs	r3, r2
    1ad2:	6063      	str	r3, [r4, #4]
	while (((Sercom *)hw)->I2CM.SYNCBUSY.reg & reg) {
    1ad4:	69e3      	ldr	r3, [r4, #28]
    1ad6:	075b      	lsls	r3, r3, #29
    1ad8:	d1fc      	bne.n	1ad4 <_sercom_i2c_sync_send_address+0xcc>
    1ada:	e7ad      	b.n	1a38 <_sercom_i2c_sync_send_address+0x30>
		                              ((msg->addr & SEVEN_ADDR_MASK) << 1) | (msg->flags & I2C_M_RD ? I2C_M_RD : 0x0)
    1adc:	005b      	lsls	r3, r3, #1
    1ade:	22ff      	movs	r2, #255	; 0xff
    1ae0:	4013      	ands	r3, r2
    1ae2:	886a      	ldrh	r2, [r5, #2]
    1ae4:	2101      	movs	r1, #1
    1ae6:	400a      	ands	r2, r1
    1ae8:	431a      	orrs	r2, r3
    1aea:	69e3      	ldr	r3, [r4, #28]
    1aec:	075b      	lsls	r3, r3, #29
    1aee:	d4fc      	bmi.n	1aea <_sercom_i2c_sync_send_address+0xe2>
	return ((Sercom *)hw)->I2CM.ADDR.reg;
    1af0:	6a63      	ldr	r3, [r4, #36]	; 0x24
		                                  | (hri_sercomi2cm_read_ADDR_reg(hw) & SERCOM_I2CM_ADDR_HS));
    1af2:	2180      	movs	r1, #128	; 0x80
    1af4:	01c9      	lsls	r1, r1, #7
    1af6:	400b      	ands	r3, r1
		hri_sercomi2cm_write_ADDR_reg(hw,
    1af8:	4313      	orrs	r3, r2
	((Sercom *)hw)->I2CM.ADDR.reg = data;
    1afa:	6263      	str	r3, [r4, #36]	; 0x24
	while (((Sercom *)hw)->I2CM.SYNCBUSY.reg & reg) {
    1afc:	69e3      	ldr	r3, [r4, #28]
    1afe:	075b      	lsls	r3, r3, #29
    1b00:	d4fc      	bmi.n	1afc <_sercom_i2c_sync_send_address+0xf4>
    1b02:	e7b6      	b.n	1a72 <_sercom_i2c_sync_send_address+0x6a>
			if (status & SERCOM_I2CM_STATUS_RXNACK) {
    1b04:	075b      	lsls	r3, r3, #29
    1b06:	d41b      	bmi.n	1b40 <_sercom_i2c_sync_send_address+0x138>
			if (msg->flags & I2C_M_TEN) {
    1b08:	886b      	ldrh	r3, [r5, #2]
    1b0a:	055b      	lsls	r3, r3, #21
    1b0c:	d534      	bpl.n	1b78 <_sercom_i2c_sync_send_address+0x170>
				                              ((((msg->addr & TEN_ADDR_MASK) >> 8) | TEN_ADDR_FRAME) << 1) | I2C_M_RD
    1b0e:	882a      	ldrh	r2, [r5, #0]
    1b10:	1212      	asrs	r2, r2, #8
    1b12:	0052      	lsls	r2, r2, #1
				                                  | (hri_sercomi2cm_read_ADDR_reg(hw) & SERCOM_I2CM_ADDR_HS));
    1b14:	2306      	movs	r3, #6
    1b16:	401a      	ands	r2, r3
    1b18:	69e3      	ldr	r3, [r4, #28]
    1b1a:	075b      	lsls	r3, r3, #29
    1b1c:	d4fc      	bmi.n	1b18 <_sercom_i2c_sync_send_address+0x110>
	return ((Sercom *)hw)->I2CM.ADDR.reg;
    1b1e:	6a63      	ldr	r3, [r4, #36]	; 0x24
    1b20:	2180      	movs	r1, #128	; 0x80
    1b22:	01c9      	lsls	r1, r1, #7
    1b24:	400b      	ands	r3, r1
    1b26:	4313      	orrs	r3, r2
				hri_sercomi2cm_write_ADDR_reg(hw,
    1b28:	22f1      	movs	r2, #241	; 0xf1
    1b2a:	4313      	orrs	r3, r2
	((Sercom *)hw)->I2CM.ADDR.reg = data;
    1b2c:	6263      	str	r3, [r4, #36]	; 0x24
	while (((Sercom *)hw)->I2CM.SYNCBUSY.reg & reg) {
    1b2e:	69e3      	ldr	r3, [r4, #28]
    1b30:	075b      	lsls	r3, r3, #29
    1b32:	d4fc      	bmi.n	1b2e <_sercom_i2c_sync_send_address+0x126>
				msg->flags &= ~I2C_M_TEN;
    1b34:	886b      	ldrh	r3, [r5, #2]
    1b36:	4a4f      	ldr	r2, [pc, #316]	; (1c74 <_sercom_i2c_sync_send_address+0x26c>)
    1b38:	4013      	ands	r3, r2
    1b3a:	806b      	strh	r3, [r5, #2]
				return I2C_OK;
    1b3c:	2000      	movs	r0, #0
    1b3e:	e065      	b.n	1c0c <_sercom_i2c_sync_send_address+0x204>
				if (msg->len > 0) {
    1b40:	686b      	ldr	r3, [r5, #4]
    1b42:	2b00      	cmp	r3, #0
    1b44:	dd04      	ble.n	1b50 <_sercom_i2c_sync_send_address+0x148>
					msg->flags |= I2C_M_FAIL;
    1b46:	886b      	ldrh	r3, [r5, #2]
    1b48:	2280      	movs	r2, #128	; 0x80
    1b4a:	0152      	lsls	r2, r2, #5
    1b4c:	4313      	orrs	r3, r2
    1b4e:	806b      	strh	r3, [r5, #2]
				if (msg->flags & I2C_M_STOP) {
    1b50:	886b      	ldrh	r3, [r5, #2]
    1b52:	b21b      	sxth	r3, r3
    1b54:	2b00      	cmp	r3, #0
    1b56:	db06      	blt.n	1b66 <_sercom_i2c_sync_send_address+0x15e>
				msg->flags &= ~I2C_M_BUSY;
    1b58:	886b      	ldrh	r3, [r5, #2]
    1b5a:	4a45      	ldr	r2, [pc, #276]	; (1c70 <_sercom_i2c_sync_send_address+0x268>)
    1b5c:	4013      	ands	r3, r2
    1b5e:	806b      	strh	r3, [r5, #2]
				return I2C_NACK;
    1b60:	2002      	movs	r0, #2
    1b62:	4240      	negs	r0, r0
    1b64:	e052      	b.n	1c0c <_sercom_i2c_sync_send_address+0x204>
	((Sercom *)hw)->I2CM.CTRLB.reg |= SERCOM_I2CM_CTRLB_CMD(mask);
    1b66:	6862      	ldr	r2, [r4, #4]
    1b68:	23c0      	movs	r3, #192	; 0xc0
    1b6a:	029b      	lsls	r3, r3, #10
    1b6c:	4313      	orrs	r3, r2
    1b6e:	6063      	str	r3, [r4, #4]
	while (((Sercom *)hw)->I2CM.SYNCBUSY.reg & reg) {
    1b70:	69e3      	ldr	r3, [r4, #28]
    1b72:	075b      	lsls	r3, r3, #29
    1b74:	d4fc      	bmi.n	1b70 <_sercom_i2c_sync_send_address+0x168>
    1b76:	e7ef      	b.n	1b58 <_sercom_i2c_sync_send_address+0x150>
			if (msg->len == 0) {
    1b78:	6868      	ldr	r0, [r5, #4]
    1b7a:	2800      	cmp	r0, #0
    1b7c:	d111      	bne.n	1ba2 <_sercom_i2c_sync_send_address+0x19a>
				if (msg->flags & I2C_M_STOP) {
    1b7e:	886b      	ldrh	r3, [r5, #2]
    1b80:	b21b      	sxth	r3, r3
    1b82:	2b00      	cmp	r3, #0
    1b84:	db04      	blt.n	1b90 <_sercom_i2c_sync_send_address+0x188>
				msg->flags &= ~I2C_M_BUSY;
    1b86:	886b      	ldrh	r3, [r5, #2]
    1b88:	4a39      	ldr	r2, [pc, #228]	; (1c70 <_sercom_i2c_sync_send_address+0x268>)
    1b8a:	4013      	ands	r3, r2
    1b8c:	806b      	strh	r3, [r5, #2]
    1b8e:	e03d      	b.n	1c0c <_sercom_i2c_sync_send_address+0x204>
	((Sercom *)hw)->I2CM.CTRLB.reg |= SERCOM_I2CM_CTRLB_CMD(mask);
    1b90:	6862      	ldr	r2, [r4, #4]
    1b92:	23c0      	movs	r3, #192	; 0xc0
    1b94:	029b      	lsls	r3, r3, #10
    1b96:	4313      	orrs	r3, r2
    1b98:	6063      	str	r3, [r4, #4]
	while (((Sercom *)hw)->I2CM.SYNCBUSY.reg & reg) {
    1b9a:	69e3      	ldr	r3, [r4, #28]
    1b9c:	075b      	lsls	r3, r3, #29
    1b9e:	d4fc      	bmi.n	1b9a <_sercom_i2c_sync_send_address+0x192>
    1ba0:	e7f1      	b.n	1b86 <_sercom_i2c_sync_send_address+0x17e>
				hri_sercomi2cm_write_DATA_reg(hw, *msg->buffer);
    1ba2:	68ab      	ldr	r3, [r5, #8]
    1ba4:	781a      	ldrb	r2, [r3, #0]
	((Sercom *)hw)->I2CM.DATA.reg = data;
    1ba6:	2328      	movs	r3, #40	; 0x28
    1ba8:	54e2      	strb	r2, [r4, r3]
	while (((Sercom *)hw)->I2CM.SYNCBUSY.reg & reg) {
    1baa:	69e3      	ldr	r3, [r4, #28]
    1bac:	075b      	lsls	r3, r3, #29
    1bae:	d4fc      	bmi.n	1baa <_sercom_i2c_sync_send_address+0x1a2>
				msg->buffer++;
    1bb0:	68ab      	ldr	r3, [r5, #8]
    1bb2:	3301      	adds	r3, #1
    1bb4:	60ab      	str	r3, [r5, #8]
				msg->len--;
    1bb6:	686b      	ldr	r3, [r5, #4]
    1bb8:	3b01      	subs	r3, #1
    1bba:	606b      	str	r3, [r5, #4]
			return I2C_OK;
    1bbc:	2000      	movs	r0, #0
    1bbe:	e025      	b.n	1c0c <_sercom_i2c_sync_send_address+0x204>
	} else if (flags & SB_FLAG) {
    1bc0:	0781      	lsls	r1, r0, #30
    1bc2:	d547      	bpl.n	1c54 <_sercom_i2c_sync_send_address+0x24c>
		if ((msg->len) && !(status & SERCOM_I2CM_STATUS_RXNACK)) {
    1bc4:	6869      	ldr	r1, [r5, #4]
    1bc6:	2900      	cmp	r1, #0
    1bc8:	d03c      	beq.n	1c44 <_sercom_i2c_sync_send_address+0x23c>
    1bca:	075b      	lsls	r3, r3, #29
    1bcc:	d43a      	bmi.n	1c44 <_sercom_i2c_sync_send_address+0x23c>
			msg->len--;
    1bce:	3901      	subs	r1, #1
    1bd0:	6069      	str	r1, [r5, #4]
			if ((msg->len == 0 && !sclsm) || (msg->len == 1 && sclsm)) {
    1bd2:	2900      	cmp	r1, #0
    1bd4:	d101      	bne.n	1bda <_sercom_i2c_sync_send_address+0x1d2>
    1bd6:	2a00      	cmp	r2, #0
    1bd8:	d01b      	beq.n	1c12 <_sercom_i2c_sync_send_address+0x20a>
    1bda:	2901      	cmp	r1, #1
    1bdc:	d017      	beq.n	1c0e <_sercom_i2c_sync_send_address+0x206>
			if (msg->len == 0) {
    1bde:	686b      	ldr	r3, [r5, #4]
    1be0:	2b00      	cmp	r3, #0
    1be2:	d107      	bne.n	1bf4 <_sercom_i2c_sync_send_address+0x1ec>
				if (msg->flags & I2C_M_STOP) {
    1be4:	886b      	ldrh	r3, [r5, #2]
    1be6:	b21b      	sxth	r3, r3
    1be8:	2b00      	cmp	r3, #0
    1bea:	db1b      	blt.n	1c24 <_sercom_i2c_sync_send_address+0x21c>
				msg->flags &= ~I2C_M_BUSY;
    1bec:	886b      	ldrh	r3, [r5, #2]
    1bee:	4a20      	ldr	r2, [pc, #128]	; (1c70 <_sercom_i2c_sync_send_address+0x268>)
    1bf0:	4013      	ands	r3, r2
    1bf2:	806b      	strh	r3, [r5, #2]
			*msg->buffer++ = hri_sercomi2cm_read_DATA_reg(hw);
    1bf4:	68aa      	ldr	r2, [r5, #8]
    1bf6:	1c53      	adds	r3, r2, #1
    1bf8:	60ab      	str	r3, [r5, #8]
    1bfa:	69e3      	ldr	r3, [r4, #28]
    1bfc:	075b      	lsls	r3, r3, #29
    1bfe:	d4fc      	bmi.n	1bfa <_sercom_i2c_sync_send_address+0x1f2>
	return ((Sercom *)hw)->I2CM.DATA.reg;
    1c00:	2328      	movs	r3, #40	; 0x28
    1c02:	5ce3      	ldrb	r3, [r4, r3]
    1c04:	7013      	strb	r3, [r2, #0]
	((Sercom *)hw)->I2CM.INTFLAG.reg = SERCOM_I2CM_INTFLAG_SB;
    1c06:	2302      	movs	r3, #2
    1c08:	7623      	strb	r3, [r4, #24]
	return I2C_OK;
    1c0a:	2000      	movs	r0, #0
}
    1c0c:	bd70      	pop	{r4, r5, r6, pc}
			if ((msg->len == 0 && !sclsm) || (msg->len == 1 && sclsm)) {
    1c0e:	2a00      	cmp	r2, #0
    1c10:	d0e5      	beq.n	1bde <_sercom_i2c_sync_send_address+0x1d6>
	((Sercom *)hw)->I2CM.CTRLB.reg |= SERCOM_I2CM_CTRLB_ACKACT;
    1c12:	6862      	ldr	r2, [r4, #4]
    1c14:	2380      	movs	r3, #128	; 0x80
    1c16:	02db      	lsls	r3, r3, #11
    1c18:	4313      	orrs	r3, r2
    1c1a:	6063      	str	r3, [r4, #4]
	while (((Sercom *)hw)->I2CM.SYNCBUSY.reg & reg) {
    1c1c:	69e3      	ldr	r3, [r4, #28]
    1c1e:	075b      	lsls	r3, r3, #29
    1c20:	d1fc      	bne.n	1c1c <_sercom_i2c_sync_send_address+0x214>
    1c22:	e7dc      	b.n	1bde <_sercom_i2c_sync_send_address+0x1d6>
	((Sercom *)hw)->I2CM.CTRLB.reg &= ~SERCOM_I2CM_CTRLB_SMEN;
    1c24:	6863      	ldr	r3, [r4, #4]
    1c26:	4a12      	ldr	r2, [pc, #72]	; (1c70 <_sercom_i2c_sync_send_address+0x268>)
    1c28:	4013      	ands	r3, r2
    1c2a:	6063      	str	r3, [r4, #4]
	while (((Sercom *)hw)->I2CM.SYNCBUSY.reg & reg) {
    1c2c:	69e3      	ldr	r3, [r4, #28]
    1c2e:	075b      	lsls	r3, r3, #29
    1c30:	d1fc      	bne.n	1c2c <_sercom_i2c_sync_send_address+0x224>
	((Sercom *)hw)->I2CM.CTRLB.reg |= SERCOM_I2CM_CTRLB_CMD(mask);
    1c32:	6862      	ldr	r2, [r4, #4]
    1c34:	23c0      	movs	r3, #192	; 0xc0
    1c36:	029b      	lsls	r3, r3, #10
    1c38:	4313      	orrs	r3, r2
    1c3a:	6063      	str	r3, [r4, #4]
	while (((Sercom *)hw)->I2CM.SYNCBUSY.reg & reg) {
    1c3c:	69e3      	ldr	r3, [r4, #28]
    1c3e:	075b      	lsls	r3, r3, #29
    1c40:	d4fc      	bmi.n	1c3c <_sercom_i2c_sync_send_address+0x234>
    1c42:	e7d3      	b.n	1bec <_sercom_i2c_sync_send_address+0x1e4>
	((Sercom *)hw)->I2CM.INTFLAG.reg = SERCOM_I2CM_INTFLAG_SB;
    1c44:	2302      	movs	r3, #2
    1c46:	7623      	strb	r3, [r4, #24]
			return I2C_NACK;
    1c48:	2002      	movs	r0, #2
    1c4a:	4240      	negs	r0, r0
    1c4c:	e7de      	b.n	1c0c <_sercom_i2c_sync_send_address+0x204>
			return I2C_ERR_BAD_ADDRESS;
    1c4e:	2004      	movs	r0, #4
    1c50:	4240      	negs	r0, r0
    1c52:	e7db      	b.n	1c0c <_sercom_i2c_sync_send_address+0x204>
	return I2C_OK;
    1c54:	2000      	movs	r0, #0
	return _sercom_i2c_sync_analyse_flags(hw, flags, msg);
    1c56:	e7d9      	b.n	1c0c <_sercom_i2c_sync_send_address+0x204>
    1c58:	0000059b 	.word	0x0000059b
    1c5c:	00002860 	.word	0x00002860
    1c60:	0000138d 	.word	0x0000138d
    1c64:	fffbffff 	.word	0xfffbffff
    1c68:	000007fe 	.word	0x000007fe
    1c6c:	0000ffff 	.word	0x0000ffff
    1c70:	fffffeff 	.word	0xfffffeff
    1c74:	fffffbff 	.word	0xfffffbff

00001c78 <_i2c_m_sync_init>:
{
    1c78:	b570      	push	{r4, r5, r6, lr}
    1c7a:	0004      	movs	r4, r0
    1c7c:	000d      	movs	r5, r1
	ASSERT(i2c_dev);
    1c7e:	1e43      	subs	r3, r0, #1
    1c80:	4198      	sbcs	r0, r3
    1c82:	b2c0      	uxtb	r0, r0
    1c84:	4a04      	ldr	r2, [pc, #16]	; (1c98 <_i2c_m_sync_init+0x20>)
    1c86:	4905      	ldr	r1, [pc, #20]	; (1c9c <_i2c_m_sync_init+0x24>)
    1c88:	4b05      	ldr	r3, [pc, #20]	; (1ca0 <_i2c_m_sync_init+0x28>)
    1c8a:	4798      	blx	r3
	i2c_dev->hw = hw;
    1c8c:	6125      	str	r5, [r4, #16]
	return _i2c_m_sync_init_impl(&i2c_dev->service, hw);
    1c8e:	0029      	movs	r1, r5
    1c90:	0020      	movs	r0, r4
    1c92:	4b04      	ldr	r3, [pc, #16]	; (1ca4 <_i2c_m_sync_init+0x2c>)
    1c94:	4798      	blx	r3
}
    1c96:	bd70      	pop	{r4, r5, r6, pc}
    1c98:	0000050e 	.word	0x0000050e
    1c9c:	00002860 	.word	0x00002860
    1ca0:	0000138d 	.word	0x0000138d
    1ca4:	00001939 	.word	0x00001939

00001ca8 <_i2c_m_sync_enable>:
{
    1ca8:	b570      	push	{r4, r5, r6, lr}
    1caa:	0004      	movs	r4, r0
	ASSERT(i2c_dev);
    1cac:	4d19      	ldr	r5, [pc, #100]	; (1d14 <_i2c_m_sync_enable+0x6c>)
    1cae:	1e43      	subs	r3, r0, #1
    1cb0:	4198      	sbcs	r0, r3
    1cb2:	b2c0      	uxtb	r0, r0
    1cb4:	4a18      	ldr	r2, [pc, #96]	; (1d18 <_i2c_m_sync_enable+0x70>)
    1cb6:	0029      	movs	r1, r5
    1cb8:	4e18      	ldr	r6, [pc, #96]	; (1d1c <_i2c_m_sync_enable+0x74>)
    1cba:	47b0      	blx	r6
	return _i2c_m_enable_implementation(i2c_dev->hw);
    1cbc:	6924      	ldr	r4, [r4, #16]
	ASSERT(hw);
    1cbe:	0020      	movs	r0, r4
    1cc0:	1e43      	subs	r3, r0, #1
    1cc2:	4198      	sbcs	r0, r3
    1cc4:	b2c0      	uxtb	r0, r0
    1cc6:	4a16      	ldr	r2, [pc, #88]	; (1d20 <_i2c_m_sync_enable+0x78>)
    1cc8:	0029      	movs	r1, r5
    1cca:	47b0      	blx	r6
	((Sercom *)hw)->I2CM.CTRLA.reg |= SERCOM_I2CM_CTRLA_ENABLE;
    1ccc:	6823      	ldr	r3, [r4, #0]
    1cce:	2202      	movs	r2, #2
    1cd0:	4313      	orrs	r3, r2
    1cd2:	6023      	str	r3, [r4, #0]
	while (((Sercom *)hw)->I2CM.SYNCBUSY.reg & reg) {
    1cd4:	69e3      	ldr	r3, [r4, #28]
    1cd6:	079b      	lsls	r3, r3, #30
    1cd8:	d1fc      	bne.n	1cd4 <_i2c_m_sync_enable+0x2c>
    1cda:	2004      	movs	r0, #4
    1cdc:	4911      	ldr	r1, [pc, #68]	; (1d24 <_i2c_m_sync_enable+0x7c>)
    1cde:	69e3      	ldr	r3, [r4, #28]
    1ce0:	075b      	lsls	r3, r3, #29
    1ce2:	d4fc      	bmi.n	1cde <_i2c_m_sync_enable+0x36>
	return (((Sercom *)hw)->I2CM.STATUS.reg & SERCOM_I2CM_STATUS_BUSSTATE_Msk) >> SERCOM_I2CM_STATUS_BUSSTATE_Pos;
    1ce4:	8b62      	ldrh	r2, [r4, #26]
    1ce6:	0912      	lsrs	r2, r2, #4
    1ce8:	2303      	movs	r3, #3
    1cea:	4013      	ands	r3, r2
	while (hri_sercomi2cm_read_STATUS_BUSSTATE_bf(hw) != I2C_IDLE) {
    1cec:	2b01      	cmp	r3, #1
    1cee:	d00b      	beq.n	1d08 <_i2c_m_sync_enable+0x60>
		timeout--;
    1cf0:	3901      	subs	r1, #1
		if (timeout <= 0) {
    1cf2:	2900      	cmp	r1, #0
    1cf4:	dcf3      	bgt.n	1cde <_i2c_m_sync_enable+0x36>
			if (--timeout_attempt)
    1cf6:	3801      	subs	r0, #1
    1cf8:	2800      	cmp	r0, #0
    1cfa:	d007      	beq.n	1d0c <_i2c_m_sync_enable+0x64>
}

static inline void hri_sercomi2cm_clear_STATUS_reg(const void *const hw, hri_sercomi2cm_status_reg_t mask)
{
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->I2CM.STATUS.reg = mask;
    1cfc:	2310      	movs	r3, #16
    1cfe:	8363      	strh	r3, [r4, #26]
	while (((Sercom *)hw)->I2CM.SYNCBUSY.reg & reg) {
    1d00:	69e3      	ldr	r3, [r4, #28]
    1d02:	075b      	lsls	r3, r3, #29
    1d04:	d4fc      	bmi.n	1d00 <_i2c_m_sync_enable+0x58>
    1d06:	e7e9      	b.n	1cdc <_i2c_m_sync_enable+0x34>
	return ERR_NONE;
    1d08:	2000      	movs	r0, #0
}
    1d0a:	bd70      	pop	{r4, r5, r6, pc}
				return I2C_ERR_BUSY;
    1d0c:	2006      	movs	r0, #6
    1d0e:	4240      	negs	r0, r0
	return _i2c_m_enable_implementation(i2c_dev->hw);
    1d10:	e7fb      	b.n	1d0a <_i2c_m_sync_enable+0x62>
    1d12:	46c0      	nop			; (mov r8, r8)
    1d14:	00002860 	.word	0x00002860
    1d18:	0000052b 	.word	0x0000052b
    1d1c:	0000138d 	.word	0x0000138d
    1d20:	000005fb 	.word	0x000005fb
    1d24:	0000ffff 	.word	0x0000ffff

00001d28 <_i2c_m_sync_transfer>:
{
    1d28:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    1d2a:	0005      	movs	r5, r0
    1d2c:	000e      	movs	r6, r1
	void *   hw = i2c_dev->hw;
    1d2e:	6904      	ldr	r4, [r0, #16]
	ASSERT(i2c_dev);
    1d30:	1e43      	subs	r3, r0, #1
    1d32:	4198      	sbcs	r0, r3
    1d34:	b2c0      	uxtb	r0, r0
    1d36:	4a93      	ldr	r2, [pc, #588]	; (1f84 <_i2c_m_sync_transfer+0x25c>)
    1d38:	4993      	ldr	r1, [pc, #588]	; (1f88 <_i2c_m_sync_transfer+0x260>)
    1d3a:	4f94      	ldr	r7, [pc, #592]	; (1f8c <_i2c_m_sync_transfer+0x264>)
    1d3c:	47b8      	blx	r7
	ASSERT(i2c_dev->hw);
    1d3e:	6928      	ldr	r0, [r5, #16]
    1d40:	1e43      	subs	r3, r0, #1
    1d42:	4198      	sbcs	r0, r3
    1d44:	b2c0      	uxtb	r0, r0
    1d46:	4a92      	ldr	r2, [pc, #584]	; (1f90 <_i2c_m_sync_transfer+0x268>)
    1d48:	498f      	ldr	r1, [pc, #572]	; (1f88 <_i2c_m_sync_transfer+0x260>)
    1d4a:	47b8      	blx	r7
	ASSERT(msg);
    1d4c:	0030      	movs	r0, r6
    1d4e:	1e43      	subs	r3, r0, #1
    1d50:	4198      	sbcs	r0, r3
    1d52:	b2c0      	uxtb	r0, r0
    1d54:	22b9      	movs	r2, #185	; 0xb9
    1d56:	00d2      	lsls	r2, r2, #3
    1d58:	498b      	ldr	r1, [pc, #556]	; (1f88 <_i2c_m_sync_transfer+0x260>)
    1d5a:	47b8      	blx	r7
	if (i2c_dev->service.msg.flags & I2C_M_BUSY) {
    1d5c:	886b      	ldrh	r3, [r5, #2]
    1d5e:	05db      	lsls	r3, r3, #23
    1d60:	d500      	bpl.n	1d64 <_i2c_m_sync_transfer+0x3c>
    1d62:	e10b      	b.n	1f7c <_i2c_m_sync_transfer+0x254>
	msg->flags |= I2C_M_BUSY;
    1d64:	8872      	ldrh	r2, [r6, #2]
    1d66:	2380      	movs	r3, #128	; 0x80
    1d68:	005b      	lsls	r3, r3, #1
    1d6a:	469c      	mov	ip, r3
    1d6c:	431a      	orrs	r2, r3
    1d6e:	8072      	strh	r2, [r6, #2]
	i2c_dev->service.msg = *msg;
    1d70:	002a      	movs	r2, r5
    1d72:	0031      	movs	r1, r6
    1d74:	c989      	ldmia	r1!, {r0, r3, r7}
    1d76:	c289      	stmia	r2!, {r0, r3, r7}
	((Sercom *)hw)->I2CM.CTRLB.reg |= SERCOM_I2CM_CTRLB_SMEN;
    1d78:	6862      	ldr	r2, [r4, #4]
    1d7a:	4663      	mov	r3, ip
    1d7c:	4313      	orrs	r3, r2
    1d7e:	6063      	str	r3, [r4, #4]
	while (((Sercom *)hw)->I2CM.SYNCBUSY.reg & reg) {
    1d80:	69e3      	ldr	r3, [r4, #28]
    1d82:	075b      	lsls	r3, r3, #29
    1d84:	d1fc      	bne.n	1d80 <_i2c_m_sync_transfer+0x58>
	ret = _sercom_i2c_sync_send_address(i2c_dev);
    1d86:	0028      	movs	r0, r5
    1d88:	4b82      	ldr	r3, [pc, #520]	; (1f94 <_i2c_m_sync_transfer+0x26c>)
    1d8a:	4798      	blx	r3
	if (ret) {
    1d8c:	2800      	cmp	r0, #0
    1d8e:	d100      	bne.n	1d92 <_i2c_m_sync_transfer+0x6a>
    1d90:	e09d      	b.n	1ece <_i2c_m_sync_transfer+0x1a6>
		i2c_dev->service.msg.flags &= ~I2C_M_BUSY;
    1d92:	886b      	ldrh	r3, [r5, #2]
    1d94:	4a80      	ldr	r2, [pc, #512]	; (1f98 <_i2c_m_sync_transfer+0x270>)
    1d96:	4013      	ands	r3, r2
    1d98:	806b      	strh	r3, [r5, #2]
}
    1d9a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			return I2C_ERR_BUS;
    1d9c:	2005      	movs	r0, #5
    1d9e:	4240      	negs	r0, r0
    1da0:	e0a6      	b.n	1ef0 <_i2c_m_sync_transfer+0x1c8>
			if (msg->flags & I2C_M_STOP) {
    1da2:	8873      	ldrh	r3, [r6, #2]
    1da4:	b21b      	sxth	r3, r3
    1da6:	2b00      	cmp	r3, #0
    1da8:	db04      	blt.n	1db4 <_i2c_m_sync_transfer+0x8c>
			i2c_dev->service.msg.flags &= ~I2C_M_BUSY;
    1daa:	886b      	ldrh	r3, [r5, #2]
    1dac:	4a7a      	ldr	r2, [pc, #488]	; (1f98 <_i2c_m_sync_transfer+0x270>)
    1dae:	4013      	ands	r3, r2
    1db0:	806b      	strh	r3, [r5, #2]
			return ret;
    1db2:	e7f2      	b.n	1d9a <_i2c_m_sync_transfer+0x72>
	((Sercom *)hw)->I2CM.CTRLB.reg |= SERCOM_I2CM_CTRLB_CMD(mask);
    1db4:	6862      	ldr	r2, [r4, #4]
    1db6:	23c0      	movs	r3, #192	; 0xc0
    1db8:	029b      	lsls	r3, r3, #10
    1dba:	4313      	orrs	r3, r2
    1dbc:	6063      	str	r3, [r4, #4]
	while (((Sercom *)hw)->I2CM.SYNCBUSY.reg & reg) {
    1dbe:	69e3      	ldr	r3, [r4, #28]
    1dc0:	075b      	lsls	r3, r3, #29
    1dc2:	d4fc      	bmi.n	1dbe <_i2c_m_sync_transfer+0x96>
    1dc4:	e7f1      	b.n	1daa <_i2c_m_sync_transfer+0x82>
			if (status & SERCOM_I2CM_STATUS_RXNACK) {
    1dc6:	0753      	lsls	r3, r2, #29
    1dc8:	d41b      	bmi.n	1e02 <_i2c_m_sync_transfer+0xda>
			if (msg->flags & I2C_M_TEN) {
    1dca:	886b      	ldrh	r3, [r5, #2]
    1dcc:	055b      	lsls	r3, r3, #21
    1dce:	d534      	bpl.n	1e3a <_i2c_m_sync_transfer+0x112>
				                              ((((msg->addr & TEN_ADDR_MASK) >> 8) | TEN_ADDR_FRAME) << 1) | I2C_M_RD
    1dd0:	882a      	ldrh	r2, [r5, #0]
    1dd2:	1212      	asrs	r2, r2, #8
    1dd4:	0052      	lsls	r2, r2, #1
				                                  | (hri_sercomi2cm_read_ADDR_reg(hw) & SERCOM_I2CM_ADDR_HS));
    1dd6:	2306      	movs	r3, #6
    1dd8:	401a      	ands	r2, r3
    1dda:	69e3      	ldr	r3, [r4, #28]
    1ddc:	075b      	lsls	r3, r3, #29
    1dde:	d4fc      	bmi.n	1dda <_i2c_m_sync_transfer+0xb2>
	return ((Sercom *)hw)->I2CM.ADDR.reg;
    1de0:	6a63      	ldr	r3, [r4, #36]	; 0x24
    1de2:	2180      	movs	r1, #128	; 0x80
    1de4:	01c9      	lsls	r1, r1, #7
    1de6:	400b      	ands	r3, r1
    1de8:	4313      	orrs	r3, r2
				hri_sercomi2cm_write_ADDR_reg(hw,
    1dea:	22f1      	movs	r2, #241	; 0xf1
    1dec:	4313      	orrs	r3, r2
	((Sercom *)hw)->I2CM.ADDR.reg = data;
    1dee:	6263      	str	r3, [r4, #36]	; 0x24
	while (((Sercom *)hw)->I2CM.SYNCBUSY.reg & reg) {
    1df0:	69e3      	ldr	r3, [r4, #28]
    1df2:	075b      	lsls	r3, r3, #29
    1df4:	d4fc      	bmi.n	1df0 <_i2c_m_sync_transfer+0xc8>
				msg->flags &= ~I2C_M_TEN;
    1df6:	886b      	ldrh	r3, [r5, #2]
    1df8:	4a68      	ldr	r2, [pc, #416]	; (1f9c <_i2c_m_sync_transfer+0x274>)
    1dfa:	4013      	ands	r3, r2
    1dfc:	806b      	strh	r3, [r5, #2]
				return I2C_OK;
    1dfe:	2000      	movs	r0, #0
    1e00:	e065      	b.n	1ece <_i2c_m_sync_transfer+0x1a6>
				if (msg->len > 0) {
    1e02:	686b      	ldr	r3, [r5, #4]
    1e04:	2b00      	cmp	r3, #0
    1e06:	dd04      	ble.n	1e12 <_i2c_m_sync_transfer+0xea>
					msg->flags |= I2C_M_FAIL;
    1e08:	886b      	ldrh	r3, [r5, #2]
    1e0a:	2280      	movs	r2, #128	; 0x80
    1e0c:	0152      	lsls	r2, r2, #5
    1e0e:	4313      	orrs	r3, r2
    1e10:	806b      	strh	r3, [r5, #2]
				if (msg->flags & I2C_M_STOP) {
    1e12:	886b      	ldrh	r3, [r5, #2]
    1e14:	b21b      	sxth	r3, r3
    1e16:	2b00      	cmp	r3, #0
    1e18:	db06      	blt.n	1e28 <_i2c_m_sync_transfer+0x100>
				msg->flags &= ~I2C_M_BUSY;
    1e1a:	886b      	ldrh	r3, [r5, #2]
    1e1c:	4a5e      	ldr	r2, [pc, #376]	; (1f98 <_i2c_m_sync_transfer+0x270>)
    1e1e:	4013      	ands	r3, r2
    1e20:	806b      	strh	r3, [r5, #2]
				return I2C_NACK;
    1e22:	2002      	movs	r0, #2
    1e24:	4240      	negs	r0, r0
    1e26:	e052      	b.n	1ece <_i2c_m_sync_transfer+0x1a6>
	((Sercom *)hw)->I2CM.CTRLB.reg |= SERCOM_I2CM_CTRLB_CMD(mask);
    1e28:	6862      	ldr	r2, [r4, #4]
    1e2a:	23c0      	movs	r3, #192	; 0xc0
    1e2c:	029b      	lsls	r3, r3, #10
    1e2e:	4313      	orrs	r3, r2
    1e30:	6063      	str	r3, [r4, #4]
	while (((Sercom *)hw)->I2CM.SYNCBUSY.reg & reg) {
    1e32:	69e3      	ldr	r3, [r4, #28]
    1e34:	075b      	lsls	r3, r3, #29
    1e36:	d4fc      	bmi.n	1e32 <_i2c_m_sync_transfer+0x10a>
    1e38:	e7ef      	b.n	1e1a <_i2c_m_sync_transfer+0xf2>
			if (msg->len == 0) {
    1e3a:	6868      	ldr	r0, [r5, #4]
    1e3c:	2800      	cmp	r0, #0
    1e3e:	d111      	bne.n	1e64 <_i2c_m_sync_transfer+0x13c>
				if (msg->flags & I2C_M_STOP) {
    1e40:	886b      	ldrh	r3, [r5, #2]
    1e42:	b21b      	sxth	r3, r3
    1e44:	2b00      	cmp	r3, #0
    1e46:	db04      	blt.n	1e52 <_i2c_m_sync_transfer+0x12a>
				msg->flags &= ~I2C_M_BUSY;
    1e48:	886b      	ldrh	r3, [r5, #2]
    1e4a:	4a53      	ldr	r2, [pc, #332]	; (1f98 <_i2c_m_sync_transfer+0x270>)
    1e4c:	4013      	ands	r3, r2
    1e4e:	806b      	strh	r3, [r5, #2]
    1e50:	e03d      	b.n	1ece <_i2c_m_sync_transfer+0x1a6>
	((Sercom *)hw)->I2CM.CTRLB.reg |= SERCOM_I2CM_CTRLB_CMD(mask);
    1e52:	6862      	ldr	r2, [r4, #4]
    1e54:	23c0      	movs	r3, #192	; 0xc0
    1e56:	029b      	lsls	r3, r3, #10
    1e58:	4313      	orrs	r3, r2
    1e5a:	6063      	str	r3, [r4, #4]
	while (((Sercom *)hw)->I2CM.SYNCBUSY.reg & reg) {
    1e5c:	69e3      	ldr	r3, [r4, #28]
    1e5e:	075b      	lsls	r3, r3, #29
    1e60:	d4fc      	bmi.n	1e5c <_i2c_m_sync_transfer+0x134>
    1e62:	e7f1      	b.n	1e48 <_i2c_m_sync_transfer+0x120>
				hri_sercomi2cm_write_DATA_reg(hw, *msg->buffer);
    1e64:	68ab      	ldr	r3, [r5, #8]
    1e66:	781a      	ldrb	r2, [r3, #0]
	((Sercom *)hw)->I2CM.DATA.reg = data;
    1e68:	2328      	movs	r3, #40	; 0x28
    1e6a:	54e2      	strb	r2, [r4, r3]
	while (((Sercom *)hw)->I2CM.SYNCBUSY.reg & reg) {
    1e6c:	69e3      	ldr	r3, [r4, #28]
    1e6e:	075b      	lsls	r3, r3, #29
    1e70:	d4fc      	bmi.n	1e6c <_i2c_m_sync_transfer+0x144>
				msg->buffer++;
    1e72:	68ab      	ldr	r3, [r5, #8]
    1e74:	3301      	adds	r3, #1
    1e76:	60ab      	str	r3, [r5, #8]
				msg->len--;
    1e78:	686b      	ldr	r3, [r5, #4]
    1e7a:	3b01      	subs	r3, #1
    1e7c:	606b      	str	r3, [r5, #4]
			return I2C_OK;
    1e7e:	2000      	movs	r0, #0
    1e80:	e025      	b.n	1ece <_i2c_m_sync_transfer+0x1a6>
	} else if (flags & SB_FLAG) {
    1e82:	07bb      	lsls	r3, r7, #30
    1e84:	d578      	bpl.n	1f78 <_i2c_m_sync_transfer+0x250>
		if ((msg->len) && !(status & SERCOM_I2CM_STATUS_RXNACK)) {
    1e86:	686b      	ldr	r3, [r5, #4]
    1e88:	2b00      	cmp	r3, #0
    1e8a:	d06d      	beq.n	1f68 <_i2c_m_sync_transfer+0x240>
    1e8c:	0752      	lsls	r2, r2, #29
    1e8e:	d46b      	bmi.n	1f68 <_i2c_m_sync_transfer+0x240>
			msg->len--;
    1e90:	3b01      	subs	r3, #1
    1e92:	606b      	str	r3, [r5, #4]
			if ((msg->len == 0 && !sclsm) || (msg->len == 1 && sclsm)) {
    1e94:	2b00      	cmp	r3, #0
    1e96:	d101      	bne.n	1e9c <_i2c_m_sync_transfer+0x174>
    1e98:	2900      	cmp	r1, #0
    1e9a:	d04c      	beq.n	1f36 <_i2c_m_sync_transfer+0x20e>
    1e9c:	2b01      	cmp	r3, #1
    1e9e:	d048      	beq.n	1f32 <_i2c_m_sync_transfer+0x20a>
			if (msg->len == 0) {
    1ea0:	686b      	ldr	r3, [r5, #4]
    1ea2:	2b00      	cmp	r3, #0
    1ea4:	d107      	bne.n	1eb6 <_i2c_m_sync_transfer+0x18e>
				if (msg->flags & I2C_M_STOP) {
    1ea6:	886b      	ldrh	r3, [r5, #2]
    1ea8:	b21b      	sxth	r3, r3
    1eaa:	2b00      	cmp	r3, #0
    1eac:	db4c      	blt.n	1f48 <_i2c_m_sync_transfer+0x220>
				msg->flags &= ~I2C_M_BUSY;
    1eae:	886b      	ldrh	r3, [r5, #2]
    1eb0:	4a39      	ldr	r2, [pc, #228]	; (1f98 <_i2c_m_sync_transfer+0x270>)
    1eb2:	4013      	ands	r3, r2
    1eb4:	806b      	strh	r3, [r5, #2]
			*msg->buffer++ = hri_sercomi2cm_read_DATA_reg(hw);
    1eb6:	68aa      	ldr	r2, [r5, #8]
    1eb8:	1c53      	adds	r3, r2, #1
    1eba:	60ab      	str	r3, [r5, #8]
    1ebc:	69e3      	ldr	r3, [r4, #28]
    1ebe:	075b      	lsls	r3, r3, #29
    1ec0:	d4fc      	bmi.n	1ebc <_i2c_m_sync_transfer+0x194>
	return ((Sercom *)hw)->I2CM.DATA.reg;
    1ec2:	2328      	movs	r3, #40	; 0x28
    1ec4:	5ce3      	ldrb	r3, [r4, r3]
    1ec6:	7013      	strb	r3, [r2, #0]
	((Sercom *)hw)->I2CM.INTFLAG.reg = SERCOM_I2CM_INTFLAG_SB;
    1ec8:	2302      	movs	r3, #2
    1eca:	7623      	strb	r3, [r4, #24]
	return I2C_OK;
    1ecc:	2000      	movs	r0, #0
	while (i2c_dev->service.msg.flags & I2C_M_BUSY) {
    1ece:	886b      	ldrh	r3, [r5, #2]
    1ed0:	05db      	lsls	r3, r3, #23
    1ed2:	d400      	bmi.n	1ed6 <_i2c_m_sync_transfer+0x1ae>
    1ed4:	e761      	b.n	1d9a <_i2c_m_sync_transfer+0x72>
	void *   hw      = i2c_dev->hw;
    1ed6:	6928      	ldr	r0, [r5, #16]
	uint32_t timeout = 65535;
    1ed8:	4a31      	ldr	r2, [pc, #196]	; (1fa0 <_i2c_m_sync_transfer+0x278>)
	return ((Sercom *)hw)->I2CM.INTFLAG.reg;
    1eda:	7e03      	ldrb	r3, [r0, #24]
    1edc:	b2db      	uxtb	r3, r3
		*flags = hri_sercomi2cm_read_INTFLAG_reg(hw);
    1ede:	001f      	movs	r7, r3
		if (timeout-- == 0) {
    1ee0:	1e51      	subs	r1, r2, #1
    1ee2:	2a00      	cmp	r2, #0
    1ee4:	d100      	bne.n	1ee8 <_i2c_m_sync_transfer+0x1c0>
    1ee6:	e759      	b.n	1d9c <_i2c_m_sync_transfer+0x74>
    1ee8:	000a      	movs	r2, r1
	} while (!(*flags & MB_FLAG) && !(*flags & SB_FLAG));
    1eea:	079b      	lsls	r3, r3, #30
    1eec:	d0f5      	beq.n	1eda <_i2c_m_sync_transfer+0x1b2>
	return I2C_OK;
    1eee:	2000      	movs	r0, #0
		if (ret) {
    1ef0:	2800      	cmp	r0, #0
    1ef2:	d000      	beq.n	1ef6 <_i2c_m_sync_transfer+0x1ce>
    1ef4:	e755      	b.n	1da2 <_i2c_m_sync_transfer+0x7a>
	tmp = ((Sercom *)hw)->I2CM.CTRLA.reg;
    1ef6:	6823      	ldr	r3, [r4, #0]
	tmp = (tmp & SERCOM_I2CM_CTRLA_SCLSM) >> SERCOM_I2CM_CTRLA_SCLSM_Pos;
    1ef8:	0edb      	lsrs	r3, r3, #27
    1efa:	2101      	movs	r1, #1
    1efc:	4019      	ands	r1, r3
	while (((Sercom *)hw)->I2CM.SYNCBUSY.reg & reg) {
    1efe:	69e3      	ldr	r3, [r4, #28]
    1f00:	075b      	lsls	r3, r3, #29
    1f02:	d4fc      	bmi.n	1efe <_i2c_m_sync_transfer+0x1d6>
	return ((Sercom *)hw)->I2CM.STATUS.reg;
    1f04:	8b62      	ldrh	r2, [r4, #26]
    1f06:	b292      	uxth	r2, r2
	if (flags & MB_FLAG) {
    1f08:	07fb      	lsls	r3, r7, #31
    1f0a:	d5ba      	bpl.n	1e82 <_i2c_m_sync_transfer+0x15a>
		if (status & SERCOM_I2CM_STATUS_ARBLOST) {
    1f0c:	0793      	lsls	r3, r2, #30
    1f0e:	d400      	bmi.n	1f12 <_i2c_m_sync_transfer+0x1ea>
    1f10:	e759      	b.n	1dc6 <_i2c_m_sync_transfer+0x9e>
	((Sercom *)hw)->I2CM.INTFLAG.reg = SERCOM_I2CM_INTFLAG_MB;
    1f12:	2301      	movs	r3, #1
    1f14:	7623      	strb	r3, [r4, #24]
			msg->flags |= I2C_M_FAIL;
    1f16:	886b      	ldrh	r3, [r5, #2]
    1f18:	2180      	movs	r1, #128	; 0x80
    1f1a:	0149      	lsls	r1, r1, #5
    1f1c:	430b      	orrs	r3, r1
    1f1e:	806b      	strh	r3, [r5, #2]
			msg->flags &= ~I2C_M_BUSY;
    1f20:	886b      	ldrh	r3, [r5, #2]
    1f22:	491d      	ldr	r1, [pc, #116]	; (1f98 <_i2c_m_sync_transfer+0x270>)
    1f24:	400b      	ands	r3, r1
    1f26:	806b      	strh	r3, [r5, #2]
			if (status & SERCOM_I2CM_STATUS_BUSERR) {
    1f28:	07d3      	lsls	r3, r2, #31
    1f2a:	d522      	bpl.n	1f72 <_i2c_m_sync_transfer+0x24a>
				return I2C_ERR_BUS;
    1f2c:	2005      	movs	r0, #5
    1f2e:	4240      	negs	r0, r0
    1f30:	e7cd      	b.n	1ece <_i2c_m_sync_transfer+0x1a6>
			if ((msg->len == 0 && !sclsm) || (msg->len == 1 && sclsm)) {
    1f32:	2900      	cmp	r1, #0
    1f34:	d0b4      	beq.n	1ea0 <_i2c_m_sync_transfer+0x178>
	((Sercom *)hw)->I2CM.CTRLB.reg |= SERCOM_I2CM_CTRLB_ACKACT;
    1f36:	6862      	ldr	r2, [r4, #4]
    1f38:	2380      	movs	r3, #128	; 0x80
    1f3a:	02db      	lsls	r3, r3, #11
    1f3c:	4313      	orrs	r3, r2
    1f3e:	6063      	str	r3, [r4, #4]
	while (((Sercom *)hw)->I2CM.SYNCBUSY.reg & reg) {
    1f40:	69e3      	ldr	r3, [r4, #28]
    1f42:	075b      	lsls	r3, r3, #29
    1f44:	d1fc      	bne.n	1f40 <_i2c_m_sync_transfer+0x218>
    1f46:	e7ab      	b.n	1ea0 <_i2c_m_sync_transfer+0x178>
	((Sercom *)hw)->I2CM.CTRLB.reg &= ~SERCOM_I2CM_CTRLB_SMEN;
    1f48:	6863      	ldr	r3, [r4, #4]
    1f4a:	4a13      	ldr	r2, [pc, #76]	; (1f98 <_i2c_m_sync_transfer+0x270>)
    1f4c:	4013      	ands	r3, r2
    1f4e:	6063      	str	r3, [r4, #4]
	while (((Sercom *)hw)->I2CM.SYNCBUSY.reg & reg) {
    1f50:	69e3      	ldr	r3, [r4, #28]
    1f52:	075b      	lsls	r3, r3, #29
    1f54:	d1fc      	bne.n	1f50 <_i2c_m_sync_transfer+0x228>
	((Sercom *)hw)->I2CM.CTRLB.reg |= SERCOM_I2CM_CTRLB_CMD(mask);
    1f56:	6862      	ldr	r2, [r4, #4]
    1f58:	23c0      	movs	r3, #192	; 0xc0
    1f5a:	029b      	lsls	r3, r3, #10
    1f5c:	4313      	orrs	r3, r2
    1f5e:	6063      	str	r3, [r4, #4]
	while (((Sercom *)hw)->I2CM.SYNCBUSY.reg & reg) {
    1f60:	69e3      	ldr	r3, [r4, #28]
    1f62:	075b      	lsls	r3, r3, #29
    1f64:	d4fc      	bmi.n	1f60 <_i2c_m_sync_transfer+0x238>
    1f66:	e7a2      	b.n	1eae <_i2c_m_sync_transfer+0x186>
	((Sercom *)hw)->I2CM.INTFLAG.reg = SERCOM_I2CM_INTFLAG_SB;
    1f68:	2302      	movs	r3, #2
    1f6a:	7623      	strb	r3, [r4, #24]
			return I2C_NACK;
    1f6c:	2002      	movs	r0, #2
    1f6e:	4240      	negs	r0, r0
    1f70:	e7ad      	b.n	1ece <_i2c_m_sync_transfer+0x1a6>
			return I2C_ERR_BAD_ADDRESS;
    1f72:	2004      	movs	r0, #4
    1f74:	4240      	negs	r0, r0
    1f76:	e7aa      	b.n	1ece <_i2c_m_sync_transfer+0x1a6>
	return I2C_OK;
    1f78:	2000      	movs	r0, #0
    1f7a:	e7a8      	b.n	1ece <_i2c_m_sync_transfer+0x1a6>
		return I2C_ERR_BUSY;
    1f7c:	2006      	movs	r0, #6
    1f7e:	4240      	negs	r0, r0
    1f80:	e70b      	b.n	1d9a <_i2c_m_sync_transfer+0x72>
    1f82:	46c0      	nop			; (mov r8, r8)
    1f84:	000005c6 	.word	0x000005c6
    1f88:	00002860 	.word	0x00002860
    1f8c:	0000138d 	.word	0x0000138d
    1f90:	000005c7 	.word	0x000005c7
    1f94:	00001a09 	.word	0x00001a09
    1f98:	fffffeff 	.word	0xfffffeff
    1f9c:	fffffbff 	.word	0xfffffbff
    1fa0:	0000ffff 	.word	0x0000ffff

00001fa4 <_spi_m_sync_init>:

	return NULL;
}

int32_t _spi_m_sync_init(struct _spi_m_sync_dev *dev, void *const hw)
{
    1fa4:	b570      	push	{r4, r5, r6, lr}
    1fa6:	0006      	movs	r6, r0
    1fa8:	000c      	movs	r4, r1
	uint8_t n = _sercom_get_hardware_index((const void *)hw_addr);
    1faa:	0008      	movs	r0, r1
    1fac:	4b71      	ldr	r3, [pc, #452]	; (2174 <STACK_SIZE+0x174>)
    1fae:	4798      	blx	r3
	for (i = 0; i < sizeof(sercomspi_regs) / sizeof(struct sercomspi_regs_cfg); i++) {
    1fb0:	2300      	movs	r3, #0
    1fb2:	2b00      	cmp	r3, #0
    1fb4:	d100      	bne.n	1fb8 <_spi_m_sync_init+0x14>
    1fb6:	e084      	b.n	20c2 <STACK_SIZE+0xc2>
	return NULL;
    1fb8:	2500      	movs	r5, #0
	const struct sercomspi_regs_cfg *regs = _spi_get_regs((uint32_t)hw);

	ASSERT(dev && hw);
    1fba:	2e00      	cmp	r6, #0
    1fbc:	d100      	bne.n	1fc0 <_spi_m_sync_init+0x1c>
    1fbe:	e08d      	b.n	20dc <STACK_SIZE+0xdc>
    1fc0:	2c00      	cmp	r4, #0
    1fc2:	d100      	bne.n	1fc6 <_spi_m_sync_init+0x22>
    1fc4:	e088      	b.n	20d8 <STACK_SIZE+0xd8>
    1fc6:	2001      	movs	r0, #1
    1fc8:	4a6b      	ldr	r2, [pc, #428]	; (2178 <STACK_SIZE+0x178>)
    1fca:	496c      	ldr	r1, [pc, #432]	; (217c <STACK_SIZE+0x17c>)
    1fcc:	4b6c      	ldr	r3, [pc, #432]	; (2180 <STACK_SIZE+0x180>)
    1fce:	4798      	blx	r3

	if (regs == NULL) {
    1fd0:	2d00      	cmp	r5, #0
    1fd2:	d100      	bne.n	1fd6 <_spi_m_sync_init+0x32>
    1fd4:	e0cb      	b.n	216e <STACK_SIZE+0x16e>
	return ((Sercom *)hw)->SPI.SYNCBUSY.reg & reg;
    1fd6:	69e3      	ldr	r3, [r4, #28]
		return ERR_INVALID_ARG;
	}

	if (!hri_sercomspi_is_syncing(hw, SERCOM_SPI_SYNCBUSY_SWRST)) {
    1fd8:	07db      	lsls	r3, r3, #31
    1fda:	d421      	bmi.n	2020 <STACK_SIZE+0x20>
		uint32_t mode = regs->ctrla & SERCOM_SPI_CTRLA_MODE_Msk;
    1fdc:	782a      	ldrb	r2, [r5, #0]
    1fde:	786b      	ldrb	r3, [r5, #1]
    1fe0:	021b      	lsls	r3, r3, #8
    1fe2:	4313      	orrs	r3, r2
    1fe4:	78aa      	ldrb	r2, [r5, #2]
    1fe6:	0412      	lsls	r2, r2, #16
    1fe8:	4313      	orrs	r3, r2
    1fea:	78ea      	ldrb	r2, [r5, #3]
    1fec:	0612      	lsls	r2, r2, #24
    1fee:	431a      	orrs	r2, r3
    1ff0:	231c      	movs	r3, #28
    1ff2:	401a      	ands	r2, r3
	while (((Sercom *)hw)->SPI.SYNCBUSY.reg & reg) {
    1ff4:	69e3      	ldr	r3, [r4, #28]
    1ff6:	079b      	lsls	r3, r3, #30
    1ff8:	d1fc      	bne.n	1ff4 <_spi_m_sync_init+0x50>
	tmp = ((Sercom *)hw)->SPI.CTRLA.reg;
    1ffa:	6823      	ldr	r3, [r4, #0]
		if (hri_sercomspi_get_CTRLA_reg(hw, SERCOM_SPI_CTRLA_ENABLE)) {
    1ffc:	079b      	lsls	r3, r3, #30
    1ffe:	d509      	bpl.n	2014 <STACK_SIZE+0x14>
	((Sercom *)hw)->SPI.CTRLA.reg &= ~SERCOM_SPI_CTRLA_ENABLE;
    2000:	6823      	ldr	r3, [r4, #0]
    2002:	2102      	movs	r1, #2
    2004:	438b      	bics	r3, r1
    2006:	6023      	str	r3, [r4, #0]
	while (((Sercom *)hw)->SPI.SYNCBUSY.reg & reg) {
    2008:	69e3      	ldr	r3, [r4, #28]
    200a:	079b      	lsls	r3, r3, #30
    200c:	d1fc      	bne.n	2008 <STACK_SIZE+0x8>
    200e:	69e3      	ldr	r3, [r4, #28]
    2010:	079b      	lsls	r3, r3, #30
    2012:	d4fc      	bmi.n	200e <STACK_SIZE+0xe>
			hri_sercomspi_clear_CTRLA_ENABLE_bit(hw);
			hri_sercomspi_wait_for_sync(hw, SERCOM_SPI_SYNCBUSY_ENABLE);
		}
		hri_sercomspi_write_CTRLA_reg(hw, SERCOM_SPI_CTRLA_SWRST | mode);
    2014:	2301      	movs	r3, #1
    2016:	4313      	orrs	r3, r2
	((Sercom *)hw)->SPI.CTRLA.reg = data;
    2018:	6023      	str	r3, [r4, #0]
	while (((Sercom *)hw)->SPI.SYNCBUSY.reg & reg) {
    201a:	69e3      	ldr	r3, [r4, #28]
    201c:	079b      	lsls	r3, r3, #30
    201e:	d1fc      	bne.n	201a <STACK_SIZE+0x1a>
    2020:	69e3      	ldr	r3, [r4, #28]
    2022:	07db      	lsls	r3, r3, #31
    2024:	d4fc      	bmi.n	2020 <STACK_SIZE+0x20>
	}
	hri_sercomspi_wait_for_sync(hw, SERCOM_SPI_SYNCBUSY_SWRST);

	dev->prvt = hw;
    2026:	6034      	str	r4, [r6, #0]

	if ((regs->ctrla & SERCOM_SPI_CTRLA_MODE_Msk) == SERCOM_USART_CTRLA_MODE_SPI_SLAVE) {
    2028:	782b      	ldrb	r3, [r5, #0]
    202a:	786a      	ldrb	r2, [r5, #1]
    202c:	0212      	lsls	r2, r2, #8
    202e:	431a      	orrs	r2, r3
    2030:	78ab      	ldrb	r3, [r5, #2]
    2032:	041b      	lsls	r3, r3, #16
    2034:	431a      	orrs	r2, r3
    2036:	78eb      	ldrb	r3, [r5, #3]
    2038:	061b      	lsls	r3, r3, #24
    203a:	4313      	orrs	r3, r2
    203c:	221c      	movs	r2, #28
    203e:	4013      	ands	r3, r2
    2040:	2b08      	cmp	r3, #8
    2042:	d04d      	beq.n	20e0 <STACK_SIZE+0xe0>
	ASSERT(hw && regs);
    2044:	2c00      	cmp	r4, #0
    2046:	d100      	bne.n	204a <STACK_SIZE+0x4a>
    2048:	e08d      	b.n	2166 <STACK_SIZE+0x166>
    204a:	2d00      	cmp	r5, #0
    204c:	d100      	bne.n	2050 <STACK_SIZE+0x50>
    204e:	e088      	b.n	2162 <STACK_SIZE+0x162>
    2050:	2001      	movs	r0, #1
    2052:	4a4c      	ldr	r2, [pc, #304]	; (2184 <STACK_SIZE+0x184>)
    2054:	4949      	ldr	r1, [pc, #292]	; (217c <STACK_SIZE+0x17c>)
    2056:	4b4a      	ldr	r3, [pc, #296]	; (2180 <STACK_SIZE+0x180>)
    2058:	4798      	blx	r3
	    hw, regs->ctrla & ~(SERCOM_SPI_CTRLA_IBON | SERCOM_SPI_CTRLA_ENABLE | SERCOM_SPI_CTRLA_SWRST));
    205a:	782b      	ldrb	r3, [r5, #0]
    205c:	786a      	ldrb	r2, [r5, #1]
    205e:	0212      	lsls	r2, r2, #8
    2060:	431a      	orrs	r2, r3
    2062:	78ab      	ldrb	r3, [r5, #2]
    2064:	041b      	lsls	r3, r3, #16
    2066:	431a      	orrs	r2, r3
    2068:	78eb      	ldrb	r3, [r5, #3]
    206a:	061b      	lsls	r3, r3, #24
    206c:	4313      	orrs	r3, r2
	hri_sercomspi_write_CTRLA_reg(
    206e:	4a46      	ldr	r2, [pc, #280]	; (2188 <STACK_SIZE+0x188>)
    2070:	4013      	ands	r3, r2
	((Sercom *)hw)->SPI.CTRLA.reg = data;
    2072:	6023      	str	r3, [r4, #0]
	while (((Sercom *)hw)->SPI.SYNCBUSY.reg & reg) {
    2074:	69e3      	ldr	r3, [r4, #28]
    2076:	079b      	lsls	r3, r3, #30
    2078:	d1fc      	bne.n	2074 <STACK_SIZE+0x74>
	    (regs->ctrlb
    207a:	792b      	ldrb	r3, [r5, #4]
    207c:	796a      	ldrb	r2, [r5, #5]
    207e:	0212      	lsls	r2, r2, #8
    2080:	431a      	orrs	r2, r3
    2082:	79ab      	ldrb	r3, [r5, #6]
    2084:	041b      	lsls	r3, r3, #16
    2086:	431a      	orrs	r2, r3
    2088:	79eb      	ldrb	r3, [r5, #7]
    208a:	061b      	lsls	r3, r3, #24
    208c:	4313      	orrs	r3, r2
	        | (SERCOM_SPI_CTRLB_RXEN));
    208e:	4a3f      	ldr	r2, [pc, #252]	; (218c <STACK_SIZE+0x18c>)
    2090:	4013      	ands	r3, r2
	hri_sercomspi_write_CTRLB_reg(
    2092:	2280      	movs	r2, #128	; 0x80
    2094:	0292      	lsls	r2, r2, #10
    2096:	4313      	orrs	r3, r2
	((Sercom *)hw)->SPI.CTRLB.reg = data;
    2098:	6063      	str	r3, [r4, #4]
	while (((Sercom *)hw)->SPI.SYNCBUSY.reg & reg) {
    209a:	69e3      	ldr	r3, [r4, #28]
    209c:	075b      	lsls	r3, r3, #29
    209e:	d1fc      	bne.n	209a <STACK_SIZE+0x9a>
	hri_sercomspi_write_BAUD_reg(hw, regs->baud);
    20a0:	7b2b      	ldrb	r3, [r5, #12]
	((Sercom *)hw)->SPI.BAUD.reg = data;
    20a2:	7323      	strb	r3, [r4, #12]
	hri_sercomspi_write_DBGCTRL_reg(hw, regs->dbgctrl);
    20a4:	7b6a      	ldrb	r2, [r5, #13]
	((Sercom *)hw)->SPI.DBGCTRL.reg = data;
    20a6:	2330      	movs	r3, #48	; 0x30
    20a8:	54e2      	strb	r2, [r4, r3]
	} else {
		_spi_load_regs_master(hw, regs);
	}

	/* Load character size from default hardware configuration */
	dev->char_size = ((regs->ctrlb & SERCOM_SPI_CTRLB_CHSIZE_Msk) == 0) ? 1 : 2;
    20aa:	792b      	ldrb	r3, [r5, #4]
    20ac:	075b      	lsls	r3, r3, #29
    20ae:	d15c      	bne.n	216a <STACK_SIZE+0x16a>
    20b0:	2301      	movs	r3, #1
    20b2:	7133      	strb	r3, [r6, #4]

	dev->dummy_byte = regs->dummy_byte;
    20b4:	7baa      	ldrb	r2, [r5, #14]
    20b6:	7beb      	ldrb	r3, [r5, #15]
    20b8:	021b      	lsls	r3, r3, #8
    20ba:	4313      	orrs	r3, r2
    20bc:	80f3      	strh	r3, [r6, #6]

	return ERR_NONE;
    20be:	2000      	movs	r0, #0
}
    20c0:	bd70      	pop	{r4, r5, r6, pc}
		if (sercomspi_regs[i].n == n) {
    20c2:	2803      	cmp	r0, #3
    20c4:	d002      	beq.n	20cc <STACK_SIZE+0xcc>
	for (i = 0; i < sizeof(sercomspi_regs) / sizeof(struct sercomspi_regs_cfg); i++) {
    20c6:	3301      	adds	r3, #1
    20c8:	b2db      	uxtb	r3, r3
    20ca:	e772      	b.n	1fb2 <_spi_m_sync_init+0xe>
			return &sercomspi_regs[i];
    20cc:	011d      	lsls	r5, r3, #4
    20ce:	18ea      	adds	r2, r5, r3
    20d0:	4d2f      	ldr	r5, [pc, #188]	; (2190 <STACK_SIZE+0x190>)
    20d2:	3524      	adds	r5, #36	; 0x24
    20d4:	18ad      	adds	r5, r5, r2
    20d6:	e770      	b.n	1fba <_spi_m_sync_init+0x16>
	ASSERT(dev && hw);
    20d8:	2000      	movs	r0, #0
    20da:	e775      	b.n	1fc8 <_spi_m_sync_init+0x24>
    20dc:	2000      	movs	r0, #0
    20de:	e773      	b.n	1fc8 <_spi_m_sync_init+0x24>
	ASSERT(hw && regs);
    20e0:	2c00      	cmp	r4, #0
    20e2:	d03c      	beq.n	215e <STACK_SIZE+0x15e>
    20e4:	2d00      	cmp	r5, #0
    20e6:	d038      	beq.n	215a <STACK_SIZE+0x15a>
    20e8:	2001      	movs	r0, #1
    20ea:	4a2a      	ldr	r2, [pc, #168]	; (2194 <STACK_SIZE+0x194>)
    20ec:	4923      	ldr	r1, [pc, #140]	; (217c <STACK_SIZE+0x17c>)
    20ee:	4b24      	ldr	r3, [pc, #144]	; (2180 <STACK_SIZE+0x180>)
    20f0:	4798      	blx	r3
	    hw, regs->ctrla & ~(SERCOM_SPI_CTRLA_IBON | SERCOM_SPI_CTRLA_ENABLE | SERCOM_SPI_CTRLA_SWRST));
    20f2:	782b      	ldrb	r3, [r5, #0]
    20f4:	786a      	ldrb	r2, [r5, #1]
    20f6:	0212      	lsls	r2, r2, #8
    20f8:	431a      	orrs	r2, r3
    20fa:	78ab      	ldrb	r3, [r5, #2]
    20fc:	041b      	lsls	r3, r3, #16
    20fe:	431a      	orrs	r2, r3
    2100:	78eb      	ldrb	r3, [r5, #3]
    2102:	061b      	lsls	r3, r3, #24
    2104:	4313      	orrs	r3, r2
	hri_sercomspi_write_CTRLA_reg(
    2106:	4a20      	ldr	r2, [pc, #128]	; (2188 <STACK_SIZE+0x188>)
    2108:	4013      	ands	r3, r2
	((Sercom *)hw)->SPI.CTRLA.reg = data;
    210a:	6023      	str	r3, [r4, #0]
	while (((Sercom *)hw)->SPI.SYNCBUSY.reg & reg) {
    210c:	69e3      	ldr	r3, [r4, #28]
    210e:	079b      	lsls	r3, r3, #30
    2110:	d1fc      	bne.n	210c <STACK_SIZE+0x10c>
	                              (regs->ctrlb & ~(SERCOM_SPI_CTRLB_MSSEN))
    2112:	792b      	ldrb	r3, [r5, #4]
    2114:	796a      	ldrb	r2, [r5, #5]
    2116:	0212      	lsls	r2, r2, #8
    2118:	431a      	orrs	r2, r3
    211a:	79ab      	ldrb	r3, [r5, #6]
    211c:	041b      	lsls	r3, r3, #16
    211e:	431a      	orrs	r2, r3
    2120:	79eb      	ldrb	r3, [r5, #7]
    2122:	061b      	lsls	r3, r3, #24
    2124:	4313      	orrs	r3, r2
	                                  | (SERCOM_SPI_CTRLB_RXEN | SERCOM_SPI_CTRLB_SSDE | SERCOM_SPI_CTRLB_PLOADEN));
    2126:	4a1c      	ldr	r2, [pc, #112]	; (2198 <STACK_SIZE+0x198>)
    2128:	4013      	ands	r3, r2
	hri_sercomspi_write_CTRLB_reg(hw,
    212a:	4a1c      	ldr	r2, [pc, #112]	; (219c <STACK_SIZE+0x19c>)
    212c:	4313      	orrs	r3, r2
	((Sercom *)hw)->SPI.CTRLB.reg = data;
    212e:	6063      	str	r3, [r4, #4]
	while (((Sercom *)hw)->SPI.SYNCBUSY.reg & reg) {
    2130:	69e3      	ldr	r3, [r4, #28]
    2132:	075b      	lsls	r3, r3, #29
    2134:	d1fc      	bne.n	2130 <STACK_SIZE+0x130>
	hri_sercomspi_write_ADDR_reg(hw, regs->addr);
    2136:	7a2b      	ldrb	r3, [r5, #8]
    2138:	7a6a      	ldrb	r2, [r5, #9]
    213a:	0212      	lsls	r2, r2, #8
    213c:	431a      	orrs	r2, r3
    213e:	7aab      	ldrb	r3, [r5, #10]
    2140:	041b      	lsls	r3, r3, #16
    2142:	431a      	orrs	r2, r3
    2144:	7aeb      	ldrb	r3, [r5, #11]
    2146:	061b      	lsls	r3, r3, #24
    2148:	4313      	orrs	r3, r2
	((Sercom *)hw)->SPI.ADDR.reg = data;
    214a:	6263      	str	r3, [r4, #36]	; 0x24
	hri_sercomspi_write_DBGCTRL_reg(hw, regs->dbgctrl);
    214c:	7b6a      	ldrb	r2, [r5, #13]
	((Sercom *)hw)->SPI.DBGCTRL.reg = data;
    214e:	2330      	movs	r3, #48	; 0x30
    2150:	54e2      	strb	r2, [r4, r3]
	return ((Sercom *)hw)->SPI.SYNCBUSY.reg & reg;
    2152:	69e3      	ldr	r3, [r4, #28]
	while (hri_sercomspi_is_syncing(hw, 0xFFFFFFFF))
    2154:	2b00      	cmp	r3, #0
    2156:	d1fc      	bne.n	2152 <STACK_SIZE+0x152>
    2158:	e7a7      	b.n	20aa <STACK_SIZE+0xaa>
	ASSERT(hw && regs);
    215a:	2000      	movs	r0, #0
    215c:	e7c5      	b.n	20ea <STACK_SIZE+0xea>
    215e:	2000      	movs	r0, #0
    2160:	e7c3      	b.n	20ea <STACK_SIZE+0xea>
	ASSERT(hw && regs);
    2162:	2000      	movs	r0, #0
    2164:	e775      	b.n	2052 <STACK_SIZE+0x52>
    2166:	2000      	movs	r0, #0
    2168:	e773      	b.n	2052 <STACK_SIZE+0x52>
	dev->char_size = ((regs->ctrlb & SERCOM_SPI_CTRLB_CHSIZE_Msk) == 0) ? 1 : 2;
    216a:	2302      	movs	r3, #2
    216c:	e7a1      	b.n	20b2 <STACK_SIZE+0xb2>
		return ERR_INVALID_ARG;
    216e:	200d      	movs	r0, #13
    2170:	4240      	negs	r0, r0
    2172:	e7a5      	b.n	20c0 <STACK_SIZE+0xc0>
    2174:	000018b5 	.word	0x000018b5
    2178:	0000092c 	.word	0x0000092c
    217c:	00002860 	.word	0x00002860
    2180:	0000138d 	.word	0x0000138d
    2184:	000008f6 	.word	0x000008f6
    2188:	fffffefc 	.word	0xfffffefc
    218c:	fffd1dbf 	.word	0xfffd1dbf
    2190:	00002828 	.word	0x00002828
    2194:	0000090a 	.word	0x0000090a
    2198:	fffdddbf 	.word	0xfffdddbf
    219c:	00020240 	.word	0x00020240

000021a0 <_spi_m_sync_trans>:

	return ERR_NONE;
}

int32_t _spi_m_sync_trans(struct _spi_m_sync_dev *dev, const struct spi_msg *msg)
{
    21a0:	b5f0      	push	{r4, r5, r6, r7, lr}
    21a2:	46ce      	mov	lr, r9
    21a4:	4647      	mov	r7, r8
    21a6:	b580      	push	{r7, lr}
    21a8:	b089      	sub	sp, #36	; 0x24
    21aa:	4681      	mov	r9, r0
    21ac:	000d      	movs	r5, r1
	void *                 hw   = dev->prvt;
    21ae:	6804      	ldr	r4, [r0, #0]
	int32_t                rc   = 0;
	struct _spi_trans_ctrl ctrl = {msg->txbuf, msg->rxbuf, 0, 0, dev->char_size};
    21b0:	680b      	ldr	r3, [r1, #0]
    21b2:	9303      	str	r3, [sp, #12]
    21b4:	684b      	ldr	r3, [r1, #4]
    21b6:	9304      	str	r3, [sp, #16]
    21b8:	2300      	movs	r3, #0
    21ba:	9305      	str	r3, [sp, #20]
    21bc:	9306      	str	r3, [sp, #24]
    21be:	7906      	ldrb	r6, [r0, #4]

	ASSERT(dev && hw);
    21c0:	2800      	cmp	r0, #0
    21c2:	d014      	beq.n	21ee <_spi_m_sync_trans+0x4e>
    21c4:	2c00      	cmp	r4, #0
    21c6:	d010      	beq.n	21ea <_spi_m_sync_trans+0x4a>
    21c8:	2001      	movs	r0, #1
    21ca:	4a37      	ldr	r2, [pc, #220]	; (22a8 <_spi_m_sync_trans+0x108>)
    21cc:	4937      	ldr	r1, [pc, #220]	; (22ac <_spi_m_sync_trans+0x10c>)
    21ce:	4b38      	ldr	r3, [pc, #224]	; (22b0 <_spi_m_sync_trans+0x110>)
    21d0:	4798      	blx	r3
    21d2:	69e3      	ldr	r3, [r4, #28]

	/* If settings are not applied (pending), we can not go on */
	if (hri_sercomspi_is_syncing(
    21d4:	075b      	lsls	r3, r3, #29
    21d6:	d164      	bne.n	22a2 <_spi_m_sync_trans+0x102>
	while (((Sercom *)hw)->SPI.SYNCBUSY.reg & reg) {
    21d8:	69e3      	ldr	r3, [r4, #28]
    21da:	079b      	lsls	r3, r3, #30
    21dc:	d1fc      	bne.n	21d8 <_spi_m_sync_trans+0x38>
	tmp = ((Sercom *)hw)->SPI.CTRLA.reg;
    21de:	6823      	ldr	r3, [r4, #0]
	        hw, (SERCOM_SPI_SYNCBUSY_SWRST | SERCOM_SPI_SYNCBUSY_ENABLE | SERCOM_SPI_SYNCBUSY_CTRLB))) {
		return ERR_BUSY;
	}

	/* SPI must be enabled to start synchronous transfer */
	if (!hri_sercomspi_get_CTRLA_ENABLE_bit(hw)) {
    21e0:	079b      	lsls	r3, r3, #30
    21e2:	d420      	bmi.n	2226 <_spi_m_sync_trans+0x86>
		return ERR_NOT_INITIALIZED;
    21e4:	2014      	movs	r0, #20
    21e6:	4240      	negs	r0, r0
    21e8:	e056      	b.n	2298 <_spi_m_sync_trans+0xf8>
	ASSERT(dev && hw);
    21ea:	2000      	movs	r0, #0
    21ec:	e7ed      	b.n	21ca <_spi_m_sync_trans+0x2a>
    21ee:	2000      	movs	r0, #0
    21f0:	e7eb      	b.n	21ca <_spi_m_sync_trans+0x2a>
		return false;
    21f2:	2200      	movs	r2, #0
    21f4:	e02d      	b.n	2252 <_spi_m_sync_trans+0xb2>
			data |= (*ctrl->txbuf) << 8;
    21f6:	7848      	ldrb	r0, [r1, #1]
    21f8:	0200      	lsls	r0, r0, #8
    21fa:	4647      	mov	r7, r8
    21fc:	4307      	orrs	r7, r0
    21fe:	46b8      	mov	r8, r7
			ctrl->txbuf++;
    2200:	3102      	adds	r1, #2
    2202:	9103      	str	r1, [sp, #12]
	ctrl->txcnt++;
    2204:	3201      	adds	r2, #1
    2206:	9205      	str	r2, [sp, #20]
	((Sercom *)hw)->SPI.DATA.reg = data;
    2208:	4642      	mov	r2, r8
    220a:	62a2      	str	r2, [r4, #40]	; 0x28
	if (SERCOM_SPI_INTFLAG_ERROR & iflag) {
    220c:	b25b      	sxtb	r3, r3
    220e:	2b00      	cmp	r3, #0
    2210:	db35      	blt.n	227e <_spi_m_sync_trans+0xde>
	return ERR_NONE;
    2212:	2000      	movs	r0, #0
			}
		}

		rc = _spi_err_check(iflag, hw);

		if (rc < 0) {
    2214:	2800      	cmp	r0, #0
    2216:	db3a      	blt.n	228e <_spi_m_sync_trans+0xee>
			break;
		}
		if (ctrl.txcnt >= msg->size && ctrl.rxcnt >= msg->size) {
    2218:	9805      	ldr	r0, [sp, #20]
    221a:	68ab      	ldr	r3, [r5, #8]
    221c:	4298      	cmp	r0, r3
    221e:	d302      	bcc.n	2226 <_spi_m_sync_trans+0x86>
    2220:	9a06      	ldr	r2, [sp, #24]
    2222:	4293      	cmp	r3, r2
    2224:	d933      	bls.n	228e <_spi_m_sync_trans+0xee>
	return ((Sercom *)hw)->SPI.INTFLAG.reg;
    2226:	7e23      	ldrb	r3, [r4, #24]
    2228:	b2db      	uxtb	r3, r3
	if (!(iflag & SERCOM_SPI_INTFLAG_RXC)) {
    222a:	075a      	lsls	r2, r3, #29
    222c:	d5e1      	bpl.n	21f2 <_spi_m_sync_trans+0x52>
	return ((Sercom *)hw)->SPI.DATA.reg;
    222e:	6aa1      	ldr	r1, [r4, #40]	; 0x28
	if (ctrl->rxbuf) {
    2230:	9a04      	ldr	r2, [sp, #16]
    2232:	2a00      	cmp	r2, #0
    2234:	d008      	beq.n	2248 <_spi_m_sync_trans+0xa8>
		*ctrl->rxbuf++ = (uint8_t)data;
    2236:	1c50      	adds	r0, r2, #1
    2238:	9004      	str	r0, [sp, #16]
    223a:	7011      	strb	r1, [r2, #0]
		if (ctrl->char_size > 1) {
    223c:	2e01      	cmp	r6, #1
    223e:	d903      	bls.n	2248 <_spi_m_sync_trans+0xa8>
			*ctrl->rxbuf++ = (uint8_t)(data >> 8);
    2240:	1c90      	adds	r0, r2, #2
    2242:	9004      	str	r0, [sp, #16]
    2244:	0a09      	lsrs	r1, r1, #8
    2246:	7051      	strb	r1, [r2, #1]
	ctrl->rxcnt++;
    2248:	9a06      	ldr	r2, [sp, #24]
    224a:	9201      	str	r2, [sp, #4]
    224c:	3201      	adds	r2, #1
    224e:	9206      	str	r2, [sp, #24]
	return true;
    2250:	2201      	movs	r2, #1
		if (!_spi_rx_check_and_receive(hw, iflag, &ctrl)) {
    2252:	2a00      	cmp	r2, #0
    2254:	d1da      	bne.n	220c <_spi_m_sync_trans+0x6c>
			if (ctrl.rxcnt >= ctrl.txcnt) {
    2256:	9906      	ldr	r1, [sp, #24]
    2258:	9a05      	ldr	r2, [sp, #20]
    225a:	4291      	cmp	r1, r2
    225c:	d3d6      	bcc.n	220c <_spi_m_sync_trans+0x6c>
				_spi_tx_check_and_send(hw, iflag, &ctrl, dev->dummy_byte);
    225e:	4649      	mov	r1, r9
    2260:	88c8      	ldrh	r0, [r1, #6]
	if (!(SERCOM_SPI_INTFLAG_DRE & iflag)) {
    2262:	07d9      	lsls	r1, r3, #31
    2264:	d5d2      	bpl.n	220c <_spi_m_sync_trans+0x6c>
	if (ctrl->txbuf) {
    2266:	9903      	ldr	r1, [sp, #12]
    2268:	2900      	cmp	r1, #0
    226a:	d006      	beq.n	227a <_spi_m_sync_trans+0xda>
		data = *ctrl->txbuf++;
    226c:	1c48      	adds	r0, r1, #1
    226e:	9003      	str	r0, [sp, #12]
    2270:	7808      	ldrb	r0, [r1, #0]
    2272:	4680      	mov	r8, r0
		if (ctrl->char_size > 1) {
    2274:	2e01      	cmp	r6, #1
    2276:	d8be      	bhi.n	21f6 <_spi_m_sync_trans+0x56>
    2278:	e7c4      	b.n	2204 <_spi_m_sync_trans+0x64>
		data = dummy;
    227a:	4680      	mov	r8, r0
    227c:	e7c2      	b.n	2204 <_spi_m_sync_trans+0x64>
	((Sercom *)hw)->SPI.STATUS.reg = mask;
    227e:	2301      	movs	r3, #1
    2280:	425b      	negs	r3, r3
    2282:	8363      	strh	r3, [r4, #26]
	((Sercom *)hw)->SPI.INTFLAG.reg = mask;
    2284:	3381      	adds	r3, #129	; 0x81
    2286:	7623      	strb	r3, [r4, #24]
		return ERR_OVERFLOW;
    2288:	2013      	movs	r0, #19
    228a:	4240      	negs	r0, r0
    228c:	e7c2      	b.n	2214 <_spi_m_sync_trans+0x74>
	tmp = ((Sercom *)hw)->SPI.INTFLAG.reg;
    228e:	7e23      	ldrb	r3, [r4, #24]
	while (!(hri_sercomspi_get_INTFLAG_reg(hw, SERCOM_SPI_INTFLAG_TXC | SERCOM_SPI_INTFLAG_DRE))) {
    2290:	079b      	lsls	r3, r3, #30
    2292:	d0fc      	beq.n	228e <_spi_m_sync_trans+0xee>
	((Sercom *)hw)->SPI.INTFLAG.reg = mask;
    2294:	2303      	movs	r3, #3
    2296:	7623      	strb	r3, [r4, #24]
	}
	/* Wait until SPI bus idle */
	_spi_wait_bus_idle(hw);

	return rc;
}
    2298:	b009      	add	sp, #36	; 0x24
    229a:	bc0c      	pop	{r2, r3}
    229c:	4690      	mov	r8, r2
    229e:	4699      	mov	r9, r3
    22a0:	bdf0      	pop	{r4, r5, r6, r7, pc}
		return ERR_BUSY;
    22a2:	2004      	movs	r0, #4
    22a4:	4240      	negs	r0, r0
    22a6:	e7f7      	b.n	2298 <_spi_m_sync_trans+0xf8>
    22a8:	00000a8c 	.word	0x00000a8c
    22ac:	00002860 	.word	0x00002860
    22b0:	0000138d 	.word	0x0000138d

000022b4 <main>:
#include <atmel_start.h>

int main(void)
{
    22b4:	b510      	push	{r4, lr}
	/* Initializes MCU, drivers and middleware */
	atmel_start_init();
    22b6:	4b04      	ldr	r3, [pc, #16]	; (22c8 <main+0x14>)
    22b8:	4798      	blx	r3
	/* Replace with your application code */
	
	while (1) {
		//initMCP4541();
		AFE_I2C_test()	;	
    22ba:	4b04      	ldr	r3, [pc, #16]	; (22cc <main+0x18>)
    22bc:	4798      	blx	r3
		delay_ms(1000);
    22be:	20fa      	movs	r0, #250	; 0xfa
    22c0:	0080      	lsls	r0, r0, #2
    22c2:	4b03      	ldr	r3, [pc, #12]	; (22d0 <main+0x1c>)
    22c4:	4798      	blx	r3
    22c6:	e7f8      	b.n	22ba <main+0x6>
    22c8:	0000011d 	.word	0x0000011d
    22cc:	0000255d 	.word	0x0000255d
    22d0:	0000109d 	.word	0x0000109d

000022d4 <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd(List_t *const pxList, ListItem_t *const pxNewListItem)
{
	ListItem_t *const pxIndex = pxList->pxIndex;
    22d4:	6843      	ldr	r3, [r0, #4]
	listTEST_LIST_ITEM_INTEGRITY(pxNewListItem);

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext     = pxIndex;
    22d6:	604b      	str	r3, [r1, #4]
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    22d8:	689a      	ldr	r2, [r3, #8]
    22da:	608a      	str	r2, [r1, #8]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
    22dc:	689a      	ldr	r2, [r3, #8]
    22de:	6051      	str	r1, [r2, #4]
	pxIndex->pxPrevious         = pxNewListItem;
    22e0:	6099      	str	r1, [r3, #8]

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = (void *)pxList;
    22e2:	6108      	str	r0, [r1, #16]

	(pxList->uxNumberOfItems)++;
    22e4:	6803      	ldr	r3, [r0, #0]
    22e6:	3301      	adds	r3, #1
    22e8:	6003      	str	r3, [r0, #0]
}
    22ea:	4770      	bx	lr

000022ec <uxListRemove>:

UBaseType_t uxListRemove(ListItem_t *const pxItemToRemove)
{
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	List_t *const pxList = (List_t *)pxItemToRemove->pvContainer;
    22ec:	6903      	ldr	r3, [r0, #16]

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    22ee:	6842      	ldr	r2, [r0, #4]
    22f0:	6881      	ldr	r1, [r0, #8]
    22f2:	6091      	str	r1, [r2, #8]
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    22f4:	6882      	ldr	r2, [r0, #8]
    22f6:	6841      	ldr	r1, [r0, #4]
    22f8:	6051      	str	r1, [r2, #4]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if (pxList->pxIndex == pxItemToRemove) {
    22fa:	685a      	ldr	r2, [r3, #4]
    22fc:	4290      	cmp	r0, r2
    22fe:	d006      	beq.n	230e <uxListRemove+0x22>
		pxList->pxIndex = pxItemToRemove->pxPrevious;
	} else {
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
    2300:	2200      	movs	r2, #0
    2302:	6102      	str	r2, [r0, #16]
	(pxList->uxNumberOfItems)--;
    2304:	681a      	ldr	r2, [r3, #0]
    2306:	3a01      	subs	r2, #1
    2308:	601a      	str	r2, [r3, #0]

	return pxList->uxNumberOfItems;
    230a:	6818      	ldr	r0, [r3, #0]
}
    230c:	4770      	bx	lr
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    230e:	6882      	ldr	r2, [r0, #8]
    2310:	605a      	str	r2, [r3, #4]
    2312:	e7f5      	b.n	2300 <uxListRemove+0x14>

00002314 <SVCall_Handler>:

void vPortSVCHandler(void)
{
	/* This function is no longer used, but retained for backward
	compatibility. */
}
    2314:	4770      	bx	lr

00002316 <ulSetInterruptMaskFromISR>:
}
/*-----------------------------------------------------------*/

uint32_t ulSetInterruptMaskFromISR(void)
{
	__asm volatile(" mrs r0, PRIMASK	\n"
    2316:	f3ef 8010 	mrs	r0, PRIMASK
    231a:	b672      	cpsid	i
    231c:	4770      	bx	lr

0000231e <vClearInterruptMaskFromISR>:
}
/*-----------------------------------------------------------*/

void vClearInterruptMaskFromISR(__attribute__((unused)) uint32_t ulMask)
{
	__asm volatile(" msr PRIMASK, r0	\n"
    231e:	f380 8810 	msr	PRIMASK, r0
    2322:	4770      	bx	lr
	...

00002330 <PendSV_Handler>:

void xPortPendSVHandler(void)
{
	/* This is a naked function. */

	__asm volatile(
    2330:	f3ef 8009 	mrs	r0, PSP
    2334:	4b0e      	ldr	r3, [pc, #56]	; (2370 <pxCurrentTCBConst>)
    2336:	681a      	ldr	r2, [r3, #0]
    2338:	3820      	subs	r0, #32
    233a:	6010      	str	r0, [r2, #0]
    233c:	c0f0      	stmia	r0!, {r4, r5, r6, r7}
    233e:	4644      	mov	r4, r8
    2340:	464d      	mov	r5, r9
    2342:	4656      	mov	r6, sl
    2344:	465f      	mov	r7, fp
    2346:	c0f0      	stmia	r0!, {r4, r5, r6, r7}
    2348:	b508      	push	{r3, lr}
    234a:	b672      	cpsid	i
    234c:	f000 f8c6 	bl	24dc <vTaskSwitchContext>
    2350:	b662      	cpsie	i
    2352:	bc0c      	pop	{r2, r3}
    2354:	6811      	ldr	r1, [r2, #0]
    2356:	6808      	ldr	r0, [r1, #0]
    2358:	3010      	adds	r0, #16
    235a:	c8f0      	ldmia	r0!, {r4, r5, r6, r7}
    235c:	46a0      	mov	r8, r4
    235e:	46a9      	mov	r9, r5
    2360:	46b2      	mov	sl, r6
    2362:	46bb      	mov	fp, r7
    2364:	f380 8809 	msr	PSP, r0
    2368:	3820      	subs	r0, #32
    236a:	c8f0      	ldmia	r0!, {r4, r5, r6, r7}
    236c:	4718      	bx	r3
    236e:	46c0      	nop			; (mov r8, r8)

00002370 <pxCurrentTCBConst>:
    2370:	200001d0 	.word	0x200001d0

00002374 <SysTick_Handler>:
	    "pxCurrentTCBConst: .word pxCurrentTCB	  ");
}
/*-----------------------------------------------------------*/

void xPortSysTickHandler(void)
{
    2374:	b510      	push	{r4, lr}
	uint32_t ulPreviousMask;

	ulPreviousMask = portSET_INTERRUPT_MASK_FROM_ISR();
    2376:	4b07      	ldr	r3, [pc, #28]	; (2394 <SysTick_Handler+0x20>)
    2378:	4798      	blx	r3
    237a:	0004      	movs	r4, r0
	{
		/* Increment the RTOS tick. */
		if (xTaskIncrementTick() != pdFALSE) {
    237c:	4b06      	ldr	r3, [pc, #24]	; (2398 <SysTick_Handler+0x24>)
    237e:	4798      	blx	r3
    2380:	2800      	cmp	r0, #0
    2382:	d003      	beq.n	238c <SysTick_Handler+0x18>
			/* Pend a context switch. */
			*(portNVIC_INT_CTRL) = portNVIC_PENDSVSET;
    2384:	2280      	movs	r2, #128	; 0x80
    2386:	0552      	lsls	r2, r2, #21
    2388:	4b04      	ldr	r3, [pc, #16]	; (239c <SysTick_Handler+0x28>)
    238a:	601a      	str	r2, [r3, #0]
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR(ulPreviousMask);
    238c:	0020      	movs	r0, r4
    238e:	4b04      	ldr	r3, [pc, #16]	; (23a0 <SysTick_Handler+0x2c>)
    2390:	4798      	blx	r3
}
    2392:	bd10      	pop	{r4, pc}
    2394:	00002317 	.word	0x00002317
    2398:	000023d5 	.word	0x000023d5
    239c:	e000ed04 	.word	0xe000ed04
    23a0:	0000231f 	.word	0x0000231f

000023a4 <prvResetNextTaskUnblockTime>:

static void prvResetNextTaskUnblockTime(void)
{
	TCB_t *pxTCB;

	if (listLIST_IS_EMPTY(pxDelayedTaskList) != pdFALSE) {
    23a4:	4b0a      	ldr	r3, [pc, #40]	; (23d0 <prvResetNextTaskUnblockTime+0x2c>)
    23a6:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    23a8:	681b      	ldr	r3, [r3, #0]
    23aa:	2b00      	cmp	r3, #0
    23ac:	d109      	bne.n	23c2 <prvResetNextTaskUnblockTime+0x1e>
    23ae:	3301      	adds	r3, #1
    23b0:	2b00      	cmp	r3, #0
    23b2:	d108      	bne.n	23c6 <prvResetNextTaskUnblockTime+0x22>
	} else {
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		(pxTCB)              = (TCB_t *)listGET_OWNER_OF_HEAD_ENTRY(pxDelayedTaskList);
    23b4:	4b06      	ldr	r3, [pc, #24]	; (23d0 <prvResetNextTaskUnblockTime+0x2c>)
    23b6:	6a9a      	ldr	r2, [r3, #40]	; 0x28
    23b8:	68d2      	ldr	r2, [r2, #12]
    23ba:	68d2      	ldr	r2, [r2, #12]
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE(&((pxTCB)->xStateListItem));
    23bc:	6852      	ldr	r2, [r2, #4]
    23be:	62da      	str	r2, [r3, #44]	; 0x2c
	}
}
    23c0:	4770      	bx	lr
	if (listLIST_IS_EMPTY(pxDelayedTaskList) != pdFALSE) {
    23c2:	2300      	movs	r3, #0
    23c4:	e7f4      	b.n	23b0 <prvResetNextTaskUnblockTime+0xc>
		xNextTaskUnblockTime = portMAX_DELAY;
    23c6:	2201      	movs	r2, #1
    23c8:	4252      	negs	r2, r2
    23ca:	4b01      	ldr	r3, [pc, #4]	; (23d0 <prvResetNextTaskUnblockTime+0x2c>)
    23cc:	62da      	str	r2, [r3, #44]	; 0x2c
    23ce:	e7f7      	b.n	23c0 <prvResetNextTaskUnblockTime+0x1c>
    23d0:	2000010c 	.word	0x2000010c

000023d4 <xTaskIncrementTick>:
{
    23d4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	if (uxSchedulerSuspended == (UBaseType_t)pdFALSE) {
    23d6:	4b3c      	ldr	r3, [pc, #240]	; (24c8 <xTaskIncrementTick+0xf4>)
    23d8:	6d9b      	ldr	r3, [r3, #88]	; 0x58
    23da:	2b00      	cmp	r3, #0
    23dc:	d167      	bne.n	24ae <xTaskIncrementTick+0xda>
		const TickType_t xConstTickCount = xTickCount + (TickType_t)1;
    23de:	4b3a      	ldr	r3, [pc, #232]	; (24c8 <xTaskIncrementTick+0xf4>)
    23e0:	6d5d      	ldr	r5, [r3, #84]	; 0x54
    23e2:	3501      	adds	r5, #1
		xTickCount = xConstTickCount;
    23e4:	655d      	str	r5, [r3, #84]	; 0x54
		if (xConstTickCount
    23e6:	2d00      	cmp	r5, #0
    23e8:	d111      	bne.n	240e <xTaskIncrementTick+0x3a>
			taskSWITCH_DELAYED_LISTS();
    23ea:	4b38      	ldr	r3, [pc, #224]	; (24cc <xTaskIncrementTick+0xf8>)
    23ec:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    23ee:	681b      	ldr	r3, [r3, #0]
    23f0:	2b00      	cmp	r3, #0
    23f2:	d001      	beq.n	23f8 <xTaskIncrementTick+0x24>
    23f4:	b672      	cpsid	i
    23f6:	e7fe      	b.n	23f6 <xTaskIncrementTick+0x22>
    23f8:	4a34      	ldr	r2, [pc, #208]	; (24cc <xTaskIncrementTick+0xf8>)
    23fa:	6a91      	ldr	r1, [r2, #40]	; 0x28
    23fc:	4b32      	ldr	r3, [pc, #200]	; (24c8 <xTaskIncrementTick+0xf4>)
    23fe:	6bd8      	ldr	r0, [r3, #60]	; 0x3c
    2400:	6290      	str	r0, [r2, #40]	; 0x28
    2402:	63d9      	str	r1, [r3, #60]	; 0x3c
    2404:	6e1a      	ldr	r2, [r3, #96]	; 0x60
    2406:	3201      	adds	r2, #1
    2408:	661a      	str	r2, [r3, #96]	; 0x60
    240a:	4b31      	ldr	r3, [pc, #196]	; (24d0 <xTaskIncrementTick+0xfc>)
    240c:	4798      	blx	r3
		if (xConstTickCount >= xNextTaskUnblockTime) {
    240e:	4b2f      	ldr	r3, [pc, #188]	; (24cc <xTaskIncrementTick+0xf8>)
    2410:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    2412:	429d      	cmp	r5, r3
    2414:	d23f      	bcs.n	2496 <xTaskIncrementTick+0xc2>
	BaseType_t xSwitchRequired = pdFALSE;
    2416:	2400      	movs	r4, #0
			if (listCURRENT_LIST_LENGTH(&(pxReadyTasksLists[pxCurrentTCB->uxPriority])) > (UBaseType_t)1) {
    2418:	4b2b      	ldr	r3, [pc, #172]	; (24c8 <xTaskIncrementTick+0xf4>)
    241a:	6c5b      	ldr	r3, [r3, #68]	; 0x44
    241c:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    241e:	0093      	lsls	r3, r2, #2
    2420:	189b      	adds	r3, r3, r2
    2422:	009a      	lsls	r2, r3, #2
    2424:	4b29      	ldr	r3, [pc, #164]	; (24cc <xTaskIncrementTick+0xf8>)
    2426:	189b      	adds	r3, r3, r2
    2428:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    242a:	2b01      	cmp	r3, #1
    242c:	d944      	bls.n	24b8 <xTaskIncrementTick+0xe4>
				xSwitchRequired = pdTRUE;
    242e:	2401      	movs	r4, #1
    2430:	e042      	b.n	24b8 <xTaskIncrementTick+0xe4>
							xSwitchRequired = pdTRUE;
    2432:	2401      	movs	r4, #1
				if (listLIST_IS_EMPTY(pxDelayedTaskList) != pdFALSE) {
    2434:	4b25      	ldr	r3, [pc, #148]	; (24cc <xTaskIncrementTick+0xf8>)
    2436:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    2438:	681b      	ldr	r3, [r3, #0]
    243a:	2b00      	cmp	r3, #0
    243c:	d02d      	beq.n	249a <xTaskIncrementTick+0xc6>
    243e:	2300      	movs	r3, #0
    2440:	2b00      	cmp	r3, #0
    2442:	d12c      	bne.n	249e <xTaskIncrementTick+0xca>
					pxTCB      = (TCB_t *)listGET_OWNER_OF_HEAD_ENTRY(pxDelayedTaskList);
    2444:	4b21      	ldr	r3, [pc, #132]	; (24cc <xTaskIncrementTick+0xf8>)
    2446:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    2448:	68db      	ldr	r3, [r3, #12]
    244a:	68de      	ldr	r6, [r3, #12]
					xItemValue = listGET_LIST_ITEM_VALUE(&(pxTCB->xStateListItem));
    244c:	6873      	ldr	r3, [r6, #4]
					if (xConstTickCount < xItemValue) {
    244e:	429d      	cmp	r5, r3
    2450:	d32a      	bcc.n	24a8 <xTaskIncrementTick+0xd4>
					(void)uxListRemove(&(pxTCB->xStateListItem));
    2452:	1d37      	adds	r7, r6, #4
    2454:	0038      	movs	r0, r7
    2456:	4b1f      	ldr	r3, [pc, #124]	; (24d4 <xTaskIncrementTick+0x100>)
    2458:	4798      	blx	r3
					if (listLIST_ITEM_CONTAINER(&(pxTCB->xEventListItem)) != NULL) {
    245a:	6ab3      	ldr	r3, [r6, #40]	; 0x28
    245c:	2b00      	cmp	r3, #0
    245e:	d003      	beq.n	2468 <xTaskIncrementTick+0x94>
						(void)uxListRemove(&(pxTCB->xEventListItem));
    2460:	0030      	movs	r0, r6
    2462:	3018      	adds	r0, #24
    2464:	4b1b      	ldr	r3, [pc, #108]	; (24d4 <xTaskIncrementTick+0x100>)
    2466:	4798      	blx	r3
					prvAddTaskToReadyList(pxTCB);
    2468:	6af2      	ldr	r2, [r6, #44]	; 0x2c
    246a:	4b17      	ldr	r3, [pc, #92]	; (24c8 <xTaskIncrementTick+0xf4>)
    246c:	6d1b      	ldr	r3, [r3, #80]	; 0x50
    246e:	429a      	cmp	r2, r3
    2470:	d901      	bls.n	2476 <xTaskIncrementTick+0xa2>
    2472:	4b15      	ldr	r3, [pc, #84]	; (24c8 <xTaskIncrementTick+0xf4>)
    2474:	651a      	str	r2, [r3, #80]	; 0x50
    2476:	0093      	lsls	r3, r2, #2
    2478:	189b      	adds	r3, r3, r2
    247a:	009a      	lsls	r2, r3, #2
    247c:	4813      	ldr	r0, [pc, #76]	; (24cc <xTaskIncrementTick+0xf8>)
    247e:	3030      	adds	r0, #48	; 0x30
    2480:	1880      	adds	r0, r0, r2
    2482:	0039      	movs	r1, r7
    2484:	4b14      	ldr	r3, [pc, #80]	; (24d8 <xTaskIncrementTick+0x104>)
    2486:	4798      	blx	r3
						if (pxTCB->uxPriority >= pxCurrentTCB->uxPriority) {
    2488:	6af2      	ldr	r2, [r6, #44]	; 0x2c
    248a:	4b0f      	ldr	r3, [pc, #60]	; (24c8 <xTaskIncrementTick+0xf4>)
    248c:	6c5b      	ldr	r3, [r3, #68]	; 0x44
    248e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    2490:	429a      	cmp	r2, r3
    2492:	d2ce      	bcs.n	2432 <xTaskIncrementTick+0x5e>
    2494:	e7ce      	b.n	2434 <xTaskIncrementTick+0x60>
    2496:	2400      	movs	r4, #0
    2498:	e7cc      	b.n	2434 <xTaskIncrementTick+0x60>
				if (listLIST_IS_EMPTY(pxDelayedTaskList) != pdFALSE) {
    249a:	3301      	adds	r3, #1
    249c:	e7d0      	b.n	2440 <xTaskIncrementTick+0x6c>
					    = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    249e:	2201      	movs	r2, #1
    24a0:	4252      	negs	r2, r2
    24a2:	4b0a      	ldr	r3, [pc, #40]	; (24cc <xTaskIncrementTick+0xf8>)
    24a4:	62da      	str	r2, [r3, #44]	; 0x2c
					break;
    24a6:	e7b7      	b.n	2418 <xTaskIncrementTick+0x44>
						xNextTaskUnblockTime = xItemValue;
    24a8:	4a08      	ldr	r2, [pc, #32]	; (24cc <xTaskIncrementTick+0xf8>)
    24aa:	62d3      	str	r3, [r2, #44]	; 0x2c
						break;
    24ac:	e7b4      	b.n	2418 <xTaskIncrementTick+0x44>
		++uxPendedTicks;
    24ae:	4a06      	ldr	r2, [pc, #24]	; (24c8 <xTaskIncrementTick+0xf4>)
    24b0:	6e53      	ldr	r3, [r2, #100]	; 0x64
    24b2:	3301      	adds	r3, #1
    24b4:	6653      	str	r3, [r2, #100]	; 0x64
	BaseType_t xSwitchRequired = pdFALSE;
    24b6:	2400      	movs	r4, #0
		if (xYieldPending != pdFALSE) {
    24b8:	4b03      	ldr	r3, [pc, #12]	; (24c8 <xTaskIncrementTick+0xf4>)
    24ba:	6e9b      	ldr	r3, [r3, #104]	; 0x68
    24bc:	2b00      	cmp	r3, #0
    24be:	d000      	beq.n	24c2 <xTaskIncrementTick+0xee>
			xSwitchRequired = pdTRUE;
    24c0:	2401      	movs	r4, #1
}
    24c2:	0020      	movs	r0, r4
    24c4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    24c6:	46c0      	nop			; (mov r8, r8)
    24c8:	2000018c 	.word	0x2000018c
    24cc:	2000010c 	.word	0x2000010c
    24d0:	000023a5 	.word	0x000023a5
    24d4:	000022ed 	.word	0x000022ed
    24d8:	000022d5 	.word	0x000022d5

000024dc <vTaskSwitchContext>:
{
    24dc:	b510      	push	{r4, lr}
	if (uxSchedulerSuspended != (UBaseType_t)pdFALSE) {
    24de:	4b1d      	ldr	r3, [pc, #116]	; (2554 <vTaskSwitchContext+0x78>)
    24e0:	6d9b      	ldr	r3, [r3, #88]	; 0x58
    24e2:	2b00      	cmp	r3, #0
    24e4:	d10f      	bne.n	2506 <vTaskSwitchContext+0x2a>
		xYieldPending = pdFALSE;
    24e6:	4b1b      	ldr	r3, [pc, #108]	; (2554 <vTaskSwitchContext+0x78>)
    24e8:	2200      	movs	r2, #0
    24ea:	669a      	str	r2, [r3, #104]	; 0x68
		taskSELECT_HIGHEST_PRIORITY_TASK();
    24ec:	6d1b      	ldr	r3, [r3, #80]	; 0x50
    24ee:	009a      	lsls	r2, r3, #2
    24f0:	18d2      	adds	r2, r2, r3
    24f2:	0091      	lsls	r1, r2, #2
    24f4:	4a18      	ldr	r2, [pc, #96]	; (2558 <vTaskSwitchContext+0x7c>)
    24f6:	1852      	adds	r2, r2, r1
    24f8:	6b12      	ldr	r2, [r2, #48]	; 0x30
    24fa:	2a00      	cmp	r2, #0
    24fc:	d109      	bne.n	2512 <vTaskSwitchContext+0x36>
    24fe:	2b00      	cmp	r3, #0
    2500:	d005      	beq.n	250e <vTaskSwitchContext+0x32>
    2502:	3b01      	subs	r3, #1
    2504:	e7f3      	b.n	24ee <vTaskSwitchContext+0x12>
		xYieldPending = pdTRUE;
    2506:	2201      	movs	r2, #1
    2508:	4b12      	ldr	r3, [pc, #72]	; (2554 <vTaskSwitchContext+0x78>)
    250a:	669a      	str	r2, [r3, #104]	; 0x68
}
    250c:	bd10      	pop	{r4, pc}
		taskSELECT_HIGHEST_PRIORITY_TASK();
    250e:	b672      	cpsid	i
    2510:	e7fe      	b.n	2510 <vTaskSwitchContext+0x34>
    2512:	4a11      	ldr	r2, [pc, #68]	; (2558 <vTaskSwitchContext+0x7c>)
    2514:	0099      	lsls	r1, r3, #2
    2516:	18cc      	adds	r4, r1, r3
    2518:	00a0      	lsls	r0, r4, #2
    251a:	1810      	adds	r0, r2, r0
    251c:	6b44      	ldr	r4, [r0, #52]	; 0x34
    251e:	6864      	ldr	r4, [r4, #4]
    2520:	6344      	str	r4, [r0, #52]	; 0x34
    2522:	3230      	adds	r2, #48	; 0x30
    2524:	18c9      	adds	r1, r1, r3
    2526:	0088      	lsls	r0, r1, #2
    2528:	3008      	adds	r0, #8
    252a:	1812      	adds	r2, r2, r0
    252c:	4294      	cmp	r4, r2
    252e:	d00a      	beq.n	2546 <vTaskSwitchContext+0x6a>
    2530:	009a      	lsls	r2, r3, #2
    2532:	18d2      	adds	r2, r2, r3
    2534:	0091      	lsls	r1, r2, #2
    2536:	4a08      	ldr	r2, [pc, #32]	; (2558 <vTaskSwitchContext+0x7c>)
    2538:	1852      	adds	r2, r2, r1
    253a:	6b52      	ldr	r2, [r2, #52]	; 0x34
    253c:	68d1      	ldr	r1, [r2, #12]
    253e:	4a05      	ldr	r2, [pc, #20]	; (2554 <vTaskSwitchContext+0x78>)
    2540:	6451      	str	r1, [r2, #68]	; 0x44
    2542:	6513      	str	r3, [r2, #80]	; 0x50
}
    2544:	e7e2      	b.n	250c <vTaskSwitchContext+0x30>
		taskSELECT_HIGHEST_PRIORITY_TASK();
    2546:	6860      	ldr	r0, [r4, #4]
    2548:	0089      	lsls	r1, r1, #2
    254a:	4a03      	ldr	r2, [pc, #12]	; (2558 <vTaskSwitchContext+0x7c>)
    254c:	1852      	adds	r2, r2, r1
    254e:	6350      	str	r0, [r2, #52]	; 0x34
    2550:	e7ee      	b.n	2530 <vTaskSwitchContext+0x54>
    2552:	46c0      	nop			; (mov r8, r8)
    2554:	2000018c 	.word	0x2000018c
    2558:	2000010c 	.word	0x2000010c

0000255c <AFE_I2C_test>:
 */ 
#include "afe76942.h"


void AFE_I2C_test(void)
{
    255c:	b510      	push	{r4, lr}
    255e:	b082      	sub	sp, #8
	struct io_descriptor *AFE_I2C_io;
	static uint8_t Addr=0x08 ;
	uint8_t DeviCeNumberCmd[3]={0x3E,5};
    2560:	2203      	movs	r2, #3
    2562:	2100      	movs	r1, #0
    2564:	4668      	mov	r0, sp
    2566:	4b12      	ldr	r3, [pc, #72]	; (25b0 <AFE_I2C_test+0x54>)
    2568:	4798      	blx	r3
    256a:	233e      	movs	r3, #62	; 0x3e
    256c:	466a      	mov	r2, sp
    256e:	7013      	strb	r3, [r2, #0]
    2570:	3b39      	subs	r3, #57	; 0x39
    2572:	7053      	strb	r3, [r2, #1]
	static uint8_t DeviCeNumberRead[10] ;
	static uint8_t tcon[2] ;
	
	
	i2c_m_sync_get_io_descriptor(&AFE_I2C, &AFE_I2C_io);
    2574:	4c0f      	ldr	r4, [pc, #60]	; (25b4 <AFE_I2C_test+0x58>)
    2576:	a901      	add	r1, sp, #4
    2578:	0020      	movs	r0, r4
    257a:	4b0f      	ldr	r3, [pc, #60]	; (25b8 <AFE_I2C_test+0x5c>)
    257c:	4798      	blx	r3
	i2c_m_sync_enable(&AFE_I2C);
    257e:	0020      	movs	r0, r4
    2580:	4b0e      	ldr	r3, [pc, #56]	; (25bc <AFE_I2C_test+0x60>)
    2582:	4798      	blx	r3
	i2c_m_sync_set_slaveaddr(&AFE_I2C, 0x08, I2C_M_SEVEN);
    2584:	2280      	movs	r2, #128	; 0x80
    2586:	0112      	lsls	r2, r2, #4
    2588:	2108      	movs	r1, #8
    258a:	0020      	movs	r0, r4
    258c:	4b0c      	ldr	r3, [pc, #48]	; (25c0 <AFE_I2C_test+0x64>)
    258e:	4798      	blx	r3
	io_write(AFE_I2C_io,&DeviCeNumberCmd[0], 2);
    2590:	2202      	movs	r2, #2
    2592:	4669      	mov	r1, sp
    2594:	9801      	ldr	r0, [sp, #4]
    2596:	4b0b      	ldr	r3, [pc, #44]	; (25c4 <AFE_I2C_test+0x68>)
    2598:	4798      	blx	r3
	io_read(AFE_I2C_io,&DeviCeNumberRead[0], 3);
    259a:	2203      	movs	r2, #3
    259c:	490a      	ldr	r1, [pc, #40]	; (25c8 <AFE_I2C_test+0x6c>)
    259e:	9801      	ldr	r0, [sp, #4]
    25a0:	4b0a      	ldr	r3, [pc, #40]	; (25cc <AFE_I2C_test+0x70>)
    25a2:	4798      	blx	r3
	delay_ms(100);
    25a4:	2064      	movs	r0, #100	; 0x64
    25a6:	4b0a      	ldr	r3, [pc, #40]	; (25d0 <AFE_I2C_test+0x74>)
    25a8:	4798      	blx	r3
    25aa:	b002      	add	sp, #8
    25ac:	bd10      	pop	{r4, pc}
    25ae:	46c0      	nop			; (mov r8, r8)
    25b0:	00002671 	.word	0x00002671
    25b4:	2000029c 	.word	0x2000029c
    25b8:	000011fb 	.word	0x000011fb
    25bc:	000011dd 	.word	0x000011dd
    25c0:	000011e9 	.word	0x000011e9
    25c4:	00001205 	.word	0x00001205
    25c8:	200001f8 	.word	0x200001f8
    25cc:	0000123d 	.word	0x0000123d
    25d0:	0000109d 	.word	0x0000109d

000025d4 <__ffssi2>:
    25d4:	b510      	push	{r4, lr}
    25d6:	2300      	movs	r3, #0
    25d8:	2800      	cmp	r0, #0
    25da:	d002      	beq.n	25e2 <__ffssi2+0xe>
    25dc:	f000 f804 	bl	25e8 <__ctzsi2>
    25e0:	1c43      	adds	r3, r0, #1
    25e2:	0018      	movs	r0, r3
    25e4:	bd10      	pop	{r4, pc}
    25e6:	46c0      	nop			; (mov r8, r8)

000025e8 <__ctzsi2>:
    25e8:	4241      	negs	r1, r0
    25ea:	4008      	ands	r0, r1
    25ec:	211c      	movs	r1, #28
    25ee:	2301      	movs	r3, #1
    25f0:	041b      	lsls	r3, r3, #16
    25f2:	4298      	cmp	r0, r3
    25f4:	d301      	bcc.n	25fa <__ctzsi2+0x12>
    25f6:	0c00      	lsrs	r0, r0, #16
    25f8:	3910      	subs	r1, #16
    25fa:	0a1b      	lsrs	r3, r3, #8
    25fc:	4298      	cmp	r0, r3
    25fe:	d301      	bcc.n	2604 <__ctzsi2+0x1c>
    2600:	0a00      	lsrs	r0, r0, #8
    2602:	3908      	subs	r1, #8
    2604:	091b      	lsrs	r3, r3, #4
    2606:	4298      	cmp	r0, r3
    2608:	d301      	bcc.n	260e <__ctzsi2+0x26>
    260a:	0900      	lsrs	r0, r0, #4
    260c:	3904      	subs	r1, #4
    260e:	a202      	add	r2, pc, #8	; (adr r2, 2618 <__ctzsi2+0x30>)
    2610:	5c10      	ldrb	r0, [r2, r0]
    2612:	1a40      	subs	r0, r0, r1
    2614:	4770      	bx	lr
    2616:	46c0      	nop			; (mov r8, r8)
    2618:	1d1d1c1b 	.word	0x1d1d1c1b
    261c:	1e1e1e1e 	.word	0x1e1e1e1e
    2620:	1f1f1f1f 	.word	0x1f1f1f1f
    2624:	1f1f1f1f 	.word	0x1f1f1f1f

00002628 <__libc_init_array>:
    2628:	b570      	push	{r4, r5, r6, lr}
    262a:	2600      	movs	r6, #0
    262c:	4d0c      	ldr	r5, [pc, #48]	; (2660 <__libc_init_array+0x38>)
    262e:	4c0d      	ldr	r4, [pc, #52]	; (2664 <__libc_init_array+0x3c>)
    2630:	1b64      	subs	r4, r4, r5
    2632:	10a4      	asrs	r4, r4, #2
    2634:	42a6      	cmp	r6, r4
    2636:	d109      	bne.n	264c <__libc_init_array+0x24>
    2638:	2600      	movs	r6, #0
    263a:	f000 f91f 	bl	287c <_init>
    263e:	4d0a      	ldr	r5, [pc, #40]	; (2668 <__libc_init_array+0x40>)
    2640:	4c0a      	ldr	r4, [pc, #40]	; (266c <__libc_init_array+0x44>)
    2642:	1b64      	subs	r4, r4, r5
    2644:	10a4      	asrs	r4, r4, #2
    2646:	42a6      	cmp	r6, r4
    2648:	d105      	bne.n	2656 <__libc_init_array+0x2e>
    264a:	bd70      	pop	{r4, r5, r6, pc}
    264c:	00b3      	lsls	r3, r6, #2
    264e:	58eb      	ldr	r3, [r5, r3]
    2650:	4798      	blx	r3
    2652:	3601      	adds	r6, #1
    2654:	e7ee      	b.n	2634 <__libc_init_array+0xc>
    2656:	00b3      	lsls	r3, r6, #2
    2658:	58eb      	ldr	r3, [r5, r3]
    265a:	4798      	blx	r3
    265c:	3601      	adds	r6, #1
    265e:	e7f2      	b.n	2646 <__libc_init_array+0x1e>
    2660:	00002888 	.word	0x00002888
    2664:	00002888 	.word	0x00002888
    2668:	00002888 	.word	0x00002888
    266c:	0000288c 	.word	0x0000288c

00002670 <memset>:
    2670:	0003      	movs	r3, r0
    2672:	1882      	adds	r2, r0, r2
    2674:	4293      	cmp	r3, r2
    2676:	d100      	bne.n	267a <memset+0xa>
    2678:	4770      	bx	lr
    267a:	7019      	strb	r1, [r3, #0]
    267c:	3301      	adds	r3, #1
    267e:	e7f9      	b.n	2674 <memset+0x4>
    2680:	682f2e2e 	.word	0x682f2e2e
    2684:	732f6c61 	.word	0x732f6c61
    2688:	682f6372 	.word	0x682f6372
    268c:	615f6c61 	.word	0x615f6c61
    2690:	645f6364 	.word	0x645f6364
    2694:	632e616d 	.word	0x632e616d
    2698:	00000000 	.word	0x00000000
    269c:	682f2e2e 	.word	0x682f2e2e
    26a0:	732f6c61 	.word	0x732f6c61
    26a4:	682f6372 	.word	0x682f6372
    26a8:	695f6c61 	.word	0x695f6c61
    26ac:	6d5f6332 	.word	0x6d5f6332
    26b0:	6e79735f 	.word	0x6e79735f
    26b4:	00632e63 	.word	0x00632e63
    26b8:	682f2e2e 	.word	0x682f2e2e
    26bc:	732f6c61 	.word	0x732f6c61
    26c0:	682f6372 	.word	0x682f6372
    26c4:	695f6c61 	.word	0x695f6c61
    26c8:	00632e6f 	.word	0x00632e6f
    26cc:	682f2e2e 	.word	0x682f2e2e
    26d0:	732f6c61 	.word	0x732f6c61
    26d4:	682f6372 	.word	0x682f6372
    26d8:	735f6c61 	.word	0x735f6c61
    26dc:	6d5f6970 	.word	0x6d5f6970
    26e0:	6e79735f 	.word	0x6e79735f
    26e4:	00632e63 	.word	0x00632e63

000026e8 <_adcs>:
    26e8:	00000000 00000010 00000000 00000000     ................
	...
    2704:	00000001 00000010 00000000 00000000     ................
	...
    2720:	682f2e2e 612f6c70 682f6364 615f6c70     ../hpl/adc/hpl_a
    2730:	632e6364 00000000                       dc.c....

00002738 <_map>:
    2738:	00000000 00000048 00000001 00000059     ....H.......Y...
    2748:	00000002 0000005a 00000003 0000004b     ....Z.......K...
    2758:	00000006 00000036 00000008 00000038     ....6.......8...
    2768:	0000000a 0000000a 0000000b 0000000b     ................
    2778:	0000000c 0000000c 0000000d 0000000d     ................
    2788:	0000000e 0000002e 682f2e2e 652f6c70     ........../hpl/e
    2798:	682f6369 655f6c70 632e6369 00000000     ic/hpl_eic.c....
    27a8:	42000400 42000800 42000c00 42001000     ...B...B...B...B
    27b8:	42001400 42001800 43000000 43000400     ...B...B...C...C

000027c8 <_usarts>:
	...

000027dc <_i2cms>:
    27dc:	00000000 00200014 00000100 00000f0e     ...... .........
    27ec:	00d70000 003d0900 00000001 00200014     ......=....... .
    27fc:	00000100 00000f0e 00d70000 003d0900     ..............=.
    280c:	00000004 00200014 00000100 00000f0e     ...... .........
    281c:	00d70000 003d0900 00000005 00200014     ......=....... .
    282c:	00000100 00000f0e 00d70000 003d0900     ..............=.

0000283c <_i2css>:
	...

0000284c <sercomspi_regs>:
    284c:	0002000c 00020000 00000000 01ff0027     ............'...
    285c:	00000003 682f2e2e 732f6c70 6f637265     ....../hpl/serco
    286c:	70682f6d 65735f6c 6d6f6372 0000632e     m/hpl_sercom.c..

0000287c <_init>:
    287c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    287e:	46c0      	nop			; (mov r8, r8)
    2880:	bcf8      	pop	{r3, r4, r5, r6, r7}
    2882:	bc08      	pop	{r3}
    2884:	469e      	mov	lr, r3
    2886:	4770      	bx	lr

00002888 <__init_array_start>:
    2888:	000000e5 	.word	0x000000e5

0000288c <_fini>:
    288c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    288e:	46c0      	nop			; (mov r8, r8)
    2890:	bcf8      	pop	{r3, r4, r5, r6, r7}
    2892:	bc08      	pop	{r3}
    2894:	469e      	mov	lr, r3
    2896:	4770      	bx	lr

00002898 <__fini_array_start>:
    2898:	000000bd 	.word	0x000000bd
